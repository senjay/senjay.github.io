<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>OpenGL笔记1</title>
    <link href="/2020/07/01/2020-07-01-OpenGL%E7%AC%94%E8%AE%B01/"/>
    <url>/2020/07/01/2020-07-01-OpenGL%E7%AC%94%E8%AE%B01/</url>
    
    <content type="html"><![CDATA[<h2 id="1-初始化"><a href="#1-初始化" class="headerlink" title="1.初始化"></a>1.初始化</h2><pre><code class="hljs c++">glewExperimental = GL_TRUE;<span class="hljs-comment">//让GLEW在管理OpenGL的函数指针时更多地使用现代化的技术</span><span class="hljs-keyword">if</span> (glewInit() != GLEW_OK)<span class="hljs-comment">//初始化</span>&#123;    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Failed to initialize GLEW"</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;&#125;</code></pre><div class="note note-warning">            <p>如果是以静态库调用glew,务必在开头加上预编译的头<code>#define GLEW_STATIC</code></p>          </div><h2 id="2-基本流程"><a href="#2-基本流程" class="headerlink" title="2.基本流程"></a>2.基本流程</h2><p>&emsp;&emsp;首先创建一个对象，然后用一个id保存它的引用（实际数据被储存在后台）。然后将对象绑定至上下文的目标位置（例子中窗口对象目标的位置被定义成<code>GL_WINDOW_TARGET</code>）。接下来设置窗口的选项。最后将目标位置的对象id设回0，解绑这个对象。设置的选项将被保存在<code>objectId</code>所引用的对象中，一旦我们重新绑定这个对象到<code>GL_WINDOW_TARGET</code>位置，这些选项就会重新生效。</p><pre><code class="hljs c++"><span class="hljs-comment">// 创建对象</span>GLuint objectId = <span class="hljs-number">0</span>;glGenObject(<span class="hljs-number">1</span>, &amp;objectId);<span class="hljs-comment">// 绑定对象至上下文</span>glBindObject(GL_WINDOW_TARGET, objectId);<span class="hljs-comment">// 设置当前绑定到 GL_WINDOW_TARGET 的对象的一些选项</span>glSetObjectOption(GL_WINDOW_TARGET, GL_OPTION_WINDOW_WIDTH, <span class="hljs-number">800</span>);glSetObjectOption(GL_WINDOW_TARGET, GL_OPTION_WINDOW_HEIGHT, <span class="hljs-number">600</span>);<span class="hljs-comment">// 将上下文对象设回默认</span>glBindObject(GL_WINDOW_TARGET, <span class="hljs-number">0</span>);</code></pre><div class="note note-info">            <p>简单的理解就是像创建id,然后绑定至OpenGL中的对象，这两步也可以近似理解为实例化一个对象，然后就可以对这个对象进行操作。</p>          </div><h2 id="3-FSM"><a href="#3-FSM" class="headerlink" title="3. FSM"></a>3. FSM</h2><p>&emsp;&emsp;OpenGL的系统是一个有限状态机，因此其函数有两种，状态设置函数(State-changing Function)和状态应用函数(State-using Function)，前者改变OpenGL的状态，只有当进入相应状态，然后执行该状态下的应用函数才会起作用。</p><p>比如</p><pre><code class="hljs c++">glClearColor(<span class="hljs-number">0.2f</span>, <span class="hljs-number">0.3f</span>, <span class="hljs-number">0.3f</span>, <span class="hljs-number">1.0f</span>);<span class="hljs-comment">//rgb(范围0-1),alpha channel    状态设置函数</span>glClear(GL_COLOR_BUFFER_BIT);<span class="hljs-comment">//状态应用函数，真正应用清除颜色</span></code></pre><h2 id="4-VBO"><a href="#4-VBO" class="headerlink" title="4. VBO"></a>4. VBO</h2><p>&emsp;&emsp;顶点缓冲对象为cpu-&gt;gpu的图形的顶点数据，简而言之，通过缓冲一次传一批顶点。</p><pre><code class="hljs c++">GLuint VBO;glGenBuffers(<span class="hljs-number">1</span>, &amp;VBO);  <span class="hljs-comment">//获得VBO id</span>glBindBuffer(GL_ARRAY_BUFFER, VBO);<span class="hljs-comment">//绑定顶点缓冲  </span>glBufferData(GL_ARRAY_BUFFER, <span class="hljs-keyword">sizeof</span>(vertices), vertices, GL_STATIC_DRAW);<span class="hljs-comment">//绑定顶点数据，这一步才真正将顶点数据vertices与buffer绑定</span></code></pre><p>介绍一下第四个参数</p><ul><li><code>GL_STATIC_DRAW</code> ：数据不会或几乎不会改变。</li><li><code>GL_DYNAMIC_DRAW</code>：数据会被改变很多。</li><li><code>GL_STREAM_DRAW</code> ：数据每次绘制时都会改变。</li></ul><h2 id="5-Vertex-Shader"><a href="#5-Vertex-Shader" class="headerlink" title="5.Vertex Shader"></a>5.Vertex Shader</h2><pre><code class="hljs glsl"><span class="hljs-meta">#version 330 core //声明版本</span><span class="hljs-keyword">layout</span> (<span class="hljs-keyword">location</span> = <span class="hljs-number">0</span>) <span class="hljs-keyword">in</span> <span class="hljs-type">vec3</span> position;<span class="hljs-comment">//in关键字声明输入变量的属性，layout(location=x)为输入变量的位置</span><span class="hljs-type">void</span> main()&#123;    <span class="hljs-built_in">gl_Position</span> = <span class="hljs-type">vec4</span>(position.x, position.y, position.z, <span class="hljs-number">1.0</span>);<span class="hljs-comment">//输出给后面，因为输入的是三维向量，将其改成后面需要的齐次坐标形式</span>&#125;</code></pre><div class="note note-info">            <p>Shader 我理解为将一道完整的工序中独立出一个步骤，而这个步骤是由用户自定的，这个步骤有上一道步骤的输入，而我们可以在这里进行编程操作，只要保证输出是符合下一道步骤的输入即可。有点面向切面的味道。</p>          </div><h3 id="5-1-编译Shader"><a href="#5-1-编译Shader" class="headerlink" title="5.1.编译Shader"></a>5.1.编译Shader</h3><pre><code class="hljs c++">GLuint vertexShader;vertexShader = glCreateShader(GL_VERTEX_SHADER);<span class="hljs-comment">//创建一个shader id</span><span class="hljs-comment">//绑定shader代码，参数一次为id,shader 数量，shader代码，第四个如果不为null,它会返回源码数组相应的长度数组</span>glShaderSource(vertexShader, <span class="hljs-number">1</span>, &amp;vertexShaderSource, <span class="hljs-literal">NULL</span>);glCompileShader(vertexShader);<span class="hljs-comment">//编译</span></code></pre><h2 id="6-Fragment-Shader"><a href="#6-Fragment-Shader" class="headerlink" title="6.Fragment Shader"></a>6.Fragment Shader</h2><p>用于颜色</p><pre><code class="hljs glsl"><span class="hljs-meta">#version 330 core</span><span class="hljs-keyword">out</span> <span class="hljs-type">vec4</span> color;<span class="hljs-comment">//out 关键字声明输出该变量</span><span class="hljs-type">void</span> main()&#123;    color = <span class="hljs-type">vec4</span>(<span class="hljs-number">1.0</span>f, <span class="hljs-number">0.5</span>f, <span class="hljs-number">0.2</span>f, <span class="hljs-number">1.0</span>f);<span class="hljs-comment">//输出颜色</span>&#125;</code></pre><h3 id="6-1-编译Shader"><a href="#6-1-编译Shader" class="headerlink" title="6.1 编译Shader"></a>6.1 编译Shader</h3><pre><code class="hljs c++">GLuint fragmentShader;fragmentShader = glCreateShader(GL_FRAGMENT_SHADER);glShaderSource(fragmentShader, <span class="hljs-number">1</span>, &amp;fragmentShaderSource, null);glCompileShader(fragmentShader);</code></pre><h2 id="7-Shader-Program-Object"><a href="#7-Shader-Program-Object" class="headerlink" title="7.Shader Program Object"></a>7.Shader Program Object</h2><p>&emsp;&emsp;要使用刚才编译的着色器我们必须把它们链接为一个着色器程序对象，然后在渲染对象的时候激活这个着色器程序。已激活着色器程序的着色器将在我们发送渲染调用的时候被使用。当链接着色器至一个程序的时候，它会把每个着色器的输出链接到下个着色器的输入。当输出和输入不匹配的时候，你会得到一个连接错误。</p><pre><code class="hljs c++">GLuint shaderProgram;shaderProgram = glCreateProgram();<span class="hljs-comment">//创建一个程序对象</span>glAttachShader(shaderProgram, vertexShader);glAttachShader(shaderProgram, fragmentShader);<span class="hljs-comment">//将shader附加至Program</span>glLinkProgram(shaderProgram);<span class="hljs-comment">//将gl与该program链接，即渲染时采用这个program</span><span class="hljs-comment">//激活使用该着色器对象，调用之后，每个着色器调用和渲染调用都会使用这个程序对象</span>glUseProgram(shaderProgram);<span class="hljs-comment">//链接shader到program后别忘记删除</span>glDeleteShader(vertexShader);glDeleteShader(fragmentShader);</code></pre><h2 id="8-读取顶点（解释自定义的顶点）"><a href="#8-读取顶点（解释自定义的顶点）" class="headerlink" title="8.读取顶点（解释自定义的顶点）"></a>8.读取顶点（解释自定义的顶点）</h2><p>&emsp;&emsp;如果是自定义的顶点数据，该如何解释也是一个问题，可以使用下面的方法解决</p><pre><code class="hljs c++"><span class="hljs-comment">// 0. 复制顶点数组到缓冲中供OpenGL使用</span>glBindBuffer(GL_ARRAY_BUFFER, VBO);glBufferData(GL_ARRAY_BUFFER, <span class="hljs-keyword">sizeof</span>(vertices), vertices, GL_STATIC_DRAW);<span class="hljs-comment">// 1. 设置顶点属性指针</span>glVertexAttribPointer(<span class="hljs-number">0</span>, <span class="hljs-number">3</span>, GL_FLOAT, GL_FALSE, <span class="hljs-number">3</span> * <span class="hljs-keyword">sizeof</span>(GLfloat), (GLvoid*)<span class="hljs-number">0</span>);glEnableVertexAttribArray(<span class="hljs-number">0</span>);<span class="hljs-comment">// 2. 当我们渲染一个物体时要使用着色器程序</span>glUseProgram(shaderProgram);<span class="hljs-comment">// 3. 绘制物体</span>someOpenGLFunctionThatDrawsOurTriangle();</code></pre><p><code>glVertexAttribPointer</code>函数的参数：</p><ul><li>第一个参数指定配置的顶点属性。比如在顶点着色器中使用<code>layout(location = 0)</code>定义了position顶点属性的位置值(Location)它可以把顶点属性的位置值设置为<code>0</code>。因为我们希望把数据传递到这一个顶点属性中，所以这里传入<code>0</code>。</li><li>第二个参数指定顶点属性的大小。顶点属性是一个<code>vec3</code>，它由3个值组成，所以大小是3。</li><li>第三个参数指定数据的类型，这里是<code>GL_FLOAT</code>(GLSL中<code>vec*</code>都是由浮点数值组成的)。</li><li>第四个参数定义是否希望数据被标准化(Normalize)。如果我们设置为<code>GL_TRUE</code>，所有数据都会被映射到0（对于有符号型signed数据是-1）到1之间。它设置为GL_FALSE。</li><li>第五个参数叫做步长(Stride)，它告诉我们在连续的顶点属性组之间的间隔。由于下个组位置数据在3个<code>GLfloat</code>之后，我们把步长设置为<code>3 * sizeof(GLfloat)</code>。</li><li>最后一个参数的类型是<code>GLvoid*</code>，所以需要进行这个奇怪的强制类型转换。它表示位置数据在缓冲中起始位置的偏移量(Offset)。由于位置数据在数组的开头，所以这里是0。</li></ul><div class="note note-success">            <p>每个顶点属性从一个VBO管理的内存中获得它的数据，而具体是从哪个VBO（程序中可以有多个VBO）获取则是通过在调用<code>glVetexAttribPointer</code>时绑定到<code>GL_ARRAY_BUFFER</code>的VBO决定的。由于在调用<code>glVetexAttribPointer</code>之前绑定的是先前定义的VBO对象，顶点属性<code>0</code>现在会链接到它的顶点数据。</p>          </div><h2 id="9-VAO"><a href="#9-VAO" class="headerlink" title="9.VAO"></a>9.VAO</h2><p>&emsp;&emsp;顶点数组对象(Vertex Array Object, VAO)可以像顶点缓冲对象那样被绑定，任何随后的顶点属性调用都会储存在这个VAO中。这样的好处就是，当配置顶点属性指针时，你只需要将那些调用执行一次，之后再绘制物体的时候只需要绑定相应的VAO就行了。这使在不同顶点数据和属性配置之间切换变得非常简单，只需要绑定不同的VAO就行了。刚刚设置的所有状态都将存储在VAO中</p><pre><code class="hljs c++">GLuint VAO;glGenVertexArrays(<span class="hljs-number">1</span>, &amp;VAO); <span class="hljs-comment">//创建VAO</span><span class="hljs-comment">// ..:: 初始化代码（只运行一次 (除非你的物体频繁改变)） :: ..</span><span class="hljs-comment">// 1. 绑定VAO</span>glBindVertexArray(VAO);<span class="hljs-comment">// 2. 把顶点数组复制到缓冲中供OpenGL使用</span>glBindBuffer(GL_ARRAY_BUFFER, VBO);glBufferData(GL_ARRAY_BUFFER, <span class="hljs-keyword">sizeof</span>(vertices), vertices, GL_STATIC_DRAW);<span class="hljs-comment">// 3. 设置顶点属性指针</span>glVertexAttribPointer(<span class="hljs-number">0</span>, <span class="hljs-number">3</span>, GL_FLOAT, GL_FALSE, <span class="hljs-number">3</span> * <span class="hljs-keyword">sizeof</span>(GLfloat), (GLvoid*)<span class="hljs-number">0</span>);glEnableVertexAttribArray(<span class="hljs-number">0</span>);<span class="hljs-comment">//4. 解绑VAO,相当于买完东西后离开，这个东西自己拿去用(比如在绘制东西时再绑定上去)</span>glBindVertexArray(<span class="hljs-number">0</span>);<span class="hljs-comment">// 5. 绘制物体</span>glUseProgram(shaderProgram);<span class="hljs-comment">//使用shader渲染</span>glBindVertexArray(VAO);<span class="hljs-comment">//再绑定</span>glDrawArrays(GL_TRIANGLES, <span class="hljs-number">0</span>, <span class="hljs-number">3</span>);<span class="hljs-comment">//形状，起始点，顶点数量</span>glBindVertexArray(<span class="hljs-number">0</span>);<span class="hljs-comment">//解绑</span></code></pre><p>&emsp;&emsp;流程是：打算绘制多个物体时，首先要生成/配置所有的VAO（和必须的VBO及属性指针)，然后储存它们供后面使用。当要绘制物体的时候就拿出相应的VAO，绑定它，绘制完物体后，再解绑VAO。</p><h2 id="10-EBO"><a href="#10-EBO" class="headerlink" title="10.EBO"></a>10.EBO</h2><p>&emsp;&emsp;索引缓冲对象，通过索引来重用顶点。</p><pre><code class="hljs c++">glDrawArrays(GL_TRIANGLES, <span class="hljs-number">0</span>, <span class="hljs-number">3</span>);GLuint EBO;glGenBuffers(<span class="hljs-number">1</span>, &amp;EBO);<span class="hljs-comment">//创建对象id</span>glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, EBO);glBufferData(GL_ELEMENT_ARRAY_BUFFER,<span class="hljs-keyword">sizeof</span>(indices),indices,GL_STATIC_DRAW); <span class="hljs-comment">//绑定索引</span><span class="hljs-comment">//此时，绘制方法改变，即不再使用glDrawArrays</span>glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, EBO);<span class="hljs-comment">//绑定EBO</span>glDrawElements(GL_TRIANGLES, <span class="hljs-number">6</span>, GL_UNSIGNED_INT, <span class="hljs-number">0</span>);<span class="hljs-comment">//通过索引方法来绘制，形状，顶点数，索引类型，EBO偏移量</span></code></pre><h2 id="11-线框模式"><a href="#11-线框模式" class="headerlink" title="11.线框模式"></a>11.线框模式</h2><p>&emsp;&emsp;要想用线框模式绘制你的三角形，可以通过<code>glPolygonMode(GL_FRONT_AND_BACK, GL_LINE)</code>函数配置OpenGL如何绘制图元。第一个参数表示将其应用到所有的三角形的正面和背面，第二个参数表示用线来绘制。之后的绘制调用会一直以线框模式绘制三角形，直到我们用<code>glPolygonMode(GL_FRONT_AND_BACK, GL_FILL)</code>将其设置回默认模式。</p><h2 id="12-总结"><a href="#12-总结" class="headerlink" title="12.总结"></a>12.总结</h2><p>&emsp;&emsp;在绑定VAO时如果绑定了EBO，VAO也会存储索引。当目标是<code>GL_ELEMENT_ARRAY_BUFFER</code>的时候，VAO会储存<code>glBindBuffer</code>的函数调用。这也意味着它也会储存解绑调用，所以确保你没有在解绑VAO之前解绑索引数组缓冲，否则它就没有这个EBO配置了。</p><pre><code class="hljs c++"><span class="hljs-comment">// ..:: 初始化代码 :: ..</span><span class="hljs-comment">// 1. 绑定顶点数组对象</span>glBindVertexArray(VAO);<span class="hljs-comment">// 2. 把我们的顶点数组复制到一个顶点缓冲中，供OpenGL使用</span>glBindBuffer(GL_ARRAY_BUFFER, VBO);glBufferData(GL_ARRAY_BUFFER, <span class="hljs-keyword">sizeof</span>(vertices), vertices, GL_STATIC_DRAW);<span class="hljs-comment">// 3. 复制索引数组到一个索引缓冲中，供OpenGL使用</span>glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, EBO);glBufferData(GL_ELEMENT_ARRAY_BUFFER, <span class="hljs-keyword">sizeof</span>(indices), indices, GL_STATIC_DRAW);<span class="hljs-comment">// 3. 设定顶点属性指针</span>glVertexAttribPointer(<span class="hljs-number">0</span>, <span class="hljs-number">3</span>, GL_FLOAT, GL_FALSE, <span class="hljs-number">3</span> * <span class="hljs-keyword">sizeof</span>(GLfloat), (GLvoid*)<span class="hljs-number">0</span>);glEnableVertexAttribArray(<span class="hljs-number">0</span>);<span class="hljs-comment">// 4. 解绑VAO(不是EBO!)</span>glBindVertexArray(<span class="hljs-number">0</span>);<span class="hljs-comment">//...</span><span class="hljs-comment">// ..:: 绘制代码（游戏循环中） :: ..</span>glUseProgram(shaderProgram);glBindVertexArray(VAO);glDrawElements(GL_TRIANGLES, <span class="hljs-number">6</span>, GL_UNSIGNED_INT, <span class="hljs-number">0</span>)glBindVertexArray(<span class="hljs-number">0</span>);</code></pre>]]></content>
    
    
    <categories>
      
      <category>OpenGL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OpenGL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>VS项目配置项说明</title>
    <link href="/2020/06/28/2020-06-28-VS%E9%A1%B9%E7%9B%AE%E9%85%8D%E7%BD%AE%E9%A1%B9%E8%AF%B4%E6%98%8E/"/>
    <url>/2020/06/28/2020-06-28-VS%E9%A1%B9%E7%9B%AE%E9%85%8D%E7%BD%AE%E9%A1%B9%E8%AF%B4%E6%98%8E/</url>
    
    <content type="html"><![CDATA[<p>​        记录一下vs配置时项目的属性设置，主要是引入三方库时需要用到，不同于cmake这种通过配置文件来操作的，感觉vs这种通过鼠标来设置又蠢又麻烦。。。</p><ul><li>VC++目录：<ul><li>可执行目录：寻找依赖的可执行的文件的目录</li><li>包含目录：寻找#include<xxxx.h>中的xxxx.h的搜索目录</li><li>库目录：寻找.lib文件的搜索目录</li></ul></li><li><p>C/C++:</p><ul><li>常规-&gt;附加包含目录：寻找#include<xxxx.h>中的xxxx.h的搜索目录（每一项对应一个文件夹XXXX，文件夹中包含了编译时所需的头文件，使用时直接#include<XXXX>即可）</li></ul></li><li><p>链接器：</p><ul><li>常规-&gt;附加库目录：寻找.lib文件的搜索目录</li><li>输入-&gt;附加依赖项：lib库（C++的库会把函数、类的声明放在*.h中，实现放在*.cpp或* .cc中。编译之后，*.cpp，*.cc，*.c会被打包成一个.lib文件，这样可以保护源代码）</li></ul></li></ul><p>最终方法为:</p><ol><li>附加包含目录—-添加工程的头文件目录：   项目-&gt;属性-&gt;配置属性-&gt;C/C++-&gt;常规-&gt;附加包含目录：加上头文件的存放目录； </li><li>附加库目录—-添加文件引用的lib静态库路径：   项目-&gt;属性-&gt;配置属性-&gt;链接器-&gt;常规-&gt;附加库目录：加上lib文件的存放目录； </li><li>附加依赖项—-添加工程引用的lib文件名：   项目-&gt;属性-&gt;配置属性-&gt;链接器-&gt;输入-&gt;附加依赖项：加上lib文件名。</li></ol><p>​        <strong>ps</strong>:包含目录：修改了系统的include宏的值，是全局的； 附加包含目录：用于当前项目，对其他项目没有影响。</p><img src="/2020/06/28/2020-06-28-VS%E9%A1%B9%E7%9B%AE%E9%85%8D%E7%BD%AE%E9%A1%B9%E8%AF%B4%E6%98%8E/image-20200628225451830.png" srcset="/img/loading.gif" class="" title="image-20200628225451830"><img src="/2020/06/28/2020-06-28-VS%E9%A1%B9%E7%9B%AE%E9%85%8D%E7%BD%AE%E9%A1%B9%E8%AF%B4%E6%98%8E/image-20200628225507115.png" srcset="/img/loading.gif" class="" title="image-20200628225507115"><img src="/2020/06/28/2020-06-28-VS%E9%A1%B9%E7%9B%AE%E9%85%8D%E7%BD%AE%E9%A1%B9%E8%AF%B4%E6%98%8E/image-20200628225519543.png" srcset="/img/loading.gif" class="" title="image-20200628225519543"><img src="/2020/06/28/2020-06-28-VS%E9%A1%B9%E7%9B%AE%E9%85%8D%E7%BD%AE%E9%A1%B9%E8%AF%B4%E6%98%8E/image-20200628225540868.png" srcset="/img/loading.gif" class="" title="image-20200628225540868"><p><a href="https://blog.csdn.net/raodotcong/article/details/8998379" target="_blank" rel="noopener">更详细的文章</a></p>]]></content>
    
    
    <categories>
      
      <category>配置</category>
      
    </categories>
    
    
    <tags>
      
      <tag>配置</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Blinn-Phong Reflectance Model</title>
    <link href="/2020/06/17/2020-06-17-Blinn-Phong-Reflectance-Model/"/>
    <url>/2020/06/17/2020-06-17-Blinn-Phong-Reflectance-Model/</url>
    
    <content type="html"><![CDATA[<h2 id="光照模型"><a href="#光照模型" class="headerlink" title="光照模型"></a>光照模型</h2><script type="math/tex; mode=display">L=L_d+L_s+L_a</script><p>$L_d$为漫反射光，$L_s$为高光，$L_a$为环境光。</p><h3 id="1-漫反射"><a href="#1-漫反射" class="headerlink" title="1.漫反射"></a>1.漫反射</h3><p>理解：漫反射散向四面八方，与观察方向无关，只与表面接受到的光源的<strong>有效光</strong>有关</p><script type="math/tex; mode=display">L_d=k_d\frac{I}{r^2}max\{0,n\cdot l\}</script><p>$k_d$漫反射系数(范围0至1，表明反射的强度)，$I$光源,$r$表面距光源距离，$n$表明法向量，$l$入射光向量(注意方向为负)</p><p>ps:均为单位向量</p><h3 id="2-高光"><a href="#2-高光" class="headerlink" title="2.高光"></a>2.高光</h3><p>相比于Phong模型，Blinn-Phong模型的高光项采用$l,v$两者的角平分线与$n$的夹角来表示观察方向与镜面反射方向的夹角，从而提高计算效率。</p><script type="math/tex; mode=display">L_s=k_s\frac{I}{r^2}max\{0,n\cdot h\}^p</script><p>$k_s$镜面反射系数(范围0至1，表明反射的强度)，$I$光源,$r$表面距光源距离，$n$表明法向量，$h=\frac{l+v}{|l+v|}$,$p$表示角度的影响，因为高光只在小角度才会起作用，下面是$cos^px$的几个变化图</p><h3 id="3-环境光"><a href="#3-环境光" class="headerlink" title="3.环境光"></a>3.环境光</h3><p>在Blinn-Phong模型中环境光被当作常数处理</p><script type="math/tex; mode=display">L_a=k_aI_a</script><h3 id="4-展示"><a href="#4-展示" class="headerlink" title="4. 展示"></a>4. 展示</h3>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>旋转变换矩阵推导</title>
    <link href="/2020/06/06/2020-06-06-%E6%97%8B%E8%BD%AC%E5%8F%98%E6%8D%A2%E7%9F%A9%E9%98%B5%E6%8E%A8%E5%AF%BC/"/>
    <url>/2020/06/06/2020-06-06-%E6%97%8B%E8%BD%AC%E5%8F%98%E6%8D%A2%E7%9F%A9%E9%98%B5%E6%8E%A8%E5%AF%BC/</url>
    
    <content type="html"><![CDATA[<p>​        </p><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>&emsp;&emsp;先介绍二维旋转变换，然后由此推广到三维绕坐标轴旋转，再推广得到绕三维任意轴旋转的罗德里格斯旋转公式。</p><h2 id="1-二维"><a href="#1-二维" class="headerlink" title="1.二维"></a>1.二维</h2><p>&emsp;&emsp;如果要求$P$逆时针旋转$\theta$得到的$P^{‘}$，记$Q$为$P$逆时针旋转90°后的向量,即$(-P_y,P_x)$,则$P$与$Q$正好组成了<strong>该平面内的一组正交向量</strong>，任何向量都可由其线性表出，由基本几何和三角学可得到：</p><script type="math/tex; mode=display">P^{'}=Pcos\theta+Qsin\theta</script><p>则</p><script type="math/tex; mode=display">\begin{aligned}P_x^{'}&=P_xcos\theta-P_ysin\theta\\P_{y}^{'}&=P_ysin\theta-P_xcos\theta\\\end{aligned}</script><p>写成矩阵为</p><script type="math/tex; mode=display">P^{'}=\begin{bmatrix}cos\theta&-sin\theta\\sin\theta&cos\theta\end{bmatrix}P</script><h2 id="2-三维绕坐标轴旋转"><a href="#2-三维绕坐标轴旋转" class="headerlink" title="2.三维绕坐标轴旋转"></a>2.三维绕坐标轴旋转</h2><img src="/2020/06/06/2020-06-06-%E6%97%8B%E8%BD%AC%E5%8F%98%E6%8D%A2%E7%9F%A9%E9%98%B5%E6%8E%A8%E5%AF%BC/image-20200606172922405.png" srcset="/img/loading.gif" class=""><p>&emsp;&emsp;注意$R_y(\theta)$与其他不同是因为如果按照逆时针旋转，由$x\times z=-y$,则得到$y$轴负方向，因此需改为顺时针，即$-\theta$,这无论是在左手坐标系还是右手系都是相同的。</p><h2 id="3-三维绕任意轴旋转"><a href="#3-三维绕任意轴旋转" class="headerlink" title="3. 三维绕任意轴旋转"></a>3. 三维绕任意轴旋转</h2><p><strong>向量$P$绕任意轴$A$旋转$\theta$角度证明：</strong></p><p>&emsp;&emsp;不妨设$A$为单位向量，同时$P$可分解为与$A$平行和垂直的两个分量，分别为：</p><script type="math/tex; mode=display">\begin{align}P_{projA}&=(A\cdot P)A=AA^TP\\P_{perpA}&=P-(A\cdot P)A=P-AA^TP\end{align}</script><p>如图所示</p><img src="/2020/06/06/2020-06-06-%E6%97%8B%E8%BD%AC%E5%8F%98%E6%8D%A2%E7%9F%A9%E9%98%B5%E6%8E%A8%E5%AF%BC/image-20200606161620614.png" srcset="/img/loading.gif" class=""><p>故最终结果</p><script type="math/tex; mode=display">P^{'}=P_{perpA}^{'}+P_{ProjA}</script><p>其中<script type="math/tex">P_{PerpA}^{'}</script>为<script type="math/tex">P_{perpA}</script>旋转<script type="math/tex">\theta</script>后得到的向量，如图</p><img src="/2020/06/06/2020-06-06-%E6%97%8B%E8%BD%AC%E5%8F%98%E6%8D%A2%E7%9F%A9%E9%98%B5%E6%8E%A8%E5%AF%BC/image-20200606161747676.png" srcset="/img/loading.gif" class=""><p>为求得其值，需找到一组线性组合来表示它，可选<script type="math/tex">P_{perpA}</script>与其旋转90°后的向量这两个向量作为组合，可以得知<script type="math/tex">A\times P</script>即为该向量，同时它的长度是与<script type="math/tex">P_{perpA}</script>相等的，这是因为</p><script type="math/tex; mode=display">|A\times P|=|P|sin\alpha=|P-(A\cdot P)A|</script><p>所以</p><script type="math/tex; mode=display">P_{perpA}^{'}=[P-(A\cdot P)A]cos\theta+(A \times P)sin \theta</script><p>所以</p><script type="math/tex; mode=display">\begin{align}P^{'}&=[P-(A\cdot P)A]cos\theta+(A \times P)sin \theta+(A\cdot P)A\\&=Pcos\theta+A\times P sin\theta+(A\cdot P)A(1-cos\theta)\end{align}</script><p>记$I$为单位阵，则矩阵形式为</p><script type="math/tex; mode=display">P^{'}=\{Icos\theta+\begin{bmatrix} 0&-A_z&A_y\\A_z&0&-A_x\\-A_y&A_x&0\end{bmatrix}sin\theta+AA^T(1-cos\theta)\}P</script><p>其中记</p><script type="math/tex; mode=display">R=Icos\theta+\begin{bmatrix} 0&-A_z&A_y\\A_z&0&-A_x\\-A_y&A_x&0\end{bmatrix}sin\theta+AA^T(1-cos\theta)</script><p>为罗德里格斯旋转公式，而将其展开写成一个矩阵就可得到旋转矩阵。</p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Lagrange插值法与Newton插值法</title>
    <link href="/2020/05/30/Lagrange%E6%8F%92%E5%80%BC%E6%B3%95%E4%B8%8ENewton%E6%8F%92%E5%80%BC%E6%B3%95/"/>
    <url>/2020/05/30/Lagrange%E6%8F%92%E5%80%BC%E6%B3%95%E4%B8%8ENewton%E6%8F%92%E5%80%BC%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h2 id="Lagrange插值法"><a href="#Lagrange插值法" class="headerlink" title="Lagrange插值法"></a>Lagrange插值法</h2><p>​        考虑有$n$个<strong>不同的点</strong> <script type="math/tex">(x_1,y_1),(x_2,y_2),(x_i,y_i)\dots (x_n,y_n)</script> , 定义函数<script type="math/tex">f_i(x)</script>满足在<script type="math/tex">l_i(x_j)</script>满足克罗内克符号函数 <script type="math/tex">\delta_{ij}</script>，</p><script type="math/tex; mode=display">l_i(x_j)=\delta_{ij}=\begin{cases}1\quad\quad\quad i=j\\0\quad\quad\quad i\not=j\end{cases}</script><p>此时，若另</p><script type="math/tex; mode=display">L(x)=\sum_{i=1}^n y_il_i(x)</script><p>则对于任意$x_i$有</p><script type="math/tex; mode=display">y_i=l_i(x_i)</script><p>即$n$个点必然经过$L(x)$,即为所求。</p><p>​        再考虑$l_i(x)$,其应为一个<strong>$n-1$次多项式</strong>,则可由因式法写出满足要求的函数:</p><script type="math/tex; mode=display">\begin{align}l_i(x)&=\frac{(x-x_1)(x-x_2)(x-x_3)\dots(x-x_{i-1})(x-x_{i+1})\dots(x_i-x_n)}{(x_i-x_1)(x_i-x_2)(x_i-x_3)\dots(x_i-x_{i-1})(x_i-x_{i+1})\dots(x_i-x_n)}\\\\&=\prod_{j\not=i}^{ 1\le j\le n }\frac{x-x_j}{x_i-x_j}\end{align}</script><p>这里的$l_i(x)$称为插值基函数。</p><p>​        以下是代码实现</p><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><span class="hljs-keyword">float</span> x[<span class="hljs-number">7</span>] = &#123;<span class="hljs-number">1.20</span>, <span class="hljs-number">1.24</span>, <span class="hljs-number">1.28</span>, <span class="hljs-number">1.32</span>, <span class="hljs-number">1.36</span>, <span class="hljs-number">1.40</span>&#125;;<span class="hljs-keyword">float</span> y1[<span class="hljs-number">7</span>] = &#123;<span class="hljs-number">1.09545</span>, <span class="hljs-number">1.11355</span>, <span class="hljs-number">1.13137</span>,<span class="hljs-number">1.14891</span>, <span class="hljs-number">1.16619</span>, <span class="hljs-number">1.18322</span>&#125;;<span class="hljs-keyword">float</span> y2[<span class="hljs-number">7</span>] = &#123;<span class="hljs-number">0.07918</span>, <span class="hljs-number">0.09342</span>, <span class="hljs-number">0.10721</span>, <span class="hljs-number">0.12057</span>, <span class="hljs-number">0.13354</span>, <span class="hljs-number">0.14613</span>&#125;;<span class="hljs-keyword">float</span> xi[<span class="hljs-number">6</span>] = &#123;<span class="hljs-number">1.22</span>, <span class="hljs-number">1.26</span>, <span class="hljs-number">1.30</span>, <span class="hljs-number">1.34</span>, <span class="hljs-number">1.38</span>&#125;;<span class="hljs-function"><span class="hljs-keyword">float</span> <span class="hljs-title">Lagrange</span><span class="hljs-params">(<span class="hljs-keyword">float</span> *y,<span class="hljs-keyword">float</span> cx)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> n=<span class="hljs-number">6</span>;    <span class="hljs-keyword">float</span> temp[<span class="hljs-number">10</span>],ans=<span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)    &#123;        temp[i] = y[i];        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;n;j++)        <span class="hljs-keyword">if</span>(j!=i)            temp[i] *= (cx - x[j]) / (x[i] - x[j]);        ans += temp[i];    &#125;    <span class="hljs-keyword">return</span> ans;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>;i++)        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"当x=%.2f,y1=%.5f,y2=%.5f\n"</span>, xi[i], Lagrange(y1,xi[i]),Lagrange(y2,xi[i]));    system(<span class="hljs-string">"pause"</span>);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p>​        我们可以发现假如新加入一个点,就必须得重新计算,这是它的缺点.</p><h2 id="Newton插值法"><a href="#Newton插值法" class="headerlink" title="Newton插值法"></a>Newton插值法</h2><p>​        该方法确定了一组新的基函数,确保能加入新的点能够重用之前的计算结果:</p><script type="math/tex; mode=display">\begin{aligned}        \phi_{1}(x) &=1 \\\phi_{2}(x) &=\left(x-x_{1}\right) \\\phi_{3}(x) &=\left(x-x_{1}\right)\left(x-x_{2}\right) \\\cdots &=\cdots \\\phi_{n+1}(x) &=\prod_{i=1}^{n}\left(x-x_{i}\right)\end{aligned}</script><p>可以看到由于<script type="math/tex">\phi_{n+1}(x)=\phi_{n}(x)(x-x_{n})</script>,因此可以重用之前的结果。</p><p>则最终的多项式为:</p><script type="math/tex; mode=display">N(x)=\sum_{i=1}^{n+1}a_i\phi_i(x)</script><p>现在仅仅需要确定$a_i$的值就可以确定$N(x)$。</p><p>​        我们将每个点依次带入相减可得到一个神奇的规律：</p><script type="math/tex; mode=display">\begin{aligned}a_1&=y_1\\a_2&=\frac{y_2-y_1}{x_2-x_1}\\a_3&=\frac{\frac{y_3-y_2}{x_3-x_2}-\frac{y_2-y_1}{x_2-x_1}}{x_3-x_1}\\\vdots\end{aligned}</script><p>我们把这种叫做<strong>差商</strong>,0阶均差定义为$f[x_i]=f(x_i)$,$n-1$阶差商为：</p><script type="math/tex; mode=display">f[x_1,x_2,x_3\dots x_n]=\frac{f[x_1,x_2,x_3\dots x_{n-1}]-f[x_2,x_3,x_4\dots x_n]}{x_n-x_1}</script><p>下面是差商表,每次迭代也可重用上一步的结果</p><p>所以最终为</p><script type="math/tex; mode=display">\begin{aligned}N(x)=& f\left(x_{1}\right)+\\& f\left[x_{1}, x_{2}\right]\left(x-x_{1}\right)+\\& f\left[x_{1}, x_{2}, x_{3}\right]\left(x-x_{1}\right)\left(x-x_{2}\right)+\\& f\left[x_{1}, \ldots, x_{4}\right]\left(x-x_{1}\right)\left(x-x_{2}\right)\left(x-x_{3}\right)+\\& \ldots\end{aligned}</script><p>以下是代码,可想而知，虽然Newton插值效率提高了，但是也要多出一部分来计算差商</p><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">float</span> x[<span class="hljs-number">7</span>] = &#123;<span class="hljs-number">1.20</span>, <span class="hljs-number">1.24</span>, <span class="hljs-number">1.28</span>, <span class="hljs-number">1.32</span>, <span class="hljs-number">1.36</span>, <span class="hljs-number">1.40</span>&#125;;<span class="hljs-keyword">float</span> y1[<span class="hljs-number">7</span>] = &#123;<span class="hljs-number">1.09545</span>, <span class="hljs-number">1.11355</span>, <span class="hljs-number">1.13137</span>,<span class="hljs-number">1.14891</span>, <span class="hljs-number">1.16619</span>, <span class="hljs-number">1.18322</span>&#125;;<span class="hljs-keyword">float</span> y2[<span class="hljs-number">7</span>] = &#123;<span class="hljs-number">0.07918</span>, <span class="hljs-number">0.09342</span>, <span class="hljs-number">0.10721</span>, <span class="hljs-number">0.12057</span>, <span class="hljs-number">0.13354</span>, <span class="hljs-number">0.14613</span>&#125;;<span class="hljs-keyword">float</span> xi[<span class="hljs-number">6</span>] = &#123;<span class="hljs-number">1.22</span>, <span class="hljs-number">1.26</span>, <span class="hljs-number">1.30</span>, <span class="hljs-number">1.34</span>, <span class="hljs-number">1.38</span>&#125;;<span class="hljs-keyword">float</span> diff[<span class="hljs-number">10</span>][<span class="hljs-number">10</span>];<span class="hljs-comment">//差商值表</span><span class="hljs-keyword">float</span> phi[<span class="hljs-number">10</span>];<span class="hljs-comment">//基函数值</span><span class="hljs-keyword">int</span> n=<span class="hljs-number">6</span>;<span class="hljs-comment">//求差商表，有点像动态规划</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">DifferenceQuotient</span><span class="hljs-params">(<span class="hljs-keyword">float</span> *y)</span></span><span class="hljs-function"></span>&#123;  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n;i++)    diff[i][<span class="hljs-number">0</span>] = y[i];      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; n;i++)  &#123;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span> ; j &lt; i+<span class="hljs-number">1</span>;j++)      diff[i][j] = (diff[i][j - <span class="hljs-number">1</span>] - diff[i<span class="hljs-number">-1</span>][j - <span class="hljs-number">1</span>]) / (x[i] - x[i-j]);  &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">float</span> <span class="hljs-title">Newton</span><span class="hljs-params">(<span class="hljs-keyword">float</span> *y,<span class="hljs-keyword">float</span> cx)</span></span><span class="hljs-function"></span>&#123;  phi[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;  <span class="hljs-keyword">float</span> ans = <span class="hljs-number">0</span>;  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; n;i++) <span class="hljs-comment">//其基函数的值</span>    phi[i] = phi[i<span class="hljs-number">-1</span>]*(cx - x[i<span class="hljs-number">-1</span>]);    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n;i++)    ans += phi[i] * diff[i][i];<span class="hljs-comment">//多项式求和为最终结果</span>    <span class="hljs-keyword">return</span> ans;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;  DifferenceQuotient(y1);  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>;i++)        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"当x=%.2f,y1=%.5f\n"</span>, xi[i], Newton(y1,xi[i]));  <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-built_in">endl</span>;  DifferenceQuotient(y2);  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>;i++)        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"当x=%.2f,y2=%.5f\n"</span>, xi[i],Newton(y2,xi[i]));  system(<span class="hljs-string">"pause"</span>);&#125;</code></pre><p>​        如果要新增节点，可以增量更新差商表</p><h2 id="两者关系"><a href="#两者关系" class="headerlink" title="两者关系"></a>两者关系</h2><p>​        其实我们可以发现两个方法都是通过$n$个点确定了一组$n$个方程的方程组:</p><script type="math/tex; mode=display">\begin{cases}y_1&=a_0+a_1x_1+a_2x_1^2+\dots+a_nx_1^n\\y_2&=a_0+a_1x_2+a_2x_2^2+\dots+a_nx_2^n\\\vdots\\y_n&=a_0+a_1x_n+a_2x_n^2+\dots+a_nx_n^n\\\end{cases}</script><p>矩阵形式为$Y=XA$</p><script type="math/tex; mode=display">\begin{bmatrix} y_1\\y_2\\ \vdots \\y_n\end{bmatrix}=\begin{bmatrix} 1&x_1&x_1^2&\dots&x_1^n\\1&x_2&x_2^2&\dots&x_2^n\\ \vdots&\vdots&\vdots&\dots&\vdots\\1&x_n&x_n^2&\dots&x_n^n\end{bmatrix}\begin{bmatrix} a_0\\a_1\\ \vdots \\a_n\end{bmatrix}</script><p>系数矩阵$X$为范德蒙行列式,则$|X|\not =0$,因此可以得出其解$A$唯一,故最终确定的多项式唯一,即两者等效.Largrane法较为简单，而Newton法在需要新增节点时可以保持很好的效率。</p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>打家劫舍</title>
    <link href="/2020/05/29/%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D/"/>
    <url>/2020/05/29/%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D/</url>
    
    <content type="html"><![CDATA[<h2 id="LeetCode-198-打家劫舍"><a href="#LeetCode-198-打家劫舍" class="headerlink" title="LeetCode 198 打家劫舍"></a>LeetCode 198 <a href="https://leetcode-cn.com/problems/house-robber/" target="_blank" rel="noopener">打家劫舍</a></h2><p>​        你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。</p><p>给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。</p><pre><code class="hljs plain">输入: [2,7,9,3,1]输出: 12解释: 偷窃 1 号房屋 (金额 &#x3D; 2), 偷窃 3 号房屋 (金额 &#x3D; 9)，接着偷窃 5 号房屋 (金额 &#x3D; 1)。     偷窃到的最高金额 &#x3D; 2 + 9 + 1 &#x3D; 12 。</code></pre><p>​        动态规划，自然而然想到每个房子有两种状态偷与不偷：偷的话只能是最走到<strong>前前一个房子是偷盗的金额总和</strong>加上当前房子金额，不偷的话就是等于走到<strong>前一个房子时偷到的金额总和</strong>，定义$dp[i]$为$nums[0…i]$的能偷到的最高金额，则转移方程为</p><script type="math/tex; mode=display">dp[i]=\begin{cases}          max(dp[i-1],dp[i-2]+nums[i])      \quad\quad\quad\quad\quad &i\in[ 2,j]\\        nums[0]   &i=0\\        max(nums[0],nums[1])  &i=1\end{cases}</script><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">rob</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;        <span class="hljs-keyword">if</span>(nums.<span class="hljs-built_in">size</span>()==<span class="hljs-number">0</span>)<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        <span class="hljs-keyword">if</span>(nums.<span class="hljs-built_in">size</span>()==<span class="hljs-number">1</span>)<span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>];<span class="hljs-comment">//边界情况</span>        <span class="hljs-keyword">int</span> dp[<span class="hljs-number">1000</span>]=&#123;<span class="hljs-number">0</span>&#125;;        dp[<span class="hljs-number">0</span>]=nums[<span class="hljs-number">0</span>];        dp[<span class="hljs-number">1</span>]=<span class="hljs-built_in">max</span>(nums[<span class="hljs-number">0</span>],nums[<span class="hljs-number">1</span>]);        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">2</span>;i&lt;nums.<span class="hljs-built_in">size</span>();i++)        &#123;            dp[i]=<span class="hljs-built_in">max</span>(dp[i<span class="hljs-number">-2</span>]+nums[i],dp[i<span class="hljs-number">-1</span>]);        &#125;        <span class="hljs-keyword">return</span> dp[nums.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>];    &#125;&#125;;</code></pre>]]></content>
    
    
    <categories>
      
      <category>习题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>习题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCodeのTree</title>
    <link href="/2020/05/26/Tree/"/>
    <url>/2020/05/26/Tree/</url>
    
    <content type="html"><![CDATA[<h1 id="关于树"><a href="#关于树" class="headerlink" title="关于树"></a>关于树</h1><h2 id="简单"><a href="#简单" class="headerlink" title="简单"></a>简单</h2><h3 id="100-相同的树"><a href="#100-相同的树" class="headerlink" title="100 相同的树"></a>100 <a href="https://leetcode-cn.com/problems/same-tree/" target="_blank" rel="noopener">相同的树</a></h3><p>给定两个二叉树，编写一个函数来检验它们是否相同。</p><p>如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。</p><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isSameTree</span><span class="hljs-params">(TreeNode* p, TreeNode* q)</span> </span>&#123;        <span class="hljs-keyword">if</span>(!p&amp;&amp;!q)<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; <span class="hljs-comment">//都为空返回true</span>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(p&amp;&amp;q&amp;&amp;p-&gt;val==q-&gt;val)<span class="hljs-comment">//相等往下做判断</span>        <span class="hljs-keyword">return</span> isSameTree(p-&gt;left,q-&gt;left)&amp;&amp;isSameTree(p-&gt;right,q-&gt;right);        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;    &#125;&#125;;</code></pre><h3 id="101-对称二叉树"><a href="#101-对称二叉树" class="headerlink" title="101 对称二叉树"></a>101 <a href="https://leetcode-cn.com/problems/symmetric-tree/" target="_blank" rel="noopener">对称二叉树</a></h3><p>给定一个二叉树，检查它是否是镜像对称的。</p><p>上题的引申</p><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isSymmetric</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;        <span class="hljs-keyword">return</span> judge(root,root);    &#125;    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">judge</span><span class="hljs-params">(TreeNode* p,TreeNode* q)</span></span><span class="hljs-function">    </span>&#123;            <span class="hljs-keyword">if</span>(!p&amp;&amp;!q)<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(p&amp;&amp;q&amp;&amp;p-&gt;val==q-&gt;val)            <span class="hljs-keyword">return</span> judge(p-&gt;left,q-&gt;right)&amp;&amp;judge(p-&gt;right,q-&gt;left);            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;    &#125;&#125;;</code></pre><h3 id="104-二叉树的最大深度"><a href="#104-二叉树的最大深度" class="headerlink" title="104 二叉树的最大深度"></a>104 <a href="https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/" target="_blank" rel="noopener">二叉树的最大深度</a></h3><p>给定一个二叉树，找出其最大深度。</p><p>二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。</p><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxDepth</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;        <span class="hljs-keyword">if</span>(!root)<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(maxDepth(root-&gt;left),maxDepth(root-&gt;right))+<span class="hljs-number">1</span>;<span class="hljs-comment">//返回左右最大值    </span>    &#125;&#125;;</code></pre><h2 id="中等"><a href="#中等" class="headerlink" title="中等"></a>中等</h2><h3 id="94-二叉树的中序遍历"><a href="#94-二叉树的中序遍历" class="headerlink" title="94 二叉树的中序遍历"></a>94 <a href="https://leetcode-cn.com/problems/binary-tree-inorder-traversal/" target="_blank" rel="noopener">二叉树的中序遍历</a></h3><p>非递归方法</p><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">inorderTraversal</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;        <span class="hljs-built_in">stack</span>&lt;TreeNode*&gt;s;        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; ans;        <span class="hljs-keyword">while</span>(!s.empty()||root)        &#123;            <span class="hljs-keyword">if</span>(root)            &#123;                s.push(root);                root=root-&gt;left;            &#125;            <span class="hljs-keyword">else</span>            &#123;                TreeNode* temp=s.top();                s.pop();                ans.push_back(temp-&gt;val);                root=temp-&gt;right;            &#125;        &#125;        <span class="hljs-keyword">return</span> ans;    &#125;&#125;;</code></pre><h3 id="105-从前序与中序遍历序列构造二叉树"><a href="#105-从前序与中序遍历序列构造二叉树" class="headerlink" title="105 从前序与中序遍历序列构造二叉树"></a>105 <a href="https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/" target="_blank" rel="noopener">从前序与中序遍历序列构造二叉树</a></h3><p>递归构造，常规。</p><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function">TreeNode* <span class="hljs-title">build</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; pre,<span class="hljs-keyword">int</span> ps,<span class="hljs-keyword">int</span> pe, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; inorder,<span class="hljs-keyword">int</span> is,<span class="hljs-keyword">int</span> ie)</span></span><span class="hljs-function">    </span>&#123;        <span class="hljs-keyword">if</span>(ps&gt;pe||is&gt;ie)<span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;        TreeNode* t=<span class="hljs-keyword">new</span> TreeNode();        t-&gt;val=pre[ps];        <span class="hljs-keyword">int</span> k=is;        <span class="hljs-keyword">while</span>(is&lt;ie&amp;&amp;inorder[k]!=t-&gt;val)k++;<span class="hljs-comment">//寻找中序中的头节点</span>        t-&gt;left=build(pre,ps+<span class="hljs-number">1</span>,ps+k-is,inorder,is,k<span class="hljs-number">-1</span>);<span class="hljs-comment">//构造左子树</span>        t-&gt;right=build(pre,ps+k-is+<span class="hljs-number">1</span>,pe,inorder,k+<span class="hljs-number">1</span>,ie);<span class="hljs-comment">//构造右子树</span>        <span class="hljs-keyword">return</span> t;    &#125;    <span class="hljs-function">TreeNode* <span class="hljs-title">buildTree</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; preorder, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; inorder)</span> </span>&#123;        <span class="hljs-keyword">return</span> build(preorder,<span class="hljs-number">0</span>,preorder.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>,inorder,<span class="hljs-number">0</span>,inorder.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>);    &#125;&#125;;</code></pre><h2 id="困难"><a href="#困难" class="headerlink" title="困难"></a>困难</h2>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>习题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>通过可逆运算交换变量的值</title>
    <link href="/2020/05/23/%E9%80%9A%E8%BF%87%E5%8F%AF%E9%80%86%E8%BF%90%E7%AE%97%E4%BA%A4%E6%8D%A2%E5%8F%98%E9%87%8F%E7%9A%84%E5%80%BC/"/>
    <url>/2020/05/23/%E9%80%9A%E8%BF%87%E5%8F%AF%E9%80%86%E8%BF%90%E7%AE%97%E4%BA%A4%E6%8D%A2%E5%8F%98%E9%87%8F%E7%9A%84%E5%80%BC/</url>
    
    <content type="html"><![CDATA[<h1 id="通过可逆运算交换变量的值"><a href="#通过可逆运算交换变量的值" class="headerlink" title="通过可逆运算交换变量的值"></a>通过可逆运算交换变量的值</h1><h3 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1 介绍"></a>1 介绍</h3><p>​        交换两个变量的值除了引入临时变量，还有通过加减或异或等奇淫技巧来完成，现在来介绍其原理并且推广它们。</p><h2 id="2-交换的原理"><a href="#2-交换的原理" class="headerlink" title="2 交换的原理"></a>2 交换的原理</h2><p>​        加减、异或都是可逆运算，现在定义一种可逆运算规则$f$,它的逆运算是$f^{-1}$，不妨设$f(a,b)=c$,则有$f^{-1}(c,a)=b$，则有如下推导,注意我用<code>:=</code>来表示赋值：</p><script type="math/tex; mode=display">\begin{align}a& :=f(a,b)  \tag{1}\label{1}\\b& :=f^{-1}(a,b)=f^{-1}(f(a,b),b)=a \tag{2}\label{2}\\a& :=f^{-1}(a,b)=f^{-1}(f(a,b),a)=b \tag{3}\label{3}\end{align}</script><p>可以看到，最终$a,b$交换了两者的值，因此可见只要是逆运算就可以满足要求，比如使用乘除：</p><pre><code class="hljs c++">a=a*b;b=a/b;a=a/b;</code></pre><p>我们可以代入数字验证一下，可以发现它也是正确的。</p><h2 id="3-交换律的影响"><a href="#3-交换律的影响" class="headerlink" title="3 交换律的影响"></a>3 交换律的影响</h2><p>​        但是，如果你细心点，你会发现既然乘除可以，那为什么要先乘后除，或者干脆使用乘方与开方，因为它们也是一组逆运算，可是当我们这样操作会发现答案是与预期不符的。因为问题出在交换律上。</p><h3 id="3-1-f-与-f-1-只有一者满足交换律"><a href="#3-1-f-与-f-1-只有一者满足交换律" class="headerlink" title="3.1 $f$与$f^{-1}$只有一者满足交换律"></a>3.1 $f$与$f^{-1}$只有一者满足交换律</h3><p>​        如果$f(a,b)\not= f(b,a)$,我们也就能得出$f^{-1}(c,a)\not=f^{-1}(c,b)$,而公式$\eqref{2}\eqref{3}$正是依赖于此的。也可这样想，不妨设$f(a,b)=c_1,f(b,a)=c_2$，则正确的应该是$f^{-1}(c_1,a)=b,f^{-1}(c_2,b)=a$。所以运算规则$f$应满足交换律，其逆运算则无要求。</p><p>​        那么，如果$f$不满足交换律，可以实现交换变量而不引入临时变量吗？答案当然是可以的，不过这就对不同的$f$就有不同的方法了，因为我们要知道$c_1$与$c_2$的关系，如果$f$是减法，则$c_1=-c_2$;如果是除法，则$c_1=c_2^{-1}$。</p><h3 id="3-2-f-与-f-1-都不满足交换律"><a href="#3-2-f-与-f-1-都不满足交换律" class="headerlink" title="3.2 $f$与$f^{-1}$都不满足交换律"></a>3.2 $f$与$f^{-1}$都不满足交换律</h3><p>​        这个条件下很好的例子就是矩阵和幂两种。矩阵涉及左乘、右乘、逆；幂涉及乘方、开方、对数。它们的运算时涉及到三种运算规则的。</p><p>​        以矩阵为例：</p><script type="math/tex; mode=display">\begin{align}A&:=AB\\B&:=AB^{-1}=ABB^{-1}=A\\A&:=B^{-1}A=A^{-1}AB=B\\\end{align}</script><p>​        幂运算：</p><p>​        </p><script type="math/tex; mode=display">\begin{align}a&:=a^b\\b&:=\sqrt[b]{a}=\sqrt[b]{a^b}=a\\a&:=\log_{a}{a}=\log_{a}{a^b}=b\end{align}</script><p>这种情况下是每种运算规则都是需要用到才能完成交换的。</p><h3 id="3-3-f-与-f-1-都满足交换律"><a href="#3-3-f-与-f-1-都满足交换律" class="headerlink" title="3.3  $f$与$f^{-1}$都满足交换律"></a>3.3  $f$与$f^{-1}$都满足交换律</h3><p>​        这个的最好的例子就是异或运算$\oplus $,因为它除了自身就满足交换，同时它的逆运算就是自身$f=f^{-1}$,</p><script type="math/tex; mode=display">\begin{align}a&:=a\oplus b\\b&:=a\oplus b=a\oplus b\oplus b =a\\a&:=a\oplus b=a\oplus b\oplus a =b\end{align}</script><h3 id="4-总结"><a href="#4-总结" class="headerlink" title="4 总结"></a>4 总结</h3><p>​        主要讲了讲这种变量交换操作的背后原理即推广，但是需要提醒的是在实际应用中，我还是建议通过临时变量来进行交换，上面的操作虽然给人眼前一亮，同时也有理论支持，可应用在实际中还是可能会出现错误，比如溢出，甚至交换变量类型根本就不是数字。我的建议是虽然这很有趣但请不要用。</p><p>​        </p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2020/05/23/hello-world/"/>
    <url>/2020/05/23/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre><code class="hljs bash">$ hexo new <span class="hljs-string">"My New Post"</span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre><code class="hljs bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre><code class="hljs bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre><code class="hljs bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Template类模板</title>
    <link href="/2020/05/21/Template%E7%B1%BB%E6%A8%A1%E6%9D%BF/"/>
    <url>/2020/05/21/Template%E7%B1%BB%E6%A8%A1%E6%9D%BF/</url>
    
    <content type="html"><![CDATA[<h1 id="Template"><a href="#Template" class="headerlink" title="Template"></a>Template</h1><h2 id="1-函数模板"><a href="#1-函数模板" class="headerlink" title="1.函数模板"></a>1.函数模板</h2><p>编译期间编译器自动分析参数类型，<code>template</code>函数模板是支持默认参数的，<code>T1 、T2</code> 顺序在默认情况下是可以任意的，不用严格按照从右到左的顺序，例如：<code>template &lt;typename T1 ,typename T2 = int&gt;</code></p><pre><code class="hljs cpp"><span class="hljs-comment">//函数模板化    </span><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<span class="hljs-function">T <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">const</span> T lval,<span class="hljs-keyword">const</span> T rval)</span></span><span class="hljs-function"></span>&#123;    T ans = lval + rval;    <span class="hljs-keyword">return</span> ans; &#125;</code></pre><pre><code class="hljs cpp"><span class="hljs-built_in">cout</span> &lt;&lt; add(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>) &lt;&lt; <span class="hljs-built_in">endl</span>;<span class="hljs-built_in">cout</span> &lt;&lt; add(<span class="hljs-number">2.1</span>, <span class="hljs-number">1.2</span>) &lt;&lt; <span class="hljs-built_in">endl</span>;<span class="hljs-comment">//add(2, 1.2)会报错,因为变成了add(int,double)</span>输出：    <span class="hljs-number">3</span>    <span class="hljs-number">3.3</span></code></pre><h2 id="2-类模板"><a href="#2-类模板" class="headerlink" title="2.类模板"></a>2.类模板</h2><p>将模板思想应用于类,类模板也支持默认参数，但是类模板必须严格从右往左默认化。</p><pre><code class="hljs cpp"><span class="hljs-comment">//类模板</span><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T</span>&gt;</span><span class="hljs-class"><span class="hljs-title">class</span> <span class="hljs-title">Myclass</span></span><span class="hljs-class">&#123;</span>    T a;    <span class="hljs-keyword">public</span>:        <span class="hljs-function">T <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">const</span> T lval, <span class="hljs-keyword">const</span> T rval)</span></span>;&#125;;<span class="hljs-keyword">template</span> &lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T</span>&gt;</span><span class="hljs-class"><span class="hljs-title">T</span> <span class="hljs-title">Myclass</span> &lt;T&gt;:</span>:add(<span class="hljs-keyword">const</span> T lval, <span class="hljs-keyword">const</span> T rval)&#123;    a = lval + rval;    <span class="hljs-keyword">return</span> a;&#125;</code></pre><pre><code class="hljs cpp">Myclass&lt;<span class="hljs-keyword">double</span>&gt; myclass;<span class="hljs-built_in">cout</span> &lt;&lt; myclass.add(<span class="hljs-number">1.2</span>, <span class="hljs-number">3.3</span>) &lt;&lt; <span class="hljs-built_in">endl</span>;输出：    <span class="hljs-number">4.5</span></code></pre><h2 id="3-成员模板"><a href="#3-成员模板" class="headerlink" title="3.成员模板"></a>3.成员模板</h2><p>在模板类内使用模板函数。</p><pre><code class="hljs cpp"><span class="hljs-comment">//成员模板</span><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T</span>&gt;</span><span class="hljs-class"><span class="hljs-title">class</span> <span class="hljs-title">Mylove</span></span><span class="hljs-class">&#123;</span>    <span class="hljs-keyword">public</span>:        T a;        <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> type_1, <span class="hljs-keyword">typename</span> type_2&gt;        <span class="hljs-function">type_1 <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">const</span> type_1 lval, <span class="hljs-keyword">const</span> type_2 rval)</span></span>;&#125;;<span class="hljs-keyword">template</span> &lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T</span>&gt;</span><span class="hljs-class"><span class="hljs-title">template</span> &lt;typename type_1, typename type_2&gt;</span><span class="hljs-class"><span class="hljs-title">type_1</span> <span class="hljs-title">Mylove</span>&lt;T&gt;:</span>:add(<span class="hljs-keyword">const</span> type_1 lval, <span class="hljs-keyword">const</span> type_2 rval)&#123;    a = lval + rval;    <span class="hljs-keyword">return</span> a;&#125;</code></pre><pre><code class="hljs cpp">Mylove&lt;<span class="hljs-keyword">double</span>&gt; mylove;<span class="hljs-built_in">cout</span> &lt;&lt; mylove.add(<span class="hljs-number">0</span>, <span class="hljs-number">20.2</span>) &lt;&lt; <span class="hljs-built_in">endl</span>; <span class="hljs-comment">//答案为20，因为该函数返回为第一个参数相同,该过程为int+double=double,但最终返回int</span>输出:<span class="hljs-number">20</span></code></pre><h2 id="4-嵌套类模板"><a href="#4-嵌套类模板" class="headerlink" title="4.嵌套类模板"></a>4.嵌套类模板</h2><p>模板类内嵌套模板类。</p><pre><code class="hljs cpp"><span class="hljs-comment">//嵌套类模板</span><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T</span>&gt;</span><span class="hljs-class"><span class="hljs-title">class</span> <span class="hljs-title">Mylife</span></span><span class="hljs-class">&#123;</span>    <span class="hljs-keyword">public</span>:        T a;        <span class="hljs-keyword">template</span> &lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">type_3</span>&gt;</span><span class="hljs-class">        <span class="hljs-title">class</span> <span class="hljs-title">Mystory</span>;</span><span class="hljs-comment">//先声明，在外部定义</span>        Mystory&lt;T&gt; mystory;<span class="hljs-comment">//用T实例化</span>&#125;;<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T</span>&gt;</span><span class="hljs-class">    <span class="hljs-title">template</span>&lt;class type_3&gt;</span><span class="hljs-class">        <span class="hljs-title">class</span> <span class="hljs-title">Mylife</span>&lt;T&gt;:</span>:Mystory        &#123;            <span class="hljs-keyword">public</span>:                type_3 c;                <span class="hljs-function">type_3 <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">const</span> type_3 lval, <span class="hljs-keyword">const</span> type_3 rval)</span> </span><span class="hljs-function">                </span>&#123;                    c = lval + rval;                    <span class="hljs-keyword">return</span> c;                &#125;;        &#125;;</code></pre><pre><code class="hljs cpp">Mylife&lt;<span class="hljs-keyword">double</span>&gt; mylife;<span class="hljs-built_in">cout</span> &lt;&lt; mylife.mystory.add(<span class="hljs-number">1</span>, <span class="hljs-number">1.1</span>) &lt;&lt; <span class="hljs-built_in">endl</span>;输出：    <span class="hljs-number">2.1</span></code></pre><h2 id="5-总结"><a href="#5-总结" class="headerlink" title="5.总结"></a>5.总结</h2><p>使用<code>template</code>,以不变应万变，平常使用的STL正是基于此。</p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Unity下计步器Pedometer算法的实现</title>
    <link href="/2020/05/15/Unity%E4%B8%8B%E8%AE%A1%E6%AD%A5%E5%99%A8Pedometer%E7%AE%97%E6%B3%95%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
    <url>/2020/05/15/Unity%E4%B8%8B%E8%AE%A1%E6%AD%A5%E5%99%A8Pedometer%E7%AE%97%E6%B3%95%E7%9A%84%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="Unity下计步器Pedometer的实现"><a href="#Unity下计步器Pedometer的实现" class="headerlink" title="Unity下计步器Pedometer的实现"></a>Unity下计步器Pedometer的实现</h2><p><strong>1.环境</strong><br>unity2018,Android(小米5)<br><strong>2.原理</strong><br><a href="https://blog.csdn.net/qq_36490364/article/details/104522980" target="_blank" rel="noopener">加速度传感器的计步算法Pedometer</a><br><strong>3.实现</strong><br>注释写的很清楚了应该<br><pre><code class="hljs c#">using UnityEngine;using UnityEngine.Networking;using UnityEngine.UI;#pragma warning disable CS0618public class pedometer : MonoBehaviour&#123;    public Text statusText,stepsText;    public float lowLimit &#x3D; 0.005f; &#x2F;&#x2F;平缓    public float highLimit &#x3D; 0.1f; &#x2F;&#x2F; 走路时的波峰波谷    public float vertHighLimit &#x3D; 0.25f;&#x2F;&#x2F;跳跃时的波峰波谷    private bool isHigh &#x3D; false; &#x2F;&#x2F; 状态    private float filterCurrent &#x3D; 10.0f; &#x2F;&#x2F; 滤波参数 得到拟合值    private float filterAverage &#x3D; 0.1f; &#x2F;&#x2F;   滤波参数  得到均值    private float accelerationCurrent &#x3D; 0f; &#x2F;&#x2F;拟合值    private float accelerationAverage &#x3D; 0f;&#x2F;&#x2F;均值    private int steps &#x3D; 0; &#x2F;&#x2F; 步数    private int oldSteps;    private float deltaTime &#x3D; 0f;&#x2F;&#x2F;计时器    private int jumpCount &#x3D; 0;&#x2F;&#x2F;跳跃数    private int oldjumpCount &#x3D; 0;        private bool startTimer &#x3D; false;&#x2F;&#x2F;开始计时    private bool isWalking &#x3D; false;    private bool isJumping &#x3D; false;    void Awake()    &#123;        accelerationAverage &#x3D; Input.acceleration.magnitude;         oldSteps &#x3D; steps;        oldjumpCount &#x3D;jumpCount ;    &#125;    void Update()    &#123;        checkWalkingAndJumping(); &#x2F;&#x2F; 检测是否行走        if (isWalking)        &#123;            statusText.text &#x3D; (&quot;状态:行走&quot;);                    &#125;        else if (!isWalking)        &#123;            statusText.text &#x3D; (&quot;状态:不动&quot;);        &#125;        if (isJumping)        &#123;            statusText.text &#x3D; (&quot;状态:跳跃&quot;);        &#125;    &#125;    void FixedUpdate()    &#123;        &#x2F;&#x2F;通过Lerp对Input.acceleration.magnitude(加速度标量和)滤波        &#x2F;&#x2F;这里使用线性插值的公式正好为EMA一次指数滤波 y[i]&#x3D;y[i-1]+(x[i]-y[i])*k&#x3D;(1-k)*y[i]+kx[i]        accelerationCurrent &#x3D; Mathf.Lerp(accelerationCurrent, Input.acceleration.magnitude, Time.deltaTime * filterCurrent);        accelerationAverage &#x3D; Mathf.Lerp(accelerationAverage, Input.acceleration.magnitude, Time.deltaTime * filterAverage);        float delta &#x3D; accelerationCurrent - accelerationAverage; &#x2F;&#x2F; 获取差值，即坡度        if (!isHigh)        &#123;               if (delta &gt; highLimit)&#x2F;&#x2F;往高            &#123;                isHigh &#x3D; true;                steps++;                stepsText.text &#x3D; &quot;步数: &quot; + steps+&quot;\n跳跃数：&quot;+jumpCount;            &#125;            if(delta&gt;vertHighLimit)            &#123;                isHigh &#x3D; true;                jumpCount++;                stepsText.text &#x3D; &quot;步数: &quot; + steps + &quot;\n跳跃数：&quot; + jumpCount;            &#125;        &#125;        else        &#123;            if (delta &lt; lowLimit)&#x2F;&#x2F;往低            &#123;                                isHigh &#x3D; false;            &#125;        &#125;    &#125;       private void checkWalkingAndJumping()    &#123;        if ((steps !&#x3D; oldSteps)||(oldjumpCount !&#x3D; jumpCount))        &#123;            startTimer &#x3D; true;            deltaTime &#x3D; 0f;        &#125;        if (startTimer)&#x2F;&#x2F;计时器，让更新UI的慢一点，因为你不可能走路只用一帧的时间QAQ        &#123;            deltaTime +&#x3D; Time.deltaTime;            if (deltaTime !&#x3D; 0)           &#123;                if (oldjumpCount !&#x3D; jumpCount)&#x2F;&#x2F;检测是否是跳跃                    isJumping &#x3D; true;                else                    isWalking &#x3D; true;                      &#125;            if (deltaTime &gt; 2)           &#123;                deltaTime &#x3D; 0F;                startTimer &#x3D; false;           &#125;        &#125;        else if (!startTimer)        &#123;            isWalking &#x3D; false;            isJumping &#x3D; false;        &#125;        oldSteps &#x3D; steps;        oldjumpCount &#x3D; jumpCount;    &#125;&#125;</code></pre></p>]]></content>
    
    
    <categories>
      
      <category>Unity</category>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>Unity</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>加速度传感器的计步算法Pedometer</title>
    <link href="/2020/05/15/%E5%8A%A0%E9%80%9F%E5%BA%A6%E4%BC%A0%E6%84%9F%E5%99%A8%E7%9A%84%E8%AE%A1%E6%AD%A5%E7%AE%97%E6%B3%95Pedometer/"/>
    <url>/2020/05/15/%E5%8A%A0%E9%80%9F%E5%BA%A6%E4%BC%A0%E6%84%9F%E5%99%A8%E7%9A%84%E8%AE%A1%E6%AD%A5%E7%AE%97%E6%B3%95Pedometer/</url>
    
    <content type="html"><![CDATA[<h2 id="加速度传感器的计步算法Pedometer"><a href="#加速度传感器的计步算法Pedometer" class="headerlink" title="加速度传感器的计步算法Pedometer"></a>加速度传感器的计步算法Pedometer</h2><p><strong>1.前言</strong><br>&emsp;&emsp;最近要使用到计步，查了很多资料，以下是一个简易的计步算法，也能检测跳跃</p><p><strong>2.工具</strong><br>&emsp;&emsp;<a href="https://download.csdn.net/download/qq_36490364/12193880" target="_blank" rel="noopener">一个实时绘制Android加速度的APP</a></p><p><strong>3.内容</strong></p><ol><li><p>Android的加速传感器的介绍</p><p>&emsp;&emsp;Android上的加速度传感器的方向如下所示（当你面朝手机屏幕观察），这是一个右手坐标系。因此加速度是由三个正交的向量组成的，例如当你平放手机在桌子上屏幕朝上，此时应为（0，0，9.6左右）<img src="/2020/05/15/%E5%8A%A0%E9%80%9F%E5%BA%A6%E4%BC%A0%E6%84%9F%E5%99%A8%E7%9A%84%E8%AE%A1%E6%AD%A5%E7%AE%97%E6%B3%95Pedometer/image-20200524015251937.png" srcset="/img/loading.gif" class="" title="image-20200524015251937"></p></li></ol><ol><li>使用g-sensor对数据进行分析<br> &emsp;&emsp;打开这个工具后进行走路和跳跃，然后导出数据，以时间为横轴画出折线图<img src="/2020/05/15/%E5%8A%A0%E9%80%9F%E5%BA%A6%E4%BC%A0%E6%84%9F%E5%99%A8%E7%9A%84%E8%AE%A1%E6%AD%A5%E7%AE%97%E6%B3%95Pedometer/20200226221501436-1590254598388.png" srcset="/img/loading.gif" class="" title="在这里插入图片描述"><br> 我们多实验几组实验后会发现，当手机以不同的姿态放入口袋然后进行运动时，xyz三轴的数据是不确定的，但是三者矢量和的模却是有规律的（其实真正的加速度被正交分解了），因此我们接下来应该分析的是它们的模|V|<br> <img src="/2020/05/15/%E5%8A%A0%E9%80%9F%E5%BA%A6%E4%BC%A0%E6%84%9F%E5%99%A8%E7%9A%84%E8%AE%A1%E6%AD%A5%E7%AE%97%E6%B3%95Pedometer/202002262042493.png" srcset="/img/loading.gif" class="" title="在这里插入图片描述">&emsp;&emsp;上图中可以知道，每次走路都会产生一个波峰和波谷，而跳跃的振幅相对大一些。因此判断行走只需判断波峰波谷就行</li></ol><ol><li>数据处理<br>&emsp;&emsp;不妨记第$i$个时间单位获取到的加速度的三个矢量和的模大小为$x_i$，为了使数据更加平滑，分别使用两次的指数滤波(EMA)<script type="math/tex; mode=display">\left\{\begin{aligned}a_{i}&=（1-p_1）a_{i-1}+p_{1}x_{i}\\b_{i}&=（1-p_2）b_{i-1}+p_{2}x_{i}\\a_{0}&=b_{0}=x_{0}\\p_{1}&>p_{2}\\\end{aligned}\right.</script></li></ol><p>&emsp;&emsp;其中$a_i$是拟合曲线，$b_i$均值，因此${\Delta{h}=a_i-b_i}$即波峰波谷的高度差,得到${\Delta{h}}$后再跟设置好的${k_1,k_2,k_3}$比较（其中${k_1&gt;k_2&gt;k_3}$)。判别结果如下,</p><script type="math/tex; mode=display">\left\{\begin{aligned}&jump,\Delta{h}>k_1\\&walking,\Delta{h}>k_2\\&standing,\Delta{h}<k_3\\\end{aligned}\right.</script><p>&emsp;&emsp;需要注意的是.一旦检测到跳跃或者行走,就得有计时器计时,当经过$\Delta t$后再进行判别,因为人走路和跳跃是需要时间的!!!</p><p>​        其中$p_1$,$p_2$,$k_1$,$k_2$,$k_3$,$\Delta t$ 都是需要我们设置的参数，下面分享一组<strong>手调</strong>测出来的参数QAQ，不一定最优但能行。。。</p><script type="math/tex; mode=display">\left\{\begin{aligned}p_1&=0.2\\p_2&=0.002\\k_1&=0.25\\k_2&=0.13\\k_3&=0.008\\\Delta t&=2s\end{aligned}\right.</script><img src="/2020/05/15/%E5%8A%A0%E9%80%9F%E5%BA%A6%E4%BC%A0%E6%84%9F%E5%99%A8%E7%9A%84%E8%AE%A1%E6%AD%A5%E7%AE%97%E6%B3%95Pedometer/20200227144604718.png" srcset="/img/loading.gif" class="" title="在这里插入图片描述"><p>&emsp;&emsp;上图是带入这些参数得到的曲线，我们可以看到经过$p_1$参数的滤波得到的曲线(红色)，已经大致拟合原数据(蓝色)，而经过$p_2$参数得到的曲线(绿色)大致为均值,要说一下的是其实绿线的值大致在9.8附近,就是重力加速度,为什么不直接采用9.8的原因是实际会有误差。</p><p>​        至于为什么会选EMA，简单有效！我们其实可以发现其公式可以用线性插值函数快速实现,虽然没人说，但我觉得在很多时候我们平滑移动物体和相机用到这个插值基于的原理就是这个，在每帧不断迭代才产生了平滑。</p><script type="math/tex; mode=display">a_i=Mathf.Lerp(a_{i-1 },x_i,p_1)=a_{i-1}+(1-p_1)x_i=(1-p_1)a_{i-1}+p_1x_i</script><p><strong>3.实现</strong><br><a href="https://blog.csdn.net/qq_36490364/article/details/104515912" target="_blank" rel="noopener">Unity下的实现</a></p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>求解最长回文子串</title>
    <link href="/2020/03/11/%E6%B1%82%E8%A7%A3%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/"/>
    <url>/2020/03/11/%E6%B1%82%E8%A7%A3%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/</url>
    
    <content type="html"><![CDATA[<p><strong>描述</strong><br>&emsp;&emsp;给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。</p><pre><code class="hljs c++">输入: <span class="hljs-string">"babad"</span>输出: <span class="hljs-string">"bab"</span>(注意: <span class="hljs-string">"aba"</span> 也是一个有效答案。)输入: <span class="hljs-string">"cbbd"</span>输出: <span class="hljs-string">"bb"</span></code></pre><p>&emsp;&emsp;dp,除此之外还有一些很炫的解法，这里只讲dp这是一道很好的入门题。<br>&emsp;&emsp;我一向认为dp第一步不是写状态转移方程，而是把状态设对。涉及到字符串的子串起码应该想到二维数组$dp<em>{ij}$,至于这个代表什么，就是手感了，设的好方程<del>推</del> （猜）的轻松，否则基本gg；<br>&emsp;&emsp;这里直接给答案，$dp</em>{ij}$表示以$s<em>i开头至以s_j$结尾的串.如果$s_i…s_j$为回文串，那么$s</em>{i-1}…s<em>{j+1}$为回文串的条件就是$s</em>{i-1}==s_{j+1}$。</p><pre><code class="hljs c++">初始状态：dp[i][i]==<span class="hljs-literal">true</span>;           i∈<span class="hljs-number">1.</span>..ndp[i][j]=dp[i+<span class="hljs-number">1</span>]d[j<span class="hljs-number">-1</span>]&amp;&amp;(s[i]==s[j])</code></pre><p>画表理解一下，以babad为例，填的顺序是斜着填的</p><div class="table-container"><table><thead><tr><th>1</th><th>0</th><th>1</th><th>0</th><th>0</th></tr></thead><tbody><tr><td></td><td>1</td><td>0</td><td>1</td><td>0</td></tr><tr><td></td><td></td><td>1</td><td>0</td><td>0</td></tr><tr><td></td><td></td><td></td><td>1</td><td>0</td></tr><tr><td></td><td></td><td></td><td></td><td>1</td></tr></tbody></table></div><img src="/2020/03/11/%E6%B1%82%E8%A7%A3%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/20200311204401984.png" srcset="/img/loading.gif" class="" title="在这里插入图片描述">上代码<pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-built_in">string</span> <span class="hljs-title">longestPalindrome</span><span class="hljs-params">(<span class="hljs-built_in">string</span> s)</span> </span>&#123;        <span class="hljs-keyword">int</span> len=s.length();        <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">bool</span>&gt;&gt; <span class="hljs-title">d</span><span class="hljs-params">(len, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">bool</span>&gt;(len))</span></span>;        <span class="hljs-keyword">int</span> <span class="hljs-built_in">max</span>=<span class="hljs-number">1</span>,p=<span class="hljs-number">0</span>,flag=<span class="hljs-number">1</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;len;i++)<span class="hljs-comment">//初始化</span>            d[i][i]=<span class="hljs-literal">true</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j&lt;len;j++)        &#123;            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;len-j;i++)            &#123;                <span class="hljs-keyword">if</span>(j==<span class="hljs-number">1</span>)<span class="hljs-comment">//长度为2的串</span>                &#123;                    d[i][j+i]=(s[i]==s[i+<span class="hljs-number">1</span>]);                    <span class="hljs-keyword">if</span>(d[i][i+<span class="hljs-number">1</span>]&amp;&amp;flag)<span class="hljs-comment">//flag用于只记录第一个长度为2的回文串，不用也没关系</span>                    &#123;                        <span class="hljs-built_in">max</span>=<span class="hljs-number">2</span>;                        p=i;                        flag=<span class="hljs-number">0</span>;                    &#125;                &#125;                <span class="hljs-keyword">else</span><span class="hljs-comment">//长度大与2的串</span>                &#123;                    d[i][j+i]=d[i+<span class="hljs-number">1</span>][i+j<span class="hljs-number">-1</span>]&amp;&amp;(s[i]==s[i+j]);<span class="hljs-comment">//转移方程</span>                    <span class="hljs-keyword">if</span>(d[i][j+i]&amp;&amp;j+<span class="hljs-number">1</span>&gt;<span class="hljs-built_in">max</span>)                    &#123;                        <span class="hljs-built_in">max</span>=j+<span class="hljs-number">1</span>;                        p=i;                    &#125;                &#125;            &#125;        &#125;        <span class="hljs-keyword">return</span> s.substr(p, <span class="hljs-built_in">max</span>);<span class="hljs-comment">//从p开始切割max位</span>    &#125;&#125;;</code></pre>]]></content>
    
    
    <categories>
      
      <category>习题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>习题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Unity Mega Fiers导入PC2文件失败</title>
    <link href="/2020/03/07/Unity-Mega-Fiers%E5%AF%BC%E5%85%A5PC2%E6%96%87%E4%BB%B6%E5%A4%B1%E8%B4%A5/"/>
    <url>/2020/03/07/Unity-Mega-Fiers%E5%AF%BC%E5%85%A5PC2%E6%96%87%E4%BB%B6%E5%A4%B1%E8%B4%A5/</url>
    
    <content type="html"><![CDATA[<p><strong>1.前言</strong><br>&emsp;&emsp;如何导入看这篇文章，<a href="https://blog.csdn.net/woerxi/article/details/64922563?depth_1-utm_source=distribute.pc_relevant.none-task&amp;utm_source=distribute.pc_relevant.none-task" target="_blank" rel="noopener">链接</a>，讲的很清楚了<br><strong>2.问题及解决</strong><br>&emsp;&emsp;出现mapping of XXX failed,查了好多资料，最后还是好不容易翻墙找到了<a href="http://www.west-racing.com/mf/?page_id=1335" target="_blank" rel="noopener">官网</a>才知道，这个也太偏僻了</p><pre><code class="hljs plain">Make sure you are using local space point cache files, so for exampleif you are using Max make sure you use the Object Space Point Cache Modifier as opposed to the World Space version and in other packages be sure to click the local space option box in the exporters.Also if you have Mapping Failures check to see if the Optimize Meshoption is turned off in the Unity FBX import settings.</code></pre><p>第一种是坐标问题，我是第二种情况，这个勾去掉就ok</p><img src="/2020/03/07/Unity-Mega-Fiers%E5%AF%BC%E5%85%A5PC2%E6%96%87%E4%BB%B6%E5%A4%B1%E8%B4%A5/20200307193324247.png" srcset="/img/loading.gif" class="" title="在这里插入图片描述"><p>还有，我补充一句，添加point cache组件的object一定是max里用点缓存的，也就是说，该是哪个物体就给哪个物体，这个不要给了父物体</p>]]></content>
    
    
    <categories>
      
      <category>Unity</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Unity</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Unity使用导入FBX的自带动画产生位移</title>
    <link href="/2020/03/06/Unity%E4%BD%BF%E7%94%A8%E5%AF%BC%E5%85%A5FBX%E7%9A%84%E8%87%AA%E5%B8%A6%E5%8A%A8%E7%94%BB%E4%BA%A7%E7%94%9F%E4%BD%8D%E7%A7%BB/"/>
    <url>/2020/03/06/Unity%E4%BD%BF%E7%94%A8%E5%AF%BC%E5%85%A5FBX%E7%9A%84%E8%87%AA%E5%B8%A6%E5%8A%A8%E7%94%BB%E4%BA%A7%E7%94%9F%E4%BD%8D%E7%A7%BB/</url>
    
    <content type="html"><![CDATA[<p><strong>1.描述</strong><br>&emsp;&emsp;在使用3dsMax导出模型带的动画时，再导入Unity，模型会一直移动到一个固定点。<br><strong>2.解决</strong><br>&emsp;&emsp;导出动画时不要选bake烘培，因为这个似乎是带着坐标信息的，我测试了好几次，把这个去掉就ok了。但是不选这个的画如果模型有做一些绑定物品，比如手中握着的东西在导入到unity时会产生一些小偏差，不过可以再重新绑定。</p><img src="/2020/03/06/Unity%E4%BD%BF%E7%94%A8%E5%AF%BC%E5%85%A5FBX%E7%9A%84%E8%87%AA%E5%B8%A6%E5%8A%A8%E7%94%BB%E4%BA%A7%E7%94%9F%E4%BD%8D%E7%A7%BB/20200306141331820.png" srcset="/img/loading.gif" class="" title="在这里插入图片描述">]]></content>
    
    
    <categories>
      
      <category>Unity</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Unity</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Unity使用NetworkServer与NetWorkClient实现服务端与客户端传递消息</title>
    <link href="/2020/02/26/Unity%E4%BD%BF%E7%94%A8NetworkServer%E4%B8%8ENetWorkClient%E5%AE%9E%E7%8E%B0%E6%9C%8D%E5%8A%A1%E7%AB%AF%E4%B8%8E%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%BC%A0%E9%80%92%E6%B6%88%E6%81%AF/"/>
    <url>/2020/02/26/Unity%E4%BD%BF%E7%94%A8NetworkServer%E4%B8%8ENetWorkClient%E5%AE%9E%E7%8E%B0%E6%9C%8D%E5%8A%A1%E7%AB%AF%E4%B8%8E%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%BC%A0%E9%80%92%E6%B6%88%E6%81%AF/</url>
    
    <content type="html"><![CDATA[<h2 id="Unity使用NetworkServer与NetWorkClient实现服务端与客户端传递消息"><a href="#Unity使用NetworkServer与NetWorkClient实现服务端与客户端传递消息" class="headerlink" title="Unity使用NetworkServer与NetWorkClient实现服务端与客户端传递消息"></a>Unity使用NetworkServer与NetWorkClient实现服务端与客户端传递消息</h2><p><strong>1.环境</strong><br>&emsp;&emsp;Unity2018<br><strong>2.前述</strong><br>&emsp;&emsp;第一个想到的方法是使用Socket,也实现了功能,但是我想Unity应该有自带的API用来实现,可是查阅了好多资料,发现大多是使用NetWorkManager,鉴于我的项目对网络的要求十分微小,因此我选择了较为低级NetworkServer和NetWorkClient类<br><strong>3.实现</strong><br>&emsp;&emsp;create一个Emty GameOjbect,挂载以下脚本,注意一下开启客户端方法setClient需要绑定在一个button上,服务端发送信息sendMessage也要绑定在一个button上。<br>&emsp;&emsp;注意，这是从我项目中直接拷贝过来稍微改了一下，可能并不能直接使用，但是应该可以很好的帮助理解这两个类的大致用法,下面是两个文档，好像需要翻墙<br><a href="https://docs.unity3d.com/2018.1/Documentation/ScriptReference/Networking.NetworkServer.html" target="_blank" rel="noopener">NetworkServer文档</a><br><a href="https://docs.unity3d.com/2018.1/Documentation/ScriptReference/Networking.NetworkClient.html" target="_blank" rel="noopener">NetworkClient文档</a></p><p>服务端与客户端的实现<br><pre><code class="hljs c#">using System.Net;using System.Net.Sockets;using UnityEngine;using UnityEngine.Networking;using UnityEngine.UI;public class MyNetWork : MonoBehaviour&#123;    public Text ipText;    private NetworkClient myClient;    void Start()    &#123;        getIp();          &#125;    void Update()    &#123;            &#125;    public void getIp()&#x2F;&#x2F;获取本机IP    &#123;        try        &#123;            IPHostEntry IpEntry &#x3D; Dns.GetHostEntry(Dns.GetHostName());            foreach (IPAddress item in IpEntry.AddressList)            &#123;                &#x2F;&#x2F;AddressFamily.InterNetwork  ipv4                if (item.AddressFamily &#x3D;&#x3D; AddressFamily.InterNetwork)                &#123;                    ipText.text &#x3D; &quot;IP:&quot; + item.ToString();                    MyMessage.ipAddress &#x3D; item.ToString();                    &#x2F;&#x2F;开启服务端                    if(NetworkServer.active)                    &#123;                        NetworkServer.Shutdown();                    &#125;                    else                    &#123;                        starServer();                    &#125;                    return;                &#125;            &#125;            return ;        &#125;        catch &#123; return; &#125;    &#125;    private void starServer()&#x2F;&#x2F;开启服务器    &#123;        NetworkServer.Listen(MyMessage.ipAddress, MyMessage.serverPort);&#x2F;&#x2F;参数为IP和Port        Debug.Log(NetworkServer.active);        &#125;  public void sendMessage()&#x2F;&#x2F;服务端发送消息    &#123;        if(NetworkServer.connections.Count&gt;0)        NetworkServer.SendToAll(MyMessage.msgTypeSend, new MessageInfo(isWalking, steps));    &#125;    public void setClient()&#x2F;&#x2F;开启客户端    &#123;        myClient &#x3D; new NetworkClient();        myClient.RegisterHandler(503, receiveMessage);&#x2F;&#x2F;注册回调函数,参数1为消息类型,数字可以自定义,用于识别回调函数,参数2为回调函数        myClient.Connect(MyMessage.ipAddress, MyMessage.serverPort);&#x2F;&#x2F;连接服务端,参数分别为IP和Port    &#125;    private void receiveMessage(NetworkMessage netMsg)&#x2F;&#x2F;客户端接收信息的回调函数的实现    &#123;        MessageInfo hostMessage &#x3D; netMsg.ReadMessage&lt;MessageInfo&gt;();        bool isWalking&#x3D; hostMessage.isWalking;        long steps  &#x3D; hostMessage.stepCount;        &#x2F;&#x2F;Output the Player name and comment        Debug.Log(&quot;isWalking: &quot; + isWalking);        Debug.Log(&quot;steps  : &quot; + steps);    &#125;&#125;</code></pre><br>MessgafeInfo类是封装的用来发送信息的自定义实体类,继承MessageBase<br><pre><code class="hljs c#">using UnityEngine.Networking;public class MessageInfo : MessageBase&#123;    public bool isWalking;    public long stepCount;    public MessageInfo() &#123; &#125;    public MessageInfo(bool iswalk,long stepcount)    &#123;        this.isWalking &#x3D; iswalk;        this.stepCount &#x3D; stepcount;    &#125;&#125;</code></pre></p>]]></content>
    
    
    <categories>
      
      <category>Unity</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Unity</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Unity Android真机测试</title>
    <link href="/2020/02/22/Unity-Android%E7%9C%9F%E6%9C%BA%E6%B5%8B%E8%AF%95/"/>
    <url>/2020/02/22/Unity-Android%E7%9C%9F%E6%9C%BA%E6%B5%8B%E8%AF%95/</url>
    
    <content type="html"><![CDATA[<h2 id="Unity-Android真机测试"><a href="#Unity-Android真机测试" class="headerlink" title="Unity Android真机测试"></a>Unity Android真机测试</h2><p>两种方法,首先在你需要debug的代码位置用Debug.log(“你想要的信息”)</p><h2 id="一-wifi"><a href="#一-wifi" class="headerlink" title="一.wifi"></a>一.wifi</h2><p>1.手机连数据线,要求电脑,手机同一网段,手机调试模式<br>2.adb tcpip 5555 //port<br>3.adb connect <ip><br>4.adb devices //检查是否连接<br>5.unity中build and run<br>6.unity中edit-&gt;preferences 找到sdk路径 复制 在我的电脑中打开 找到tools文件夹下的monitor打开，搜索栏输入：tag:Unity 观察</p><h2 id="二-usb"><a href="#二-usb" class="headerlink" title="二.usb"></a>二.usb</h2><p>1.手机连数据线,手机调试模式,允许usb 安装 (发现有些手机要有sim卡才能开启usb安装)<br>2.unity中build and run<br>3.unity中edit-&gt;preferences 找到sdk路径 复制 在我的电脑中打开 找到tools文件夹下的monitor打开，搜索栏输入：tag:Unity 观察<br>ps:其中第2步可用以下2步代替<br>①.unity打包出apk<br>②.cmd中adb -s &lt;设备号&gt; install -r <apk路径> //设备号可用adb devices 查看</p><p><strong>Montitor的界面</strong><br><img src="/2020/02/22/Unity-Android%E7%9C%9F%E6%9C%BA%E6%B5%8B%E8%AF%95/20200222155222186.png" srcset="/img/loading.gif" class="" title="在这里插入图片描述">下面是通法,不仅仅适用于unity,可以测试任何apk,这是以前开发安卓时用到的,上面两种其实是特例罢了,<br>1.连数据线,手机调试模式,允许usb 安装<br>2.用android studio(或者其他IDE)打包出apk<br>3.adb -s &lt;设备号&gt; install -r <apk路径> //设备号可用adb devices 查看<br>4.找到sdk路径 复制 在我的电脑中打开 找到tools文件夹下的monitor打开，搜索栏输入：tag:<xxx> 观察,也可以是pid:<xxx>,app:<xxx>,text:<xxx></p><p>ps:以上所有&lt;&gt; 在输入的时候都不同打出来,我只为为了表示这里填的是一个值;<br>用wifi的方法我没试过,因为以前都是用usb连接的习惯了,如果第一种方法有失效请告知</p>]]></content>
    
    
    <categories>
      
      <category>Unity</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Unity</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Unity打包apk后雾效果消失</title>
    <link href="/2020/02/22/Unity%E6%89%93%E5%8C%85apk%E5%90%8E%E9%9B%BE%E6%95%88%E6%9E%9C%E6%B6%88%E5%A4%B1/"/>
    <url>/2020/02/22/Unity%E6%89%93%E5%8C%85apk%E5%90%8E%E9%9B%BE%E6%95%88%E6%9E%9C%E6%B6%88%E5%A4%B1/</url>
    
    <content type="html"><![CDATA[<h2 id="Unity打包apk后雾效果消失"><a href="#Unity打包apk后雾效果消失" class="headerlink" title="Unity打包apk后雾效果消失"></a>Unity打包apk后雾效果消失</h2><p>&emsp;&emsp;今天测试一个雾的效果时，发现在电脑上play有用，等打包到apk时就失效了。讲一下避免以下坑吧。</p><p> <strong>1.环境</strong><br>unity2018</p><p><strong>2.解决方法</strong><br>Edit-&gt;Project Settings-&gt;Graphics 找到Shader Stripping 中fog mode设置为custom（原来是Automatic）,然后选中你想要的模式，最后重新打包就ok</p><img src="/2020/02/22/Unity%E6%89%93%E5%8C%85apk%E5%90%8E%E9%9B%BE%E6%95%88%E6%9E%9C%E6%B6%88%E5%A4%B1/20200222150033160.png" srcset="/img/loading.gif" class="" title="在这里插入图片描述"><p>这三种模式的介绍请看另一篇吧<br><a href="https://blog.csdn.net/qq_36490364/article/details/104444197" target="_blank" rel="noopener">unity fog雾的三种模式</a></p>]]></content>
    
    
    <categories>
      
      <category>Unity</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Bug</tag>
      
      <tag>Unity</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Unity fog雾的三种模式</title>
    <link href="/2020/02/22/Unity-fog%E9%9B%BE%E7%9A%84%E4%B8%89%E7%A7%8D%E6%A8%A1%E5%BC%8F/"/>
    <url>/2020/02/22/Unity-fog%E9%9B%BE%E7%9A%84%E4%B8%89%E7%A7%8D%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h2 id="unity-fog雾的三种模式"><a href="#unity-fog雾的三种模式" class="headerlink" title="unity fog雾的三种模式"></a>unity fog雾的三种模式</h2><p><strong>1.Linear</strong><br>线性模式，有fogStartDistance和fogEndDistance两个参数，雾从Start开始到End越来越浓，End之后也为最大浓度，计算方法为$\frac{end-|z|}{end-start}$，z为相机距离<br><strong>2.Exponential</strong><br>指数模式，有参数fogDensity（取值范围0-1），表示雾的浓度，浓度越大雾越大，计算方法为$e^{-d|z|}$,其中d为浓度，z为相机距离<br><strong>3.Exponential Squared</strong><br>指数平方，有参数fogDensity，越大表示雾越浓，计算方法为$e^{-(dz)^2}$</p><p>ps:fogDensity参数只适用于2，3，fogStartDistance和fogEndDistance只适用于1</p><p>下面是使用代码开启雾气的效果</p><pre><code class="hljs c#">RenderSettings.fog &#x3D; true;&#x2F;&#x2F;开启RenderSettings.fogMode &#x3D; FogMode.ExponentialSquared;&#x2F;&#x2F;模式RenderSettings.fogColor &#x3D; Color.red;&#x2F;&#x2F;颜色RenderSettings.fogDensity &#x3D; 0.04f;&#x2F;&#x2F;浓度</code></pre><p><a href="https://blog.csdn.net/qq_36490364/article/details/104443965" target="_blank" rel="noopener">关于打包apk后雾效果消失的解决方法</a></p>]]></content>
    
    
    <categories>
      
      <category>Unity</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Unity</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HDU1728逃离迷宫DFS</title>
    <link href="/2019/09/03/HDU1728%E9%80%83%E7%A6%BB%E8%BF%B7%E5%AE%ABDFS/"/>
    <url>/2019/09/03/HDU1728%E9%80%83%E7%A6%BB%E8%BF%B7%E5%AE%ABDFS/</url>
    
    <content type="html"><![CDATA[<h2 id="逃离迷宫"><a href="#逃离迷宫" class="headerlink" title="逃离迷宫"></a>逃离迷宫</h2><p>Problem Description</p><p>　　给定一个m × n (m行, n列)的迷宫，迷宫中有两个位置，gloria想从迷宫的一个位置走到另外一个位置，当然迷宫中有些地方是空地，gloria可以穿越，有些地方是障碍，她必须绕行，从迷宫的一个位置，只能走到与它相邻的4个位置中,当然在行走过程中，gloria不能走到迷宫外面去。令人头痛的是，gloria是个没什么方向感的人，因此，她在行走过程中，不能转太多弯了，否则她会晕倒的。我们假定给定的两个位置都是空地，初始时，gloria所面向的方向未定，她可以选择4个方向的任何一个出发，而不算成一次转弯。gloria能从一个位置走到另外一个位置吗？</p><p>Input</p><p>　　第1行为一个整数t (1 ≤ t ≤ 100),表示测试数据的个数，接下来为t组测试数据，每组测试数据中，<br>　　第1行为两个整数m, n (1 ≤ m, n ≤ 100),分别表示迷宫的行数和列数，接下来m行，每行包括n个字符，其中字符’.’表示该位置为空地，字符’*’表示该位置为障碍，输入数据中只有这两种字符，每组测试数据的最后一行为5个整数k, x1, y1, x2, y2 (1 ≤ k ≤ 10, 1 ≤ x1, x2 ≤ n, 1 ≤ y1, y2 ≤ m),其中k表示gloria最多能转的弯数，(x1, y1), (x2, y2)表示两个位置，其中x1，x2对应列，y1, y2对应行。</p><p>Output</p><p>　　每组测试数据对应为一行，若gloria能从一个位置走到另外一个位置，输出“yes”，否则输出“no”。</p><p>Sample Input<br><pre><code class="hljs c++"><span class="hljs-number">2</span><span class="hljs-number">5</span> <span class="hljs-number">5</span>...***.**...........*....<span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">3</span><span class="hljs-number">5</span> <span class="hljs-number">5</span>...***.**...........*....<span class="hljs-number">2</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">3</span></code></pre></p><p>Sample Output<br><pre><code class="hljs plain">noyes</code></pre></p><p><strong>思路:dfs,并且用一个辅助二维数组记录当前坐标的最小转向次数,每次转向path+1,同时每次向四周走的时候用turn记录当前方向,此题的坑在输入的x代表列，y代表行。</strong></p><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">char</span> <span class="hljs-built_in">map</span>[<span class="hljs-number">100</span>][<span class="hljs-number">100</span>];<span class="hljs-keyword">int</span> tt[<span class="hljs-number">100</span>][<span class="hljs-number">100</span>];<span class="hljs-comment">//记录最小转向次数 </span><span class="hljs-keyword">int</span> n, m;<span class="hljs-keyword">int</span> k, x1, yy1, x2, y2;<span class="hljs-keyword">int</span> ans;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y, <span class="hljs-keyword">int</span> path, <span class="hljs-keyword">int</span> <span class="hljs-built_in">turn</span>)</span><span class="hljs-comment">//x,y 坐标,path 转向次数, turn 方向分别为2468，下左右上,参考街机 </span></span><span class="hljs-function"></span>&#123;<span class="hljs-keyword">if</span> (x == y2 - <span class="hljs-number">1</span> &amp;&amp; y == x2 - <span class="hljs-number">1</span> &amp;&amp; tt[y2 - <span class="hljs-number">1</span>][x2 - <span class="hljs-number">1</span>] &lt;= k)<span class="hljs-comment">//出口 </span><span class="hljs-keyword">return</span>;<span class="hljs-keyword">if</span> (x&lt;<span class="hljs-number">0</span> || x&gt;n - <span class="hljs-number">1</span> || y&lt;<span class="hljs-number">0</span> || y&gt;m - <span class="hljs-number">1</span> || <span class="hljs-built_in">map</span>[x][y] == <span class="hljs-string">'*'</span> || tt[x][y] &gt; k)<span class="hljs-comment">//不符合 </span><span class="hljs-keyword">return</span>;<span class="hljs-keyword">if</span> (<span class="hljs-built_in">map</span>[x + <span class="hljs-number">1</span>][y] == <span class="hljs-string">'.'</span>)<span class="hljs-comment">//向左 </span>&#123;<span class="hljs-keyword">if</span> (<span class="hljs-built_in">turn</span> == <span class="hljs-number">2</span> || <span class="hljs-built_in">turn</span> == <span class="hljs-number">0</span>)<span class="hljs-comment">//检查当前方向是否为左或初始点 </span>&#123;<span class="hljs-keyword">if</span> (path&lt;=tt[x + <span class="hljs-number">1</span>][y])<span class="hljs-comment">//转向次数是否比tt数组记录中的小或等于,这边一定要用小于等于, 因为可能有不同路径 </span>&#123;tt[x + <span class="hljs-number">1</span>][y] = path;dfs(x + <span class="hljs-number">1</span>, y, path, <span class="hljs-number">2</span>);&#125;&#125;<span class="hljs-keyword">else</span><span class="hljs-comment">//方向不同要转向 path+1,并调整方向 </span>&#123;<span class="hljs-keyword">if</span> (path + <span class="hljs-number">1</span>&lt;=tt[x + <span class="hljs-number">1</span>][y])&#123;tt[x + <span class="hljs-number">1</span>][y] = path + <span class="hljs-number">1</span>;dfs(x + <span class="hljs-number">1</span>, y, path + <span class="hljs-number">1</span>, <span class="hljs-number">2</span>);&#125;&#125;&#125;<span class="hljs-keyword">if</span> (<span class="hljs-built_in">map</span>[x - <span class="hljs-number">1</span>][y] == <span class="hljs-string">'.'</span>)&#123;<span class="hljs-keyword">if</span> (<span class="hljs-built_in">turn</span> == <span class="hljs-number">8</span> || <span class="hljs-built_in">turn</span> == <span class="hljs-number">0</span>)&#123;<span class="hljs-keyword">if</span> (path&lt;=tt[x - <span class="hljs-number">1</span>][y])&#123;tt[x - <span class="hljs-number">1</span>][y] = path;dfs(x - <span class="hljs-number">1</span>, y, path, <span class="hljs-number">8</span>);&#125;&#125;<span class="hljs-keyword">else</span>&#123;<span class="hljs-keyword">if</span> (path + <span class="hljs-number">1</span>&lt;=tt[x - <span class="hljs-number">1</span>][y])&#123;tt[x - <span class="hljs-number">1</span>][y] = path + <span class="hljs-number">1</span>;dfs(x - <span class="hljs-number">1</span>, y, path + <span class="hljs-number">1</span>, <span class="hljs-number">8</span>);&#125;&#125;&#125;<span class="hljs-keyword">if</span> (<span class="hljs-built_in">map</span>[x][y + <span class="hljs-number">1</span>] == <span class="hljs-string">'.'</span>)&#123;<span class="hljs-keyword">if</span> (<span class="hljs-built_in">turn</span> == <span class="hljs-number">6</span> || <span class="hljs-built_in">turn</span> == <span class="hljs-number">0</span>)&#123;<span class="hljs-keyword">if</span> (path&lt;=tt[x][y + <span class="hljs-number">1</span>])&#123;tt[x][y + <span class="hljs-number">1</span>] = path;dfs(x, y + <span class="hljs-number">1</span>, path, <span class="hljs-number">6</span>);&#125;&#125;<span class="hljs-keyword">else</span>&#123;<span class="hljs-keyword">if</span> (path + <span class="hljs-number">1</span>&lt;=tt[x][y + <span class="hljs-number">1</span>])&#123;tt[x][y + <span class="hljs-number">1</span>] = path + <span class="hljs-number">1</span>;dfs(x, y + <span class="hljs-number">1</span>, path + <span class="hljs-number">1</span>, <span class="hljs-number">6</span>);&#125;&#125;&#125;<span class="hljs-keyword">if</span> (<span class="hljs-built_in">map</span>[x][y - <span class="hljs-number">1</span>] == <span class="hljs-string">'.'</span>)&#123;<span class="hljs-keyword">if</span> (<span class="hljs-built_in">turn</span> == <span class="hljs-number">4</span> || <span class="hljs-built_in">turn</span> == <span class="hljs-number">0</span>)&#123;<span class="hljs-keyword">if</span> (path&lt;=tt[x][y - <span class="hljs-number">1</span>])&#123;tt[x][y - <span class="hljs-number">1</span>] = path;dfs(x, y - <span class="hljs-number">1</span>, path, <span class="hljs-number">4</span>);&#125;&#125;<span class="hljs-keyword">else</span>&#123;<span class="hljs-keyword">if</span> (path + <span class="hljs-number">1</span>&lt;=tt[x][y - <span class="hljs-number">1</span>])&#123;tt[x][y - <span class="hljs-number">1</span>] = path + <span class="hljs-number">1</span>;dfs(x, y - <span class="hljs-number">1</span>, path + <span class="hljs-number">1</span>, <span class="hljs-number">4</span>);&#125;&#125;&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-keyword">int</span> t;<span class="hljs-built_in">cin</span> &gt;&gt; t;<span class="hljs-keyword">while</span> (t--)&#123;<span class="hljs-built_in">cin</span> &gt;&gt; n &gt;&gt; m;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i&lt;n; i++)<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j&lt;m; j++)&#123;<span class="hljs-built_in">cin</span> &gt;&gt; <span class="hljs-built_in">map</span>[i][j];tt[i][j] = <span class="hljs-number">10000</span>;&#125;<span class="hljs-built_in">cin</span> &gt;&gt; k &gt;&gt; x1 &gt;&gt; yy1 &gt;&gt; x2 &gt;&gt; y2;tt[yy1 - <span class="hljs-number">1</span>][x1 - <span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;ans = <span class="hljs-number">0</span>;dfs(yy1 - <span class="hljs-number">1</span>, x1 - <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<span class="hljs-keyword">if</span> (tt[y2 - <span class="hljs-number">1</span>][x2 - <span class="hljs-number">1</span>]&lt;=k)<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"yes"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<span class="hljs-keyword">else</span><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"no"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>习题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>习题</tag>
      
      <tag>DFS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>AOE网</title>
    <link href="/2019/05/20/AOE%E7%BD%91/"/>
    <url>/2019/05/20/AOE%E7%BD%91/</url>
    
    <content type="html"><![CDATA[<h2 id="AOE网"><a href="#AOE网" class="headerlink" title="AOE网"></a>AOE网</h2><p><strong>1.介绍</strong><br>定义：在带权有向图中，以顶点表示事件，有向边表示活动，边上的权值表示完成该活动的开销，则称这种有向图为用边表示活动的网络，简称为AOE网（Activity On Edge Network）</p><p>性质：</p><ul><li>只有在某顶点所代表的事件发生后，从该顶点出发的各有向边所代表的活动才能开始</li><li>只有在进入某一顶点的各有向边所代表的活动都已经结束时，该顶点所代表的事件才发生</li></ul><p><strong>2.几个词的解释</strong><br>ps:事件是点，活动是边！！！</p><p>关键路径：<br>从源点到汇点的所有路径中，具有最长路径长度的路径，该路径上的活动成为<code>关键活动（后面有用先记着）</code></p><p>事件<code>V[k]</code>的最早发生时间<code>ve[k]</code>:<br>从开始顶点V到V[k]的最长路径长度。</p><p>事件<code>V[k]</code>的最迟发生时间<code>vl[k]</code>:<br>不推迟整个工程完成的前提下，即保证它所指向的事件Vi在ve(i)时刻能够发生时，改事件最迟必须发生的事件。</p><p>活动<code>a[i]</code>的最早开始时间<code>e[i]</code>:       活动a[i]用边<code>(V[k],V[j])</code>表示</p><pre><code class="hljs c++">e[i]=ve[k]</code></pre><p>活动<code>a[i]</code>的最迟开始时间<code>l[i]</code>:</p><pre><code class="hljs c++">l[i]=vl[j]-Weight(V[k],V[j])</code></pre><p>一个活动a[i]的松弛时间：<br><code>d[i]=l[i]-e[i]</code>或者<code>d[i]=关键路径长度-包含a[i]活动的最长路径</code></p><p><strong>3.计算</strong><br><img src="/2019/05/20/AOE%E7%BD%91/20190519214237921.png" srcset="/img/loading.gif" class="" title="在这里插入图片描述"></p><p><strong>3.1 计算事件的最早和最迟发生时间</strong></p><p>ve的计算方法为从前往后计算，取最大值，例如对于F,<code>ve(F)=max{ve(B)+a5,ve(E)+a7,ve(G)+a8}</code> ,只有一个的话就只取一个，多个的话，多个中取最大值</p><p>vl的计算方法为从后往前计算，首先另终点J的vl值为其ve，即vl(J)=ve(J)=18，然后多个中取最小值，例如对于B,<code>vl(B)=min{vl(C)-a2,vl(F)-a5,vl(D)-a3}=2</code>;若只有一个，例如对于H,<code>vl(H)=vl(J)-a12=14</code></p><p>最终算出各个顶点的最早和最迟发生时间如下<br>|V|ve（事件最早发生时间）| vl（事件最迟发生事件）|<br>|—|—|—|<br>|  A| 0 |0|<br>|  B| 2 |2|<br>| C| 5 |5|<br>|  D|  4|4|<br>| E| 10 |10|<br>|  F|13 |13|<br>| G| 7 |7|<br>|  H| 12 |14|<br>|  I| 13 |16|<br>|  J|18  |18|</p><p>有以上可以得出ve==vl的点即为关键路径上的事件，即A,B,C,D,E,F,G,J，则有以上点连接的边所代表的活动a1,a2,a3,a4,a6,a7,a8,a10疑似为关键活动<br>注意：<br>关键路径可能不只有一条，计算到这里只能得出关键路径上的事件，具体怎么走还等计算活动的最早和最迟开始时间，如果仅仅需要计算出关键路径，则只需计算几个疑似关键活动的最早和最迟发生时间，为了清楚，我们这里就把全部活动的都计算出来</p><p><strong>3.2活动的最早和最迟开始时间</strong><br>活动最早开始时间：  例如a1,为边（A,B），则<code>a1=ve(A)=0</code>;例如a2,为边（B,C），则a2=ve(B)=2</p><p>活动最晚开始时间：例如对于a1,为边（A,B）,则<code>a1=vl(B)-weight(a1)=2-2=0</code>；例如a12,为边（H,J）,则<code>a12=vl(J)-weight(a12)=18-4=14</code></p><p>最终结果如下</p><div class="table-container"><table><thead><tr><th>a</th><th>e（活动最早开始时间）</th><th>l（活动最迟开始事件）</th></tr></thead><tbody><tr><td>a1</td><td>0</td><td>0</td></tr><tr><td>a2</td><td>2</td><td>2</td></tr><tr><td>a3</td><td>2</td><td>2</td></tr><tr><td>a4</td><td>5</td><td>5</td></tr><tr><td>a5</td><td>2</td><td>9</td></tr><tr><td>a6</td><td>4</td><td>4</td></tr><tr><td>a7</td><td>10</td><td>10</td></tr><tr><td>a8</td><td>7</td><td>7</td></tr><tr><td>a9</td><td>10</td><td>12</td></tr><tr><td>a10</td><td>13</td><td>13</td></tr><tr><td>a11</td><td>7</td><td>10</td></tr><tr><td>a12</td><td>12</td><td>14</td></tr><tr><td>a13</td><td>13</td><td>16</td></tr></tbody></table></div><p>找出e==l的活动ai,这里为a1,a2,a3,,a4,a6,a7,a8,a10;经观察可发现这里有两条关键路径，分别为a1,a2,a4,a7,a10和a1,a3,a6,a8,a10</p><p>又比如问一个活动的松弛时间，即活动ai在不拖延总工程时间的情况下，该活动可以拖延的时间，有两种解法，比如问BF的松弛时间：<br>解1：BF=a5,所以松弛时间=l(a5)-e(a5)=7<br>解2：包含BF活动的最长路径为ABFJ,其长度为11，又因为关键路径长度为18，所以松弛时间为18-11=7</p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>快排C++&amp;Python</title>
    <link href="/2019/03/31/%E5%BF%AB%E6%8E%92C++&amp;Python/"/>
    <url>/2019/03/31/%E5%BF%AB%E6%8E%92C++&amp;Python/</url>
    
    <content type="html"><![CDATA[<h2 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h2><p>1．i =left; j =right; 找一个基准数（随意，这里不妨找a[left]=a[i]），将其挖出。<br>2．j—由后向前找比它小的数，找到后挖出此数填前一个坑a[i]中。<br>3．i++由前向后找比它大的数，找到后也挖出此数填到前一个坑a[j]中。<br>4．重复2，3步，直到i==j，将基准数填入a[i]中。</p><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">quick</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a[],<span class="hljs-keyword">int</span> left,<span class="hljs-keyword">int</span> right)</span></span><span class="hljs-function"></span>&#123;<span class="hljs-keyword">if</span>(left&gt;=right)<span class="hljs-keyword">return</span>;<span class="hljs-keyword">int</span> i=left,j=right,key=a[left];<span class="hljs-keyword">while</span>(i&lt;j)&#123;<span class="hljs-keyword">while</span>((i&lt;j)&amp;&amp;a[j]&gt;=key)j--;<span class="hljs-keyword">if</span>(i&lt;j)a[i++]=a[j];<span class="hljs-keyword">while</span>((i&lt;j)&amp;&amp;a[i]&lt;key)i++;<span class="hljs-keyword">if</span>(i&lt;j)a[j--]=a[i];&#125;a[i]=key;quick(a,left,j<span class="hljs-number">-1</span>);quick(a,j+<span class="hljs-number">1</span>,right);&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-keyword">int</span> a[]=&#123;<span class="hljs-number">-1</span>,<span class="hljs-number">-9</span>,<span class="hljs-number">4</span>,<span class="hljs-number">66</span>,<span class="hljs-number">123</span>,<span class="hljs-number">452</span>,<span class="hljs-number">665</span>,<span class="hljs-number">1</span>,<span class="hljs-number">34</span>&#125;;<span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> len=<span class="hljs-keyword">sizeof</span>(a)/<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>);<span class="hljs-comment">//不用static len会变</span><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;len;i++)<span class="hljs-built_in">cout</span>&lt;&lt;a[i]&lt;&lt;<span class="hljs-string">" "</span>;<span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-built_in">endl</span>;quick(a,<span class="hljs-number">0</span>,len<span class="hljs-number">-1</span>);<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;len;i++)<span class="hljs-built_in">cout</span>&lt;&lt;a[i]&lt;&lt;<span class="hljs-string">" "</span>;<span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-built_in">endl</span>;system(<span class="hljs-string">"pause"</span>);<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h2 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h2><p>1.记位于列表中间的数为mid<br>2.大于mid的放入greater列表<br>3.小于mid的放入less列表<br>4.递归greater和less列表<br><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">quick</span><span class="hljs-params">(arr)</span>:</span>    <span class="hljs-keyword">if</span>(len(arr)&lt;<span class="hljs-number">2</span>):        <span class="hljs-keyword">return</span> arr    mid=arr[len(arr)//<span class="hljs-number">2</span>]    less,greater=[],[]    arr.remove(mid)    <span class="hljs-keyword">for</span> num <span class="hljs-keyword">in</span> arr:        <span class="hljs-keyword">if</span>(num&gt;mid):            greater.append(num)        <span class="hljs-keyword">else</span>:            less.append(num)    <span class="hljs-keyword">return</span> quick(less)+[mid]+quick(greater)    arr=[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">5</span>,<span class="hljs-number">5</span>,<span class="hljs-number">5</span>,<span class="hljs-number">5</span>,<span class="hljs-number">31</span>,<span class="hljs-number">4</span>]arr=quick(arr)print(<span class="hljs-string">' '</span>.join([str(i)<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> arr]))</code></pre></p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
      <category>Python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>习题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>java.awt.Robot的mouseMove(x,y)效果不起作用</title>
    <link href="/2019/03/29/java.awt.Robot%E7%9A%84mouseMove(x,y)%E6%95%88%E6%9E%9C%E4%B8%8D%E8%B5%B7%E4%BD%9C%E7%94%A8/"/>
    <url>/2019/03/29/java.awt.Robot%E7%9A%84mouseMove(x,y)%E6%95%88%E6%9E%9C%E4%B8%8D%E8%B5%B7%E4%BD%9C%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p><code>mouseMove(x,y)</code>，此函数是使鼠标移动到<code>（x,y）</code>位置<br>测试发现它是一个逐渐逼近的过程，所以外面套个循环，就能移动到想要的位置了<br>原因未知，不知是不是win10的锅</p><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.awt.Robot;Robot robot=<span class="hljs-keyword">new</span> Robot();<span class="hljs-keyword">int</span> k=<span class="hljs-number">10</span>;<span class="hljs-keyword">int</span> x=<span class="hljs-number">666</span>;<span class="hljs-keyword">int</span> y=<span class="hljs-number">666</span>;<span class="hljs-keyword">while</span>((--k)&gt;<span class="hljs-number">0</span>)&#123;robot.mouseMove(x,y);&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Bug</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>KMP算法及手工求解next数组</title>
    <link href="/2019/03/18/KMP%E7%AE%97%E6%B3%95%E5%8F%8A%E6%89%8B%E5%B7%A5%E6%B1%82%E8%A7%A3next%E6%95%B0%E7%BB%84/"/>
    <url>/2019/03/18/KMP%E7%AE%97%E6%B3%95%E5%8F%8A%E6%89%8B%E5%B7%A5%E6%B1%82%E8%A7%A3next%E6%95%B0%E7%BB%84/</url>
    
    <content type="html"><![CDATA[<h2 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a>KMP算法</h2><p>详解找来找去感觉还是这两篇解释的很好<br><a href="https://segmentfault.com/a/1190000008575379?utm_medium=referral&amp;utm_source=tuicool" target="_blank" rel="noopener">KMP算法（1）：如何理解KMP</a><br><a href="https://segmentfault.com/a/1190000009409706" target="_blank" rel="noopener">KMP算法（2）：其细微之处</a></p><h2 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a><strong>笔记</strong></h2><img src="/2019/03/18/KMP%E7%AE%97%E6%B3%95%E5%8F%8A%E6%89%8B%E5%B7%A5%E6%B1%82%E8%A7%A3next%E6%95%B0%E7%BB%84/2019031822273034.png" srcset="/img/loading.gif" class="" title="在这里插入图片描述"><p>next[i]=j,即模式串p[1-i]的最长的相同真前后缀的长度<br><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"stdafx.h"</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"string"</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"iostream"</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">getNext</span><span class="hljs-params">(<span class="hljs-built_in">string</span> p, <span class="hljs-keyword">int</span> next[])</span></span><span class="hljs-function"></span>&#123;<span class="hljs-keyword">int</span> len = p.<span class="hljs-built_in">size</span>();<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;<span class="hljs-keyword">int</span> j = <span class="hljs-number">-1</span>;next[<span class="hljs-number">0</span>] = <span class="hljs-number">-1</span>;<span class="hljs-keyword">while</span> (i &lt; len - <span class="hljs-number">1</span>)&#123;<span class="hljs-keyword">if</span> (j == <span class="hljs-number">-1</span> || p[i] == p[j])next[++i] = ++j;<span class="hljs-keyword">else</span>j = next[j];&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">KMP</span><span class="hljs-params">(<span class="hljs-built_in">string</span> s, <span class="hljs-built_in">string</span> p, <span class="hljs-keyword">int</span> next[])</span></span><span class="hljs-function"></span>&#123;<span class="hljs-keyword">int</span> i, j;<span class="hljs-keyword">int</span> pl = p.<span class="hljs-built_in">size</span>();<span class="hljs-keyword">int</span> sl = s.<span class="hljs-built_in">size</span>();<span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>; i &lt; sl&amp;&amp; j &lt; pl;)<span class="hljs-comment">//注意这里不要用j&lt;p.size() 因为p.size()是unsigned int 类型，然后j有可能变成-1然后直接跳出循环</span>&#123;<span class="hljs-keyword">if</span> (j == <span class="hljs-number">-1</span> || s[i] == p[j])&#123;i++;j++;&#125;<span class="hljs-keyword">else</span>j = next[j];&#125;<span class="hljs-keyword">if</span> (j == p.<span class="hljs-built_in">size</span>())<span class="hljs-keyword">return</span> i - j;<span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-keyword">int</span> next[<span class="hljs-number">100</span>] = &#123; <span class="hljs-number">0</span> &#125;;<span class="hljs-built_in">string</span> s = <span class="hljs-string">"abababababcdab"</span>;<span class="hljs-built_in">string</span> p = <span class="hljs-string">"abcdab"</span>;<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"主串:"</span> &lt;&lt; s &lt;&lt; <span class="hljs-built_in">endl</span>;<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"子串:"</span> &lt;&lt; p &lt;&lt; <span class="hljs-built_in">endl</span>;getNext(p, next);<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"next数组为："</span>;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; p.<span class="hljs-built_in">size</span>(); i++)<span class="hljs-built_in">cout</span> &lt;&lt; next[i];<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"匹配位置:"</span> &lt;&lt; KMP(s, p, next) &lt;&lt; <span class="hljs-built_in">endl</span>;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></p><h2 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h2><img src="/2019/03/18/KMP%E7%AE%97%E6%B3%95%E5%8F%8A%E6%89%8B%E5%B7%A5%E6%B1%82%E8%A7%A3next%E6%95%B0%E7%BB%84/20190321174723805.png" srcset="/img/loading.gif" class="" title="在这里插入图片描述"><h2 id="手工求解next数组方法"><a href="#手工求解next数组方法" class="headerlink" title="手工求解next数组方法"></a>手工求解next数组方法</h2><p>以下两种方法互通，分别为以0为初始或以-1为初始</p><p><strong>1.以0为初始</strong></p><div class="table-container"><table><thead><tr><th>i</th><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th><th>10</th></tr></thead><tbody><tr><td> p</td><td>a</td><td>b</td><td>a</td><td>b</td><td>a</td><td>a</td><td>a</td><td>b</td><td>a</td><td>b</td><td>a </td></tr><tr><td> next</td><td>0</td><td>1</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table></div><ol><li>当i=0，1 next[0],next[1]分别初始为0，1</li><li>当i=2,p的前2位为 <code>ab</code>,因<code>next[1]=1</code>，则观察<code>ab</code>的前<code>1</code>位和后<code>1</code>位是否相同，不同，所以<code>next[2]=1</code>(记住后面运算时若连1位相同都没有则记为<code>1</code>，即最小记为1，其实看后面就知道意思是<code>next[i]=0+1=1</code>)</li><li>当i=3,p的前3位为<code>aba</code>,因<code>next[2]=1</code>,则观察<code>aba</code>的前<code>1</code>位和后<code>1</code>位是否相同，相同，则在原基础上<code>+1</code>，即<code>next[3]=1+1=2</code></li><li>当i=4,p的前4位为<code>abab</code>,因<code>next[3]=2</code>,则观察<code>abab</code>的前<code>2</code>位和后<code>2</code>位是否相同，相同，则在原基础上<code>+1</code>，即<code>next[4]=2+1=3</code></li><li>当i=5,p的前5位为<code>ababa</code>,因<code>next[4]=3</code>,则观察<code>ababa</code>的前<code>3</code>位和后<code>3</code>位是否相同，相同，则在原基础上<code>+1</code>，即<code>next[5]=3+1=4</code></li><li>当i=6,p的前6位为<code>ababaa</code>,因<code>next[5]=4</code>,则观察<code>ababaa</code>的前<code>4</code>位和后<code>4</code>位是否相同，不相同，则在原基础上<code>-1</code>，观察前<code>3</code>位和后<code>3</code>位是否相同，不同继续<code>-1</code>，直到观察到前<code>2</code>位和后<code>2</code>位相同，若不同再继续减，后观察到前1位和后1位相同，则next[6]=1+1=2</li><li>当i=7,p的前7位为<code>ababaaa</code>,因<code>next[5]=2</code>,则观察<code>ababaaa</code>的前<code>2</code>位和后<code>2</code>位是否相同，不相同，则在原基础上<code>-1</code>，观察前<code>1</code>位和后<code>1</code>位是否相同，相同，则next[7]=1+1=2</li><li>…</li><li>…</li><li>…   </li></ol><p>最终为</p><div class="table-container"><table><thead><tr><th>i</th><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th><th>10</th></tr></thead><tbody><tr><td>p</td><td>a</td><td>b</td><td>a</td><td>b</td><td>a</td><td>a</td><td>a</td><td>b</td><td>a</td><td>b</td><td>a</td></tr><tr><td>next</td><td>0</td><td>1</td><td>1</td><td>2</td><td>3</td><td>4</td><td>2</td><td>2</td><td>3</td><td>4</td><td>5</td></tr></tbody></table></div><p><strong>2.以-1为初始</strong></p><div class="table-container"><table><thead><tr><th>i</th><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th><th>10</th></tr></thead><tbody><tr><td>p</td><td>a</td><td>b</td><td>a</td><td>b</td><td>a</td><td>a</td><td>a</td><td>b</td><td>a</td><td>b</td><td>a</td></tr><tr><td>next</td><td>-1</td><td>0</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table></div><ol><li>当i=0，1 next[0],next[1]分别初始为-1，0</li><li>当i=2，p的前2位为<code>ab</code>,因<code>next[1]=0</code>，则<code>next[1]+1=1</code>,观察前<code>1</code>位和后<code>1</code>位是否相同，不同，则<code>1-1=0</code>，到0为止，则<code>next[2]=0</code>（<code>1-1=0</code>中第一个1的意思即前1位和后1位是否相同中的1）</li><li>当i=3,p的前3位为<code>aba</code>,因<code>next[2]=0</code>,则<code>next[2]+1=1</code>,则观察的前<code>1</code>位和后<code>1</code>位是否相同，相同，则<code>next[3]=1</code></li><li>当i=4,p的前4位为<code>abab</code>,因<code>next[3]=1</code>,则<code>next[3]+1=2</code>,则观察前<code>2</code>位和后<code>2</code>位是否相同，相同，则<code>next[4]=2</code></li><li>当i=5,p的前5位为<code>ababa</code>,因<code>next[4]=2</code>,则<code>next[4]+1=3</code>,则观察前<code>3</code>位和后<code>3</code>位是否相同，相同，则<code>next[4]=3</code></li><li>当i=6,p的前6位为<code>ababaa</code>,因<code>next[5]=3</code>,则<code>next[5]+1=4</code>,则观察前<code>4</code>位和后<code>4</code>位是否相同，不相同;则观察前<code>3</code>位和后<code>3</code>位是否相同，不同;则观察前<code>2</code>位和后<code>2</code>位是否相同，不相同;则观察前<code>1</code>位和后<code>1</code>位是否相同，相同，则<code>next[6]=1</code></li><li>当i=7,p的前6位为<code>ababaaa</code>,因<code>next[6]=1</code>,则<code>next[6]+1=2</code>,则观察前<code>2</code>位和后<code>2</code>位是否相同，不相同;则观察前<code>1</code>位和后<code>1</code>位是否相同，相同，则<code>next[7]=1</code></li><li>…</li><li>…</li><li><p>…</p><p>最终为</p></li></ol><div class="table-container"><table><thead><tr><th>i</th><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th><th>10</th></tr></thead><tbody><tr><td>p</td><td>a</td><td>b</td><td>a</td><td>b</td><td>a</td><td>a</td><td>a</td><td>b</td><td>a</td><td>b</td><td>a</td></tr><tr><td>next</td><td>-1</td><td>0</td><td>0</td><td>1</td><td>2</td><td>3</td><td>1</td><td>1</td><td>2</td><td>3</td><td>4</td></tr></tbody></table></div><p><strong>俩种方法的关系</strong><br>观察发现法1的next数组每项+1就是法2的next数组，所以考试时无论用哪一种都是可以的，只要<code>分析或者看清</code>是以什么为初值就行<br>其实还可以理解为把法1的next数组向右移1位，并把首位赋值位-1</p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Mysql Err1055 ONLY_FULL_GROUP_BY 存储过程</title>
    <link href="/2019/01/21/Mysql-Err1055-ONLY_FULL_GROUP_BY-%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B/"/>
    <url>/2019/01/21/Mysql-Err1055-ONLY_FULL_GROUP_BY-%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><p>Ubuntu16.04<br>Mysql5.7<br><strong>1.背景</strong><br>Err 1055 报错 sql_moede为ONLY_FULL_GROUP_BY,具体错误原因不介绍了.按提示改变sql_mode后存储过程中仍报改错.<br><strong>2.解决方法</strong><br>修改/etc/mysql/my.cnf 可以在最后加上如下<br><pre><code class="hljs mysql">[mysqld]sql_mode &#x3D;&quot;STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION&quot;</code></pre><br>然后 service mysql restart 重启服务<br>还有一些其他的设置sql_mode的方法,可自行了解<br>但是按照上面方法做完后在查询中不会再报1055,但是使用存储过程仍旧有问题,解决方法就是<br>…<br>…<br>…<br>复制,删除,新建,粘贴!!!<br>新建一个存储过程就OK,具体原因不了解,总之是个大坑</p>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Mysql</tag>
      
      <tag>Bug</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>python numpy的数组切片和其中None的意思</title>
    <link href="/2018/11/02/python-numpy%E7%9A%84%E6%95%B0%E7%BB%84%E5%88%87%E7%89%87%E5%92%8C%E5%85%B6%E4%B8%ADNone%E7%9A%84%E6%84%8F%E6%80%9D/"/>
    <url>/2018/11/02/python-numpy%E7%9A%84%E6%95%B0%E7%BB%84%E5%88%87%E7%89%87%E5%92%8C%E5%85%B6%E4%B8%ADNone%E7%9A%84%E6%84%8F%E6%80%9D/</url>
    
    <content type="html"><![CDATA[<h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><p>python 3.6<br>numpy<br><strong>1.背景</strong><br>    今天有人问我numpy中[1:3,None]是啥意思,一开始讲得云里雾里,后来终于理清了，我们逐步深入研究♂(滑稽)<br><strong>2.一维情况</strong></p><pre><code class="hljs python"><span class="hljs-keyword">import</span>  numpy <span class="hljs-keyword">as</span> npa=np.array([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>])print(a[<span class="hljs-number">0</span>:<span class="hljs-number">3</span>:<span class="hljs-number">2</span>])</code></pre><p>输出</p><pre><code class="hljs python">[<span class="hljs-number">1</span> <span class="hljs-number">3</span>]</code></pre><p>一维应该都知道吧 跟list差不多 [Start:End:Step] 注意是不包含End<br><strong>2.二维情况</strong><br>{% asset_img 20181101011506918.png 在这里插入图片描述 %}</p><pre><code class="hljs python"><span class="hljs-keyword">import</span>  numpy <span class="hljs-keyword">as</span> npa=np.array([[<span class="hljs-number">11</span>,<span class="hljs-number">12</span>,<span class="hljs-number">13</span>,<span class="hljs-number">14</span>],[<span class="hljs-number">21</span>,<span class="hljs-number">22</span>,<span class="hljs-number">23</span>,<span class="hljs-number">24</span>],[<span class="hljs-number">31</span>,<span class="hljs-number">32</span>,<span class="hljs-number">33</span>,<span class="hljs-number">34</span>],[<span class="hljs-number">41</span>,<span class="hljs-number">42</span>,<span class="hljs-number">43</span>,<span class="hljs-number">44</span>]])print(a[<span class="hljs-number">0</span>:<span class="hljs-number">4</span>:<span class="hljs-number">2</span>,<span class="hljs-number">0</span>:<span class="hljs-number">4</span>:<span class="hljs-number">2</span>])</code></pre><p>输出</p><pre><code class="hljs python">[[<span class="hljs-number">11</span> <span class="hljs-number">13</span>] [<span class="hljs-number">31</span> <span class="hljs-number">33</span>]]</code></pre><p>所以第0维取0到4步长为2 ，第1维也取0到4步长为2 ，所以意思是[第0维,第1维]，然后多维类推嘛，应该能理解了吧<br><strong>3.关于None</strong><br>再说说一开始的[:,None]</p><font color=red size=5>emmmm简单说就是说它增加了一个维度</font>但还是有些不同的，看例子<pre><code class="hljs python"><span class="hljs-keyword">import</span>  numpy <span class="hljs-keyword">as</span> npa=np.array([[<span class="hljs-number">11</span>,<span class="hljs-number">12</span>,<span class="hljs-number">13</span>,<span class="hljs-number">14</span>],[<span class="hljs-number">21</span>,<span class="hljs-number">22</span>,<span class="hljs-number">23</span>,<span class="hljs-number">24</span>],[<span class="hljs-number">31</span>,<span class="hljs-number">32</span>,<span class="hljs-number">33</span>,<span class="hljs-number">34</span>],[<span class="hljs-number">41</span>,<span class="hljs-number">42</span>,<span class="hljs-number">43</span>,<span class="hljs-number">44</span>]])print(<span class="hljs-string">'0维为None:'</span>)print(a[<span class="hljs-literal">None</span>,<span class="hljs-number">0</span>:<span class="hljs-number">4</span>])print(<span class="hljs-string">'1维为None:'</span>)print(a[<span class="hljs-number">0</span>:<span class="hljs-number">4</span>,<span class="hljs-literal">None</span>])</code></pre>输出<pre><code class="hljs python"><span class="hljs-number">0</span>维为<span class="hljs-literal">None</span>:[[[<span class="hljs-number">11</span> <span class="hljs-number">12</span> <span class="hljs-number">13</span> <span class="hljs-number">14</span>]  [<span class="hljs-number">21</span> <span class="hljs-number">22</span> <span class="hljs-number">23</span> <span class="hljs-number">24</span>]  [<span class="hljs-number">31</span> <span class="hljs-number">32</span> <span class="hljs-number">33</span> <span class="hljs-number">34</span>]  [<span class="hljs-number">41</span> <span class="hljs-number">42</span> <span class="hljs-number">43</span> <span class="hljs-number">44</span>]]]<span class="hljs-number">1</span>维为<span class="hljs-literal">None</span>:[[[<span class="hljs-number">11</span> <span class="hljs-number">12</span> <span class="hljs-number">13</span> <span class="hljs-number">14</span>]] [[<span class="hljs-number">21</span> <span class="hljs-number">22</span> <span class="hljs-number">23</span> <span class="hljs-number">24</span>]] [[<span class="hljs-number">31</span> <span class="hljs-number">32</span> <span class="hljs-number">33</span> <span class="hljs-number">34</span>]] [[<span class="hljs-number">41</span> <span class="hljs-number">42</span> <span class="hljs-number">43</span> <span class="hljs-number">44</span>]]]</code></pre>看下官方文档,[链接](https://www.numpy.org/devdocs/reference/arrays.indexing.html)<pre><code class="hljs python">Note:Remember that a slicing tuple can always be constructed <span class="hljs-keyword">as</span> obj <span class="hljs-keyword">and</span> used <span class="hljs-keyword">in</span> the x[obj] notation. Slice objects can be used <span class="hljs-keyword">in</span> the construction <span class="hljs-keyword">in</span> place of the [start:stop:step] notation.For example, x[<span class="hljs-number">1</span>:<span class="hljs-number">10</span>:<span class="hljs-number">5</span>,::<span class="hljs-number">-1</span>] can also be implemented <span class="hljs-keyword">as</span> obj = (slice(<span class="hljs-number">1</span>,<span class="hljs-number">10</span>,<span class="hljs-number">5</span>), slice(<span class="hljs-literal">None</span>,<span class="hljs-literal">None</span>,<span class="hljs-number">-1</span>)); x[obj].This can be useful <span class="hljs-keyword">for</span> constructing generic code that works on arrays of arbitrary dimension.</code></pre><pre><code class="hljs python">numpy.newaxisThe newaxis object can be used <span class="hljs-keyword">in</span> all slicing operations to create an axis of length one.newaxis <span class="hljs-keyword">is</span> an alias <span class="hljs-keyword">for</span> ‘<span class="hljs-literal">None</span>’, <span class="hljs-keyword">and</span> ‘<span class="hljs-literal">None</span>’ can be used <span class="hljs-keyword">in</span> place of this <span class="hljs-keyword">with</span> the same result.</code></pre>它巴拉巴拉的意思就是<font color=red size=5>numpy.newaxis效果和None是一样的，None是它的别名</font><pre><code class="hljs python">print(<span class="hljs-literal">None</span> <span class="hljs-keyword">is</span> np.newaxis)<span class="hljs-literal">True</span></code></pre><p>(话说为了少打点字（len(None)&lt;len(numpy.newaxis)）,可能就会让初学者看不懂- -，但是告诉他们答案我想他们肯定想暴打写代码的人♂（呼应前文滑稽）)<br>想更详细的知道numpy.newaxis的可以自己去搜搜啦</p>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>numpy</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python 凯撒加密</title>
    <link href="/2018/10/21/Python-%E5%87%AF%E6%92%92%E5%8A%A0%E5%AF%86/"/>
    <url>/2018/10/21/Python-%E5%87%AF%E6%92%92%E5%8A%A0%E5%AF%86/</url>
    
    <content type="html"><![CDATA[<p>在密码学中，恺撒密码是一种最简单且最广为人知的加密技术。它是一种替换加密的技术，明文中的所有字母都在字母表上向后（或向前）按照一个固定数目进行偏移后被替换成密文。例，当偏移量是3的时候，所有的字母A将被替换成D，B变成E，以此类推。</p><pre><code class="hljs python">n=input(<span class="hljs-string">"请输入移位："</span>)n=int(n)str_mi=input(<span class="hljs-string">"请输入需要加密的字符串："</span>)<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">jiami</span><span class="hljs-params">(str_1,n)</span>:</span>    ans=list(str_1)    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">0</span>,len(ans)):        <span class="hljs-keyword">if</span> ans[i].islower():            num = ord(ans[i])            ans[i] = chr((num - <span class="hljs-number">97</span> + n) % <span class="hljs-number">26</span> + <span class="hljs-number">97</span>)        <span class="hljs-keyword">if</span> ans[i].isupper():            num = ord(ans[i])            ans[i] = chr((num - <span class="hljs-number">65</span> + n) % <span class="hljs-number">26</span> + <span class="hljs-number">65</span>)    <span class="hljs-keyword">return</span> <span class="hljs-string">''</span>.join(ans)<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">jiemi</span><span class="hljs-params">(str_1)</span>:</span>    print(str_1+<span class="hljs-string">"的可能的明文为:"</span>)    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">0</span>,<span class="hljs-number">25</span>):        print(jiami(str_1,i))print(<span class="hljs-string">"加密后为："</span>+jiami(str_mi,n))jiemi(jiami(str_mi,n))</code></pre><img src="/2018/10/21/Python-%E5%87%AF%E6%92%92%E5%8A%A0%E5%AF%86/20181021154702527.png" srcset="/img/loading.gif" class="" title="在这里插入图片描述">]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>习题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>爬取微博热搜榜单存入mysql并部署在云服务器上</title>
    <link href="/2018/10/19/%E7%88%AC%E5%8F%96%E5%BE%AE%E5%8D%9A%E7%83%AD%E6%90%9C%E6%A6%9C%E5%8D%95%E5%AD%98%E5%85%A5mysql%E5%B9%B6%E9%83%A8%E7%BD%B2%E5%9C%A8%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A/"/>
    <url>/2018/10/19/%E7%88%AC%E5%8F%96%E5%BE%AE%E5%8D%9A%E7%83%AD%E6%90%9C%E6%A6%9C%E5%8D%95%E5%AD%98%E5%85%A5mysql%E5%B9%B6%E9%83%A8%E7%BD%B2%E5%9C%A8%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A/</url>
    
    <content type="html"><![CDATA[<h2 id="环境："><a href="#环境：" class="headerlink" title="环境："></a>环境：</h2><p>python3.5.2<br><strong>涉及的库:</strong><br>requests<br>bs4<br>pymysql<br><strong>服务器:</strong><br>Ubuntu16.04<br><strong>1.代码</strong></p><pre><code class="hljs python"><span class="hljs-keyword">import</span> requests<span class="hljs-keyword">import</span> datetime<span class="hljs-keyword">import</span> time<span class="hljs-keyword">import</span> pymysql<span class="hljs-keyword">from</span> bs4 <span class="hljs-keyword">import</span> BeautifulSoup<span class="hljs-keyword">import</span> randomhottime=<span class="hljs-string">''</span><span class="hljs-comment">#时间</span>sql = <span class="hljs-string">"insert into hottop(time,top)values(%s,%s)"</span>db = pymysql.connect(<span class="hljs-string">"数据库的ip"</span>,<span class="hljs-string">"数据库用户名"</span>,<span class="hljs-string">"密码"</span>,<span class="hljs-string">"weibohot"</span>)cursor = db.cursor()<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">Gethot</span><span class="hljs-params">()</span>:</span>    url = <span class="hljs-string">'https://s.weibo.com/top/summary?cate=realtimehot'</span>    <span class="hljs-comment">#这里为了稳定,可以添加一个user-Agent的池,然后每次用的时候随机一个,也可以添加ip池</span>    header=&#123;        <span class="hljs-string">'User-Agent'</span>:<span class="hljs-string">'Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:61.0) Gecko/20100101 Firefox/61.0'</span>    &#125;    <span class="hljs-keyword">try</span>:        <span class="hljs-comment"># global 声明接下来用的hottime是全局变量,</span>        <span class="hljs-comment"># 如果不加这个,它会变成局部变量,即使你在函数外声明了一个hottime</span>        <span class="hljs-keyword">global</span> hottime        hottime = datetime.datetime.now().strftime(<span class="hljs-string">"%Y-%m-%d %H:%M:%S"</span>)        hotweb = requests.get(url, headers=header, timeout=<span class="hljs-number">10</span>)    <span class="hljs-keyword">except</span>:        print(hottime+<span class="hljs-string">':http Error'</span>)    <span class="hljs-keyword">else</span>:        soup = BeautifulSoup(hotweb.text, <span class="hljs-string">"html.parser"</span>)        ans = soup.find_all(<span class="hljs-string">'td'</span>)        top = <span class="hljs-string">''</span>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> ans:            a = i.find(<span class="hljs-string">'a'</span>)  <span class="hljs-comment"># a标签内容，即热搜内容</span>            span = i.find(<span class="hljs-string">'span'</span>)  <span class="hljs-comment"># span标签内的的热度</span>            <span class="hljs-keyword">if</span> (a != <span class="hljs-literal">None</span> <span class="hljs-keyword">and</span> span != <span class="hljs-literal">None</span>):                top += a.get_text() + <span class="hljs-string">'__'</span> + span.get_text() + <span class="hljs-string">'\n'</span>        <span class="hljs-keyword">return</span> toperrorcount=<span class="hljs-number">0</span><span class="hljs-comment">#5次错误跳出循环</span><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:    <span class="hljs-keyword">try</span>:        top = Gethot()        cursor.execute(sql,(hottime,top))    <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:        errorcount+=<span class="hljs-number">1</span>        db.rollback()        print(hottime+<span class="hljs-string">":执行MySQL: %s 时出错：%s"</span> % (sql, e))        <span class="hljs-keyword">if</span>(errorcount==<span class="hljs-number">5</span>):            <span class="hljs-keyword">break</span>        <span class="hljs-keyword">else</span>:            time.sleep(<span class="hljs-number">10</span>)            <span class="hljs-keyword">continue</span>    <span class="hljs-keyword">else</span>:        db.commit()        time.sleep(random.randint(<span class="hljs-number">450</span>,<span class="hljs-number">550</span>))<span class="hljs-comment">#每次sleep随机450-550秒</span></code></pre><p><strong>2.数据表</strong></p><div class="table-container"><table><thead><tr><th>time</th><th>top</th></tr></thead><tbody><tr><td>datetime</td><td>varchar(2000)</td></tr></tbody></table></div><p>DDL语句:(不设置utf-8可能会出错- -)<br><pre><code class="hljs mysql">CREATE TABLE &#96;hottop&#96; (  &#96;time&#96; datetime NOT NULL,  &#96;top&#96; varchar(2000) NOT NULL)DEFAULT CHARSET&#x3D;utf8;</code></pre><br><strong>3.部署到服务器</strong><br>如果你是在本地写的代码,先把文件上传到服务器(可以通过ftp啥的,方法多多),<br>关于运行,weibohot.py是代码文件, log.file是通过print输出的日志文件(可以不必先创建,运行下面命令它自己也会创建)</p><pre><code class="hljs shell">nohup python3 -u weibohot.py &gt; log.file 2&gt;&amp;1 &amp;</code></pre><p>nohup命令可以看<a href="https://blog.csdn.net/liuyanfeier/article/details/62422742" target="_blank" rel="noopener">这篇文章</a>,我觉得介绍的很精简明要,现在市面上的云服务基本都给你装好了python2和3环境,直接用python命令的话一开始都应该默认为2,-u参数是不启用缓冲(否则你print出来的东西可能不会马上输出到log.file日志中)<br>其实仅仅如此还是不够的,它在运行中可能还会遇到各种问题之类的,因此想要更好的可以写个shell脚本,断线邮件提醒啊,重连啊…<br><strong>4.结果</strong><br><img src="/2018/10/19/%E7%88%AC%E5%8F%96%E5%BE%AE%E5%8D%9A%E7%83%AD%E6%90%9C%E6%A6%9C%E5%8D%95%E5%AD%98%E5%85%A5mysql%E5%B9%B6%E9%83%A8%E7%BD%B2%E5%9C%A8%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A/20181019001055507.png" srcset="/img/loading.gif" class="" title="在这里插入图片描述"></p>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>爬虫</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用阿里云ECS安装mysql及远程登录的一些小问题</title>
    <link href="/2018/10/15/%E4%BD%BF%E7%94%A8%E9%98%BF%E9%87%8C%E4%BA%91ECS%E5%AE%89%E8%A3%85mysql%E5%8F%8A%E8%BF%9C%E7%A8%8B%E7%99%BB%E5%BD%95%E7%9A%84%E4%B8%80%E4%BA%9B%E5%B0%8F%E9%97%AE%E9%A2%98/"/>
    <url>/2018/10/15/%E4%BD%BF%E7%94%A8%E9%98%BF%E9%87%8C%E4%BA%91ECS%E5%AE%89%E8%A3%85mysql%E5%8F%8A%E8%BF%9C%E7%A8%8B%E7%99%BB%E5%BD%95%E7%9A%84%E4%B8%80%E4%BA%9B%E5%B0%8F%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p><strong>1.Unable to locate package xxx</strong> </p><img src="/2018/10/15/%E4%BD%BF%E7%94%A8%E9%98%BF%E9%87%8C%E4%BA%91ECS%E5%AE%89%E8%A3%85mysql%E5%8F%8A%E8%BF%9C%E7%A8%8B%E7%99%BB%E5%BD%95%E7%9A%84%E4%B8%80%E4%BA%9B%E5%B0%8F%E9%97%AE%E9%A2%98/20181015222129131.png" srcset="/img/loading.gif" class="" title="在这里插入图片描述"><p>解决方法:</p><pre><code>sudo apt-get update</code></pre><p><strong>2.远程登录</strong><br>        选择创建一个用于远程登录的用户:</p><pre><code class="hljs shell">GRANT ALL PRIVILEGES ON *.* TO 'username'@'%' IDENTIFIED BY 'password' WITH GRANT OPTION;</code></pre><p>生效:</p><pre><code class="hljs shell">flush privileges;</code></pre><p>​        接下来一步,看了网上许多说的,都是vim /etc/mysql/my.cnf 将里面的bind-address = 127.0.0.1改为0.0.0.0,我试了下 然后进行重启服务(/etc/init.d/mysql restart),最后遇到报错:<br>mysql.serviceJob for mysql.service failed because the control process exited with error code. See “systemctl status mysql.service” and “journalctl -xe” for details.failed!</p><img src="/2018/10/15/%E4%BD%BF%E7%94%A8%E9%98%BF%E9%87%8C%E4%BA%91ECS%E5%AE%89%E8%A3%85mysql%E5%8F%8A%E8%BF%9C%E7%A8%8B%E7%99%BB%E5%BD%95%E7%9A%84%E4%B8%80%E4%BA%9B%E5%B0%8F%E9%97%AE%E9%A2%98/20181015222017843.png" srcset="/img/loading.gif" class="" title="在这里插入图片描述"><p>???<br><img src="/2018/10/15/%E4%BD%BF%E7%94%A8%E9%98%BF%E9%87%8C%E4%BA%91ECS%E5%AE%89%E8%A3%85mysql%E5%8F%8A%E8%BF%9C%E7%A8%8B%E7%99%BB%E5%BD%95%E7%9A%84%E4%B8%80%E4%BA%9B%E5%B0%8F%E9%97%AE%E9%A2%98/20181015222342177.png" srcset="/img/loading.gif" class="" title="在这里插入图片描述"><br>回去 仔细看/etc/mysql/my.cnf<br>我去!!!<br><img src="/2018/10/15/%E4%BD%BF%E7%94%A8%E9%98%BF%E9%87%8C%E4%BA%91ECS%E5%AE%89%E8%A3%85mysql%E5%8F%8A%E8%BF%9C%E7%A8%8B%E7%99%BB%E5%BD%95%E7%9A%84%E4%B8%80%E4%BA%9B%E5%B0%8F%E9%97%AE%E9%A2%98/20181015222729516.png" srcset="/img/loading.gif" class="" title="在这里插入图片描述"><br>emm他的意思是说配置文件在那俩目录下…果然在操作的时候还是要仔细看下的- -<br>两个我都进去看了下 结果是在</p><pre><code class="hljs shell">vim  /etc/mysql/mysql.conf.d/mysqld.cnf</code></pre><p>找到bind-address改为0.0.0.0(任意ip可访问),也可以设成自己的,在第一次那个文件里我还好奇咋没有bind-address,虎得我直接加了一行上去…</p><img src="/2018/10/15/%E4%BD%BF%E7%94%A8%E9%98%BF%E9%87%8C%E4%BA%91ECS%E5%AE%89%E8%A3%85mysql%E5%8F%8A%E8%BF%9C%E7%A8%8B%E7%99%BB%E5%BD%95%E7%9A%84%E4%B8%80%E4%BA%9B%E5%B0%8F%E9%97%AE%E9%A2%98/20181015223338455.png" srcset="/img/loading.gif" class="" title="在这里插入图片描述"><p>重启服务  /etc/init.d/mysql restart  ,ok<br>Navicat连接测试成功</p><p><img src="使用阿里云ECS安装mysql及远程登录的一些小问题/20181015224839569.png" srcset="/img/loading.gif" alt="在这里插入图片描述" style="zoom:50%;" /></p><p><strong>重要</strong><br>netstat -anp|grep 3306<br>查看3306端口有没有开启,没有的话去阿里云那添加安全规则,不细写了</p>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Mysql</tag>
      
      <tag>Bug</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>requests模拟登录（基础向）以及打印成pdf时使用pdfkit时出现的一些问题</title>
    <link href="/2018/10/13/requests%E6%A8%A1%E6%8B%9F%E7%99%BB%E5%BD%95%EF%BC%88%E5%9F%BA%E7%A1%80%E5%90%91%EF%BC%89%E4%BB%A5%E5%8F%8A%E6%89%93%E5%8D%B0%E6%88%90pdf%E6%97%B6%E4%BD%BF%E7%94%A8pdfkit%E6%97%B6%E5%87%BA%E7%8E%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98/"/>
    <url>/2018/10/13/requests%E6%A8%A1%E6%8B%9F%E7%99%BB%E5%BD%95%EF%BC%88%E5%9F%BA%E7%A1%80%E5%90%91%EF%BC%89%E4%BB%A5%E5%8F%8A%E6%89%93%E5%8D%B0%E6%88%90pdf%E6%97%B6%E4%BD%BF%E7%94%A8pdfkit%E6%97%B6%E5%87%BA%E7%8E%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p>需求时这样的：学校有一个判题网，当期末的时候要把提交的结果一页一页的打印成pdf交给老师<br>因为是内网，模拟登录十分简单我就简单写一下，但是我在使用pdfkit时出现了一些问题（强迫症问题），最终也没找到很好的解决方法，如果有dalao有想法恳请告诉 - -！</p><h2 id="环境："><a href="#环境：" class="headerlink" title="环境："></a>环境：</h2><p>python3.6<br><strong>涉及的库:</strong><br>requests<br>pdfkit<br>re<br><strong>1.模拟登录</strong><br><img src="/2018/10/13/requests%E6%A8%A1%E6%8B%9F%E7%99%BB%E5%BD%95%EF%BC%88%E5%9F%BA%E7%A1%80%E5%90%91%EF%BC%89%E4%BB%A5%E5%8F%8A%E6%89%93%E5%8D%B0%E6%88%90pdf%E6%97%B6%E4%BD%BF%E7%94%A8pdfkit%E6%97%B6%E5%87%BA%E7%8E%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98/20181013013638153.png" srcset="/img/loading.gif" class="" title="在这里插入图片描述"><br>登录的url如上 我们关注hearder里最后几个就行，先构造出来header</p><pre><code class="hljs plain">header&#x3D;&#123;&#39;uer-aGent&#39;:&#39;Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64; rv:61.0) Gecko&#x2F;20100101 Firefox&#x2F;61.0&#39;,&#39;Referer&#39;:&#39;http:&#x2F;&#x2F;**.***.***.***&#x2F;&#39;,&#39;Host&#39;:&#39;**.***.***.***&#39;&#125;</code></pre><img src="/2018/10/13/requests%E6%A8%A1%E6%8B%9F%E7%99%BB%E5%BD%95%EF%BC%88%E5%9F%BA%E7%A1%80%E5%90%91%EF%BC%89%E4%BB%A5%E5%8F%8A%E6%89%93%E5%8D%B0%E6%88%90pdf%E6%97%B6%E4%BD%BF%E7%94%A8pdfkit%E6%97%B6%E5%87%BA%E7%8E%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98/20181013014502706.png" srcset="/img/loading.gif" class="" title="在这里插入图片描述"><p>这是需要post的参数，第一个参数csrfmid…啥的我们发现就是cookie中的一个</p><p>接下来我们来讲讲如何获取cookie，因为是学生自己用的，验证很low，我们先通过requests.Session（）获得一个session（这里不懂的强烈建议先去搞懂Session和Cookie），我们先通过session.get（）先尝试登录一下，因为我们没有提交任何表单数据，毫无疑问是失败的，但是我们却因此获得了cookie，具体看代码，十分简单<br><pre><code class="hljs python"><span class="hljs-keyword">import</span> requests<span class="hljs-keyword">import</span> re<span class="hljs-keyword">import</span> time<span class="hljs-keyword">import</span> pdfkitpostdata=&#123;<span class="hljs-string">'password'</span>:<span class="hljs-string">'******'</span>,<span class="hljs-string">'username'</span>:<span class="hljs-string">'*******'</span>&#125;session = requests.Session()<span class="hljs-comment">#登录</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">Getcookiesandlogin</span><span class="hljs-params">()</span>:</span>    posturl = <span class="hljs-string">'http://**.***.***.***/user/logincheck/'</span>    session.get(<span class="hljs-string">'http://**.***.***.***/'</span>,headers=header)<span class="hljs-comment">#通过这次来获取cookie</span>    postdata[<span class="hljs-string">'csrfmiddlewaretoken'</span>]=session.cookies.get_dict()[<span class="hljs-string">'csrftoken'</span>]<span class="hljs-comment">#把cookie加入表单参数中</span>    session.post(posturl, data=postdata,headers=header)</code></pre><br><strong>2.pdfkit</strong><br>pdfkit依赖于<a href="https://wkhtmltopdf.org/downloads.html" target="_blank" rel="noopener">wkhtmltopdf</a>，链接为下载地址，我下的是windos的MXE (MinGW-w64)，直接解压就行，使用的时候设置一下路径参数就ok<br><pre><code class="hljs python">path=<span class="hljs-string">'E:/wkhtmltopdf/wkhtmltox/bin/wkhtmltopdf.exe'</span><span class="hljs-comment">#你解压后的路径</span>config = pdfkit.configuration(wkhtmltopdf=path)</code></pre></p><p>先说最后都没有解决的问题吧，看两幅图片的对比<br>1.<br><img src="/2018/10/13/requests%E6%A8%A1%E6%8B%9F%E7%99%BB%E5%BD%95%EF%BC%88%E5%9F%BA%E7%A1%80%E5%90%91%EF%BC%89%E4%BB%A5%E5%8F%8A%E6%89%93%E5%8D%B0%E6%88%90pdf%E6%97%B6%E4%BD%BF%E7%94%A8pdfkit%E6%97%B6%E5%87%BA%E7%8E%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98/20181013021751279.png" srcset="/img/loading.gif" class="" title="在这里插入图片描述"><br>2.<img src="/2018/10/13/requests%E6%A8%A1%E6%8B%9F%E7%99%BB%E5%BD%95%EF%BC%88%E5%9F%BA%E7%A1%80%E5%90%91%EF%BC%89%E4%BB%A5%E5%8F%8A%E6%89%93%E5%8D%B0%E6%88%90pdf%E6%97%B6%E4%BD%BF%E7%94%A8pdfkit%E6%97%B6%E5%87%BA%E7%8E%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98/20181013015556342.png" srcset="/img/loading.gif" class="" title="在这里插入图片描述"><br>emmm，就是空白（红框圈出），打印pdf的时候会出现空白，而且这些空白是有些pdf有，有些pdf没有的，而这些空白也不仅仅是出现在页与页的分隔之间。。。<br><em>只截取关于pdfkit的一段代码吧（这是最后的）</em></p><pre><code class="hljs python">text=session.get(url)css=[<span class="hljs-string">'E:\Pycharm\MyProjects\monidenglupanti\css\shCore.css'</span>,<span class="hljs-string">'E:\Pycharm\MyProjects\monidenglupanti\css\shThemeDefault.css'</span>,     <span class="hljs-string">'E:\Pycharm\MyProjects\monidenglupanti\css\global.css'</span>,<span class="hljs-string">'E:\Pycharm\MyProjects\monidenglupanti\css\group.css'</span>,     <span class="hljs-string">'E:\Pycharm\MyProjects\monidenglupanti\css\printstyle.css'</span>]name=re.findall(<span class="hljs-string">r'&lt;title&gt;(.*) &lt;/title&gt;'</span>,text.text)[<span class="hljs-number">0</span>].replace(<span class="hljs-string">' '</span>,<span class="hljs-string">''</span>)name=name.replace(<span class="hljs-string">':'</span>,<span class="hljs-string">'_'</span>)path=<span class="hljs-string">'E:/Pycharm/MyProjects/monidenglupanti/'</span>+name+<span class="hljs-string">'.pdf'</span>h=text.text.replace(<span class="hljs-string">'/js/media/js/scripts/'</span>,<span class="hljs-string">'js/'</span>)h = text.text.replace(<span class="hljs-string">'/js/media/js/'</span>, <span class="hljs-string">'js/'</span>)<span class="hljs-comment">#这里外链的路径变成‘C:\Users\76083\AppData\Local\Temp\’，改成其他路径失效，没解决- -！</span>pdfkit.from_string(h,output_path=path,configuration=config,css=css)</code></pre><p>苦逼历程：<br>1.一开始，发现打印的pdf没有样式，好，把网页的样式下载下来，添加进去，<br>后来发现，打印出来的pdf还是有些小地方不一样，想破脑袋，此处省略万字。。。<br>2.突然想到有些应该是javascript动态生成的！好，咱再把他也全部下载下来<br>（下载方法：Internet选项-常规-先点删除-选择临时文件(全清了也ok就当清理垃圾了)-删除后刷新一下你要下载的网页-再点设置-再点查看文件，好，里面就全是这个网站的css和js文件了）。<br>3.然后加载javascritpt，把网页中js的相对路径改成我需要的觉得路径，发现又发现设置其他盘无用（它还是会ignore）只能设置在‘C:\Users\76083\AppData\Local\Temp\’？？？算了，屈服<br>4.满心欢心运行效果，样式啥的全对了，看到空白，强迫症卒</p>]]></content>
    
    
    <categories>
      
      <category>python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>爬虫</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>12306余票及票价查询</title>
    <link href="/2018/10/09/%E4%BD%99%E7%A5%A8%E5%8F%8A%E7%A5%A8%E4%BB%B7%E6%9F%A5%E8%AF%A2/"/>
    <url>/2018/10/09/%E4%BD%99%E7%A5%A8%E5%8F%8A%E7%A5%A8%E4%BB%B7%E6%9F%A5%E8%AF%A2/</url>
    
    <content type="html"><![CDATA[<p>还原整个思路，遇到的一些问题也会写出来，纯新手向，因为打包在了一个类里，所以单独拷贝一个函数可能会有些问题,后面有完整代码地址，如有错误可以指正- -有问题也可以留言，后面写的有些赶，可以去完整源代码中看看<br>截至2018/10/9   0:15代码还是有效的</p><h2 id="环境："><a href="#环境：" class="headerlink" title="环境："></a>环境：</h2><p>python3.6<br><strong>涉及的库:</strong><br>requests<br>json<br>prettytable<br>re<br>pprint<br><strong>1.url分析</strong><br>    先打开<a href="https://kyfw.12306.cn/otn/leftTicket/init" target="_blank" rel="noopener">12306的余票查询</a>，我用的是火狐浏览器，按F12打开调试工具选择network（网络）选项，选择出发地，目的地，日期，点击查询<br>    <img src="/2018/10/09/%E4%BD%99%E7%A5%A8%E5%8F%8A%E7%A5%A8%E4%BB%B7%E6%9F%A5%E8%AF%A2/20181008211309564.png" srcset="/img/loading.gif" class="" title="在这里插入图片描述"><br>（小白问题：调试窗口里啥也没有是因为 你一番操作猛如虎，结果完事后想起：哎？调试窗口没打开！）<br>右上角有一排选项，咱选js，xhr 然后从这一条条里找出我们需要的链接（点的时候在右边选择响应，可以看到这条请求返回啥）哇塞！你找到一串data，里面还有各种车票的信息，好了，就是你了：<br><a href="https://kyfw.12306.cn/otn/leftTicket/queryA?leftTicketDTO.train_date=2018-10-23&amp;leftTicketDTO.from_station=HZH&amp;leftTicketDTO.to_station=RZH&amp;purpose_codes=ADULT" target="_blank" rel="noopener">https://kyfw.12306.cn/otn/leftTicket/queryA?leftTicketDTO.train_date=2018-10-23&amp;leftTicketDTO.from_station=HZH&amp;leftTicketDTO.to_station=RZH&amp;purpose_codes=ADULT</a><br><img src="/2018/10/09/%E4%BD%99%E7%A5%A8%E5%8F%8A%E7%A5%A8%E4%BB%B7%E6%9F%A5%E8%AF%A2/20181008212636116.png" srcset="/img/loading.gif" class="" title="在这里插入图片描述"><br><strong>PS</strong>：找json链接这种活就看经验了，老手可能马上就能找到，新手可能就要一条条点（汗~~）我这给一个快速的方法：进入余票查询界面，选择好出发地和目的地及日期，点击查询，好！然后再打开F12调试界面在点查询！哇塞只有1条而且就是我们需要的！（深入原因的话就是在你打开了调试界面后你只进行了这一条查询的post请求，而返回的当然就是你要的了）<br><img src="/2018/10/09/%E4%BD%99%E7%A5%A8%E5%8F%8A%E7%A5%A8%E4%BB%B7%E6%9F%A5%E8%AF%A2/20181008213803841.png" srcset="/img/loading.gif" class="" title="在这里插入图片描述"><br>好,继续正题,我们来观察这条json的链接,很容易明白那些参数吧,如下:<br><a href="https://kyfw.12306.cn/otn/leftTicket/queryA?leftTicketDTO.train_date=2018-10-23&amp;leftTicketDTO.from_station=HZH&amp;leftTicketDTO.to_station=RZH&amp;purpose_codes=ADULT" target="_blank" rel="noopener">https://kyfw.12306.cn/otn/leftTicket/queryA?leftTicketDTO.train_date=2018-10-23&amp;leftTicketDTO.from_station=HZH&amp;leftTicketDTO.to_station=RZH&amp;purpose_codes=ADULT</a><br>leftTicketDTO.train_date=日期<br>leftTicketDTO.from_station=出发点的地点码<br>leftTicketDTO.to_station=目的地的地点码<br>purpose_codes=票的种类<br><strong>2.获取车站对照字典</strong><br>上文链接中有两个参数是地点码,即一个地名对应一个值,一开始我是直接下载了网上(baidu喽)的一个字典,然后最后写完.不对!我靠!而且调试半天定位到字典错了!(这么多的地名偏偏被窝测试到错误的也是没谁了…）<br><img src="/2018/10/09/%E4%BD%99%E7%A5%A8%E5%8F%8A%E7%A5%A8%E4%BB%B7%E6%9F%A5%E8%AF%A2/20181008220408892.png" srcset="/img/loading.gif" class="" title="在这里插入图片描述"><br>好!自己动手!</p><pre><code class="hljs python"><span class="hljs-keyword">import</span> requests<span class="hljs-keyword">import</span> re<span class="hljs-comment">#生成字典 运行一次后抛弃之~~~</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">new_dictionary</span><span class="hljs-params">()</span>:</span>    url=<span class="hljs-string">"https://kyfw.12306.cn/otn/resources/js/framework/station_name.js?station_version=1.9069"</span>    station_namesweb=requests.get(url)    stationdic = re.findall(<span class="hljs-string">r'([\u4e00-\u9fa5]+)\|([a-zA-Z]+)'</span>, station_namesweb.text)    stationdic=dict(stationdic)    print(stationdic)new_dictionary()</code></pre><p>requests请求,json打包,正则提取,over!<br>打印出一个字典复制然后在一个文件里就ok了(上面代码中的url其实也是一样找的,可以试试手去找找看)哈哈,其实这也是今天整个工程的浓缩版吧,思路也是差不多的<br><strong>3.输入出发点,目的地,时间,获得需要的查询链接</strong><br>废多看码!!!</p><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">getUrl</span><span class="hljs-params">(self)</span>:</span>    startflag = <span class="hljs-literal">False</span>    endflag = <span class="hljs-literal">False</span>    <span class="hljs-keyword">while</span> startflag == <span class="hljs-literal">False</span>:        start = input(<span class="hljs-string">"请输入始发地：\n"</span>)        startflag = stations.__contains__(start)        <span class="hljs-keyword">if</span> startflag == <span class="hljs-literal">False</span>:            print(<span class="hljs-string">'始发地输入错误！'</span>)    <span class="hljs-keyword">while</span> endflag == <span class="hljs-literal">False</span>:        end = input(<span class="hljs-string">"请输入目的地：\n"</span>)        endflag = stations.__contains__(end)        <span class="hljs-keyword">if</span> endflag == <span class="hljs-literal">False</span>:            print(<span class="hljs-string">'目的地输入错误！'</span>)    self.date = input(<span class="hljs-string">"请输入日期(格式为xxxx-xx-xx)：\n"</span>)    url = <span class="hljs-string">'https://kyfw.12306.cn/otn/leftTicket/queryA?leftTicketDTO.train_date='</span> \          + self.date + <span class="hljs-string">'&amp;leftTicketDTO.from_station='</span> \          + stations[start] + <span class="hljs-string">'&amp;leftTicketDTO.to_station='</span> \          + stations[end] + <span class="hljs-string">'&amp;purpose_codes=ADULT'</span>    <span class="hljs-keyword">return</span> url</code></pre><p><strong>4.获取车辆信息</strong><br>因为12306在这里没做啥验证所以可以直接请求,不妨直接在浏览器里看一下,emmm是不是头都大了!!!!<br><img src="/2018/10/09/%E4%BD%99%E7%A5%A8%E5%8F%8A%E7%A5%A8%E4%BB%B7%E6%9F%A5%E8%AF%A2/20181008233255654.png" srcset="/img/loading.gif" class="" title="在这里插入图片描述"><br>车辆的信息都在这里了,用|分隔开,我们要做的就是从里面提取出我们想要的信息,emmm其实我花的时间最多的是在这里,因为要一一对应知道每个信息代表什么,而我又找不到那么一辆每个信息都齐全的车来让我对照…只能用好几辆的信息来对比喽（还不一定是对的，眼力有限）…我的眼睛!!!<br><img src="/2018/10/09/%E4%BD%99%E7%A5%A8%E5%8F%8A%E7%A5%A8%E4%BB%B7%E6%9F%A5%E8%AF%A2/20181008234420942.png" srcset="/img/loading.gif" class="" title="在这里插入图片描述"></p><blockquote><p><code>乱码|预订|030000K5540E|K551|MDB|RZH|HZH|RZH|02:31|10:50|08:19|Y|乱码|20181021|3|B2|44|52|0|0||||无|||无||有|10|||||10401030|1413|0</code></p><p>上代码:<br><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">getData</span><span class="hljs-params">(self,url)</span>:</span>    dataweb = requests.get(url)    datajson = json.loads(dataweb.text)    datatrains = datajson[<span class="hljs-string">'data'</span>][<span class="hljs-string">'result'</span>]    restations=datajson[<span class="hljs-string">'data'</span>][<span class="hljs-string">'map'</span>]<span class="hljs-comment">#地点缩写：地点全称的字典</span>    dataans = []    <span class="hljs-keyword">for</span> train <span class="hljs-keyword">in</span> datatrains:        per = &#123;            <span class="hljs-string">'train_no'</span>: <span class="hljs-string">''</span>,            <span class="hljs-string">'from_station_no'</span>: <span class="hljs-string">''</span>,            <span class="hljs-string">'to_station_no'</span>: <span class="hljs-string">''</span>,            <span class="hljs-string">'seat_types'</span>: <span class="hljs-string">''</span>,            <span class="hljs-string">'chufazhan'</span>:<span class="hljs-string">''</span>,            <span class="hljs-string">'dadaozhan'</span>:<span class="hljs-string">''</span>,            <span class="hljs-string">'checi'</span>: <span class="hljs-string">''</span>,            <span class="hljs-string">'chufasj'</span>: <span class="hljs-string">''</span>,            <span class="hljs-string">'didasj'</span>: <span class="hljs-string">''</span>,            <span class="hljs-string">'lishi'</span>: <span class="hljs-string">''</span>,            <span class="hljs-string">'erdeng'</span>: <span class="hljs-string">''</span>,            <span class="hljs-string">'yideng'</span>: <span class="hljs-string">''</span>,            <span class="hljs-string">'shangwu'</span>: <span class="hljs-string">''</span>,            <span class="hljs-string">'wuzuo'</span>:<span class="hljs-string">''</span>        &#125;        train = train.split(<span class="hljs-string">'|'</span>)        per[<span class="hljs-string">'train_no'</span>] = train[<span class="hljs-number">2</span>]        per[<span class="hljs-string">'from_station_no'</span>] = train[<span class="hljs-number">16</span>]        per[<span class="hljs-string">'to_station_no'</span>] = train[<span class="hljs-number">17</span>]        per[<span class="hljs-string">'seat_types'</span>] = train[<span class="hljs-number">35</span>]        per[<span class="hljs-string">'chufazhan'</span>]=train[<span class="hljs-number">6</span>]        per[<span class="hljs-string">'dadaozhan'</span>]=train[<span class="hljs-number">7</span>]        <span class="hljs-comment">#将得到站点名字由缩写转换全称</span>        per[<span class="hljs-string">'chufazhan'</span>]=restations[per[<span class="hljs-string">'chufazhan'</span>]]        per[<span class="hljs-string">'dadaozhan'</span>]=restations[per[<span class="hljs-string">'dadaozhan'</span>]]        per[<span class="hljs-string">'checi'</span>] = train[<span class="hljs-number">3</span>]        per[<span class="hljs-string">'chufasj'</span>] = train[<span class="hljs-number">8</span>]        per[<span class="hljs-string">'didasj'</span>] = train[<span class="hljs-number">9</span>]        per[<span class="hljs-string">'lishi'</span>] = train[<span class="hljs-number">10</span>]        per[<span class="hljs-string">'erdeng'</span>] = train[<span class="hljs-number">30</span>]        per[<span class="hljs-string">'yideng'</span>] = train[<span class="hljs-number">31</span>]        per[<span class="hljs-string">'shangwu'</span>] = train[<span class="hljs-number">32</span>]        per[<span class="hljs-string">'wuzuo'</span>]=train[<span class="hljs-number">26</span>]        <span class="hljs-keyword">for</span> value <span class="hljs-keyword">in</span> per:            <span class="hljs-keyword">if</span> (per[value] == <span class="hljs-string">''</span>):                per[value] = <span class="hljs-string">'-'</span>        dataans.append(per)    <span class="hljs-keyword">return</span> dataans</code></pre><br>PS：这里有个问题要说明下：比如我朋友温州-金华，而金华有两个站，他只要其中一个站的，所以我们得显示出出发站和抵达站到底是哪个，但是在信息中我们获得地点是一个码而不是一个站的名字，而我们的字典中是 {名字：码}，一开始我想要不干脆再做个反转的字典，后来往上翻的时候发现：原来上面已经给我们了！解决！计划通~<br><img src="/2018/10/09/%E4%BD%99%E7%A5%A8%E5%8F%8A%E7%A5%A8%E4%BB%B7%E6%9F%A5%E8%AF%A2/20181009004354618.png" srcset="/img/loading.gif" class="" title="在这里插入图片描述"><br><strong>5.获取票价信息</strong><br>票价的url是另外一条了,获取方式同上上,老方法请求,解析,打包<br><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">GetPrice</span><span class="hljs-params">(self,train_no,from_station_no,to_station_no,seat_types,date,price)</span>:</span>    url = <span class="hljs-string">'https://kyfw.12306.cn/otn/leftTicket/queryTicketPrice?train_no='</span> \          + train_no + <span class="hljs-string">'&amp;from_station_no='</span> \          + from_station_no + <span class="hljs-string">'&amp;to_station_no='</span> \          + to_station_no + <span class="hljs-string">'&amp;seat_types='</span> \          + seat_types + <span class="hljs-string">'&amp;train_date='</span> + date    priceweb=requests.get(url)    pricejson=json.loads(priceweb.text)    pricedata=pricejson[<span class="hljs-string">'data'</span>]    shangwu=pricedata.__contains__(<span class="hljs-string">'A9'</span>)<span class="hljs-comment">#商务</span>    yideng=pricedata.__contains__(<span class="hljs-string">'M'</span>)<span class="hljs-comment">#一等</span>    erdeng=pricedata.__contains__(<span class="hljs-string">'O'</span>)<span class="hljs-comment">#二等</span>    wuzuo=pricedata.__contains__(<span class="hljs-string">'WZ'</span>)<span class="hljs-comment">#无座</span>    <span class="hljs-keyword">if</span> shangwu:        price[<span class="hljs-string">'shangwu'</span>]=pricedata[<span class="hljs-string">'A9'</span>]    <span class="hljs-keyword">else</span> :        price[<span class="hljs-string">'shangwu'</span>]=<span class="hljs-string">''</span>    <span class="hljs-keyword">if</span> yideng:        price[<span class="hljs-string">'yideng'</span>]=pricedata[<span class="hljs-string">'M'</span>]    <span class="hljs-keyword">else</span> :        price[<span class="hljs-string">'yideng'</span>]=<span class="hljs-string">''</span>    <span class="hljs-keyword">if</span> erdeng:        price[<span class="hljs-string">'erdeng'</span>]=pricedata[<span class="hljs-string">'O'</span>]    <span class="hljs-keyword">else</span> :        price[<span class="hljs-string">'erdeng'</span>]=<span class="hljs-string">''</span>    <span class="hljs-keyword">if</span> wuzuo:        price[<span class="hljs-string">'wuzuo'</span>]=pricedata[<span class="hljs-string">'WZ'</span>]    <span class="hljs-keyword">else</span> :        price[<span class="hljs-string">'wuzuo'</span>]=<span class="hljs-string">''</span>    <span class="hljs-keyword">return</span> price</code></pre><br><strong>6.输出</strong><br>用了prettytable库输出表格<br><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">Print</span><span class="hljs-params">(self)</span>:</span>    price=&#123;        <span class="hljs-string">'shangwu'</span>:<span class="hljs-string">''</span>,        <span class="hljs-string">'yideng'</span>:<span class="hljs-string">''</span>,        <span class="hljs-string">'erdeng'</span>:<span class="hljs-string">''</span>,        <span class="hljs-string">'wuzuo'</span>:<span class="hljs-string">''</span>,    &#125;    table = prettytable.PrettyTable()    table.field_names = [<span class="hljs-string">"车次"</span>,<span class="hljs-string">"出发站"</span>,<span class="hljs-string">"达到站"</span> ,<span class="hljs-string">"出发时间"</span>, <span class="hljs-string">"抵达时间"</span>, <span class="hljs-string">"历时"</span>, <span class="hljs-string">"二等座"</span>, <span class="hljs-string">"一等座"</span>, <span class="hljs-string">"商务座"</span>,<span class="hljs-string">"无座"</span>]    <span class="hljs-keyword">for</span> per <span class="hljs-keyword">in</span> self.data:        price=self.GetPrice(per[<span class="hljs-string">'train_no'</span>],per[<span class="hljs-string">'from_station_no'</span>],per[<span class="hljs-string">'to_station_no'</span>],per[<span class="hljs-string">'seat_types'</span>],self.date,price)        table.add_row([per[<span class="hljs-string">'checi'</span>],per[<span class="hljs-string">'chufazhan'</span>],per[<span class="hljs-string">'dadaozhan'</span>], per[<span class="hljs-string">'chufasj'</span>], per[<span class="hljs-string">'didasj'</span>], per[<span class="hljs-string">'lishi'</span>], per[<span class="hljs-string">'erdeng'</span>]+<span class="hljs-string">'\n'</span>+price[<span class="hljs-string">'erdeng'</span>], per[<span class="hljs-string">'yideng'</span>]+<span class="hljs-string">'\n'</span>+price[<span class="hljs-string">'yideng'</span>],                       per[<span class="hljs-string">'shangwu'</span>]+<span class="hljs-string">'\n'</span>+price[<span class="hljs-string">'shangwu'</span>],per[<span class="hljs-string">'wuzuo'</span>]+<span class="hljs-string">'\n'</span>+price[<span class="hljs-string">'wuzuo'</span>]])    print(table)</code></pre><br><strong>7.演示</strong><br><img src="/2018/10/09/%E4%BD%99%E7%A5%A8%E5%8F%8A%E7%A5%A8%E4%BB%B7%E6%9F%A5%E8%AF%A2/20181008235639135.png" srcset="/img/loading.gif" class="" title="在这里插入图片描述"><br>8.完整代码<br><a href="https://github.com/senjay/12306tickets_and_price_search" target="_blank" rel="noopener">https://github.com/senjay/12306tickets_and_price_search</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>爬虫</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
