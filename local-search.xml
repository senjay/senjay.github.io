<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Practical 3D Frame Field Generation-3D</title>
    <link href="/2020/09/17/2020-09-17-Practical-3D-Frame-Field-Generation-3D/"/>
    <url>/2020/09/17/2020-09-17-Practical-3D-Frame-Field-Generation-3D/</url>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;作者在前文的2d形式下引入的基函数其实是傅里叶基底，而在3d下，根据《Boundary aligned smooth 3D cross-frame field》的启发，使用了球谐函数作为基函数。不同的是该文使用了不同的多项式<script type="math/tex">x^4+y^4+z^4</script>来在球上展开。（而前文是<script type="math/tex">x^2y^2+y^2z^2+z^2x^2</script>，其实优化后式子是一样的）</p><h3 id="二、3D"><a href="#二、3D" class="headerlink" title="二、3D"></a>二、3D</h3><h4 id="1-标架表示"><a href="#1-标架表示" class="headerlink" title="1. 标架表示"></a>1. 标架表示</h4><p>&emsp;&emsp;如果<script type="math/tex">\tilde{F}</script>为参考标架函数，那么它为：</p><script type="math/tex; mode=display">\begin{aligned}\tilde{F}&=\sqrt{\frac{7}{12}}Y_{4}^{0}+\sqrt{\frac{5}{12}}Y_{4}^{4}\\&=B\tilde{a}\\&=\left(Y_{4}^{-4},Y_{4}^{-3},Y_{4}^{-2},Y_{4}^{-1}, Y_{4}^{0}, Y_{4}^{1},Y_{4}^{2},Y_{4}^{3}, Y_{4}^{4}\right)\left(0,0,0,0, \sqrt{\frac{7}{12}}, 0,0,0, \sqrt{\frac{5}{12}}\right)^{\top}\end{aligned}</script><p>其中<script type="math/tex">Y_{l}^{m}</script>是实球谐基函数，其中<script type="math/tex">l</script>称为degree/band,<script type="math/tex">m</script>称为order，<script type="math/tex">m\in[-l,l]</script>。</p><p>（球谐函数在图形学中先是被用于光照渲染《<em>Spherical harmonic lighting: The gritty details</em>》，<a href="https://zhuanlan.zhihu.com/p/51179426" target="_blank" rel="noopener">一个通俗的介绍球谐函数的系列文章</a>）</p><p>ps:为什么选择球谐函数？因为它具有以下性质：</p><ul><li><p>标准正交性，它是一组正交基</p></li><li><p>旋转不变性，比如用矩阵<script type="math/tex">R</script>旋转<script type="math/tex">f(x)</script>后变为<script type="math/tex">g(x)</script>,即<script type="math/tex">g(x)=Rf(x)</script>,根据旋转不变性有<script type="math/tex">g(x)=f(Rx)</script></p></li><li><p><strong>函数乘积的积分等于其球谐系数向量的点积</strong>，<script type="math/tex">\int_{S} L(s) t(s) d s=\sum_{i=0}^{\infty} L_{i} t_{i}</script></p></li></ul><p>由旋转不变性，任意标架可表示为<script type="math/tex">F=BR\tilde{a}</script>，其中<script type="math/tex">R</script>是<script type="math/tex">9\times 9</script>旋转矩阵，可由Wigner D-matrices  给出。</p><h4 id="2-能量函数"><a href="#2-能量函数" class="headerlink" title="2. 能量函数"></a>2. 能量函数</h4><script type="math/tex; mode=display">E=\sum_{i j} \int_{S^{2}}\left(F^{j}(\alpha)-F^{i}(\alpha)\right)^{2} d \alpha=\sum_{i j}\left\|a^{j}-a^{i}\right\|^{2}</script><p>相比于2d,3d中的能量函数其实是类似的，不同的是<script type="math/tex">a</script>，不再相同，因为引入了球谐函数作为基函数。可以注意到<script type="math/tex">a</script>是一个九维向量，而我们要得到的是一个三维向量（即<script type="math/tex">a</script>是一个嵌入到九维空间的三维流形），所以后面还需要用其他方法求解其投影在三维中对应的向量，文章中赋予了一个随机初值并使用梯度下降来求解（We do not have a formal proof, but we conjecture that there is a single minimum of the L2 norm ）</p><h4 id="3-约束"><a href="#3-约束" class="headerlink" title="3. 约束"></a>3. 约束</h4><p>&emsp;&emsp;一些顶点上的标架需要满足约束条件，如下</p><h5 id="3-1法向量对齐z轴"><a href="#3-1法向量对齐z轴" class="headerlink" title="3.1法向量对齐z轴"></a>3.1法向量对齐z轴</h5><p>&emsp;&emsp;根据<script type="math/tex">a=R_z\tilde{a}</script>可得到</p><script type="math/tex; mode=display">a=\left(\sqrt{\frac{5}{12}} \sin 4 \theta, 0,0,0, \sqrt{\frac{7}{12}}, 0,0,0, \sqrt{\frac{5}{12}} \cos 4 \theta\right)^{\top}</script><p>其中<script type="math/tex">R_z</script>是绕z轴的旋转矩阵。引入向量<script type="math/tex">c=(c_0,c_1)</script>,可写成以下形式</p><script type="math/tex; mode=display">\begin{aligned}a &=\sqrt{\frac{7}{12}}(0,0,0,0,1,0,0,0,0)^{\top} \\&+c_{0}(0,0,0,0,0,0,0,0,1)^{\top} \\&+c_{1}(1,0,0,0,0,0,0,0,0)^{\top}\end{aligned}</script><p>其中<script type="math/tex">cc^{\top}=\frac{5}{12}</script></p><h5 id="3-2法向量不与z轴对齐"><a href="#3-2法向量不与z轴对齐" class="headerlink" title="3.2法向量不与z轴对齐"></a>3.2法向量不与z轴对齐</h5><p>&emsp;&emsp;策略是先将z轴转到法向量方向，即乘一个旋转矩阵<script type="math/tex">R</script>，则<script type="math/tex">a</script>变成以下形式</p><script type="math/tex; mode=display">\begin{aligned}a &=\sqrt{\frac{7}{12}}R(0,0,0,0,1,0,0,0,0)^{\top} \\& +c_{0}R(0,0,0,0,0,0,0,0,1)^{\top} \\& +c_{1}R(1,0,0,0,0,0,0,0,0)^{\top}\\\end{aligned}</script><h5 id="3-3尖锐、角点"><a href="#3-3尖锐、角点" class="headerlink" title="3.3尖锐、角点"></a>3.3尖锐、角点</h5><p>&emsp;&emsp;该类顶点上的标架需要符合两个法向量，选择两个大致正交的法向量作为它的特征，然后通过旋转让它们正交，然后将z轴转到它们的叉积方向，方法同3.2</p><h5 id="3-4-旋转矩阵"><a href="#3-4-旋转矩阵" class="headerlink" title="3.4 旋转矩阵"></a>3.4 旋转矩阵</h5><p>&emsp;&emsp;旋转矩阵为9x9矩阵，为Wigner D-matrices </p><script type="math/tex; mode=display">\begin{aligned}&R_{B}^{z}(\gamma)=\left[\begin{array}{ccccccccc}\cos (4 \gamma) & 0 & 0 & 0 & 0 & 0 & 0 & 0 & \sin (4 \gamma) \\0 & \cos (3 \gamma) & 0 & 0 & 0 & 0 & 0 & \sin (3 \gamma) & 0 \\0 & 0 & \cos (2 \gamma) & 0 & 0 & 0 & \sin (2 \gamma) & 0 & 0 \\0 & 0 & 0 & \cos (\gamma) & 0 & \sin (\gamma) & 0 & 0 & 0 \\0 & 0 & 0 &0 & 1 & 0 & 0 & 0 & 0 \\0 & 0 & 0 &  -\sin (\gamma) & 0 & \cos ( \gamma) & 0 & 0 & 0 & 0 \\0 & 0 & -\sin (2 \gamma) & 0 & 0 & 0 & \cos (2 \gamma) & 0 & 0 & 0 \\0 & -\sin (3 \gamma) & 0 & 0 & 0 & 0 & 0 & \cos (3 \gamma) & 0 \\-\sin (4 \gamma) & 0 & 0 & 0 & 0 & 0 & 0 & 0 & \cos (4 \gamma)\end{array}\right]\end{aligned}</script><script type="math/tex; mode=display">\begin{aligned}&R_{B}^{x}(\pi / 2)=\left[\begin{array}{cccccccc}0 & 0 & 0 & 0 & 0 & \sqrt{14} / 4 & 0 & -\sqrt{2} / 4 & 0 \\0 & -3 / 4 & 0 & \sqrt{7} / 4 & 0 & 0 & 0 & 0 & 0 \\0 & 0 & 0 & 0 & 0 & \sqrt{2} / 4 & 0 & \sqrt{14} / 4 & 0 \\0 & \sqrt{7} / 4 & 0 & 3 / 4 & 0 & 0 & 0 & 0 & 0 \\0 & 0 & 0 & 0 & 3 / 8 & 0 & \sqrt{5} / 4 & 0 & \sqrt{35} / 8 \\-\sqrt{14} / 4 & 0 & -\sqrt{2} / 4 & 0 & 0 & 0 & 0 & 0 & 0 \\0 & 0 & 0 & 0 & \sqrt{5} / 4 & 0 & 1 / 2 & 0 & -\sqrt{7} / 4 \\\sqrt{2} / 4 & 0 & -\sqrt{14} / 4 & 0 & 0 & 0 & 0 & 0 & 0 \\0 & 0 & 0 & 0 & \sqrt{35} / 8 & 0 & -\sqrt{7} / 4 & 0 & 1 / 8\end{array}\right]\end{aligned}</script><script type="math/tex; mode=display">\begin{array}{l}R_{B}^{y}(\beta)=R_{B}^{x}(\pi / 2) \times R_{B}^{z}(\beta) \times R_{B}^{x}(\pi / 2)^{\top} \\R_{B}^{x}(\alpha)=R_{B}^{y}(\pi / 2)^{\top} \times R_{B}^{z}(\alpha) \times R_{B}^{y}(\pi / 2)\end{array}</script><p>则最终旋转矩阵为</p><script type="math/tex; mode=display">R_{B}(\alpha, \beta, \gamma)=R_{B}^{x}(\alpha) \times R_{B}^{y}(\beta) \times R_{B}^{z}(\gamma)</script><h4 id="4-矩阵化"><a href="#4-矩阵化" class="headerlink" title="4.矩阵化"></a>4.矩阵化</h4><p>&emsp;&emsp;求解采用最小二乘<script type="math/tex">||AX-b||</script>，其中标架<script type="math/tex">a^i</script>和约束<script type="math/tex">c^i</script>存储于<script type="math/tex">X</script>向量（<script type="math/tex">(9n_v+2n_l)</script>维，<script type="math/tex">n_v</script>为不带约束的顶点，<script type="math/tex">n_l</script>是带约束的顶点）</p><script type="math/tex; mode=display">X[9i+d]=a_d^i ,\quad \quad i \in[0,n_v],d \in [0,8]\\ X[9n_v+2i+d]=c_{d}^{i},\quad \quad i \in [0,n_l],d \in [0,1]\\</script><p>&emsp;&emsp;系数矩阵<script type="math/tex">A_{(9\mathcal{E}+9n_l)\times(9n_v+2n_l)}</script>（<script type="math/tex">\mathcal{E}</script>为边数）下标是行，上标是列，设置如下：</p><script type="math/tex; mode=display"></script><p>注意到上面的<script type="math/tex">A</script>还不完整，还需在下面加入一个描述约束的block(<script type="math/tex">9n_l\times(9n_v+2n_l)</script>)</p><p>&emsp;&emsp;对于有约束点，计算得到其将z轴旋转到法向方向的9x9旋转矩阵<script type="math/tex">R_B</script>,并定义如下值</p><script type="math/tex; mode=display">\begin{aligned}h_{0} & = R_{B} (1,0,0,0,0,0,0,0,0)^{\top} \\h_{4} & = R_{B} (0,0,0,0,1,0,0,0,0)^{\top} \\h_{8} &= R_{B} (0,0,0,0,0,0,0,0,1)^{\top}\\\lambda& =100\end{aligned}</script><p>其中<script type="math/tex">\lambda</script>是惩罚系数，则矩阵A剩余部分为</p><script type="math/tex; mode=display">A_{9n_l\times(9n_v+2n_l)}=\left\{\begin{aligned}&a_{i+d}^{9i+d}=\lambda,\quad a_{i+d}^{9n_v+2i}=\lambda h_0[d],\quad a_{i+d}^{9n_v+2i+1}=\lambda h_8[d] \ \ \ &&i\in \mathcal{n_l}, d \in[0,8]\\&0  &&other\end{aligned}\right.</script><script type="math/tex; mode=display">b$$为$$(9\mathcal{E}+9n_l)$$维向量，其前$$9\mathcal{E}$$维为$$0$$,后$$9n_l$$由约束决定，如下</script><p>b_{9\mathcal{E}+9n_l}=\left{<br>\begin{aligned}&amp;b_i=0  \quad &amp;&amp; i \in[0,9\mathcal{E})\<br>&amp;b_i=\lambda \sqrt{\frac{7}{12}}h_4[d]  &amp;&amp;i \in[9\mathcal{E},9\mathcal{E}+9n_l]<br>\end{aligned}<br>\right.</p><p><script type="math/tex">注意到</script>b<script type="math/tex">中的非零项中的</script>h_4<script type="math/tex">和</script>A<script type="math/tex">中的约束项一一对应的，即矩阵</script>A<script type="math/tex">和</script>b$$都是动态生成的，分成了两个block:表面约束点和自由点。另据作者的说法，在这两个block中做一个Hilbert sort会提升大约30%的效率。</p><p>&emsp;&emsp;至此，可通过求解<script type="math/tex">A^{\top}AX=A^{\top}X</script>得到位于顶点的嵌入到九维空间的标架表示（不再像2D中那样只需标准化就行了）。</p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>标架场</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Boundary Aligned Smooth 3D Cross-Frame Field</title>
    <link href="/2020/09/16/2020-09-16-Boundary-Aligned-Smooth-3D-Cross-Frame-Field/"/>
    <url>/2020/09/16/2020-09-16-Boundary-Aligned-Smooth-3D-Cross-Frame-Field/</url>
    
    <content type="html"><![CDATA[<h3 id="标架表示方法"><a href="#标架表示方法" class="headerlink" title="标架表示方法"></a>标架表示方法</h3><p>&emsp;&emsp;3d标架存在24个方向（坐标轴有6个选择，垂直它的有4种，即6x4=24种），为了表述两个相邻标架的差异，采用基函数来表示标架，而不是采用以前的使用vector pair来表示,该文首先提出了采用球谐函数作为基函数来描述标架。</p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>标架场</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Paper Introduction</title>
    <link href="/2020/09/16/2020-09-16-Paper-Introduction/"/>
    <url>/2020/09/16/2020-09-16-Paper-Introduction/</url>
    
    <content type="html"><![CDATA[<h3 id="1-标架场"><a href="#1-标架场" class="headerlink" title="1. 标架场"></a>1. 标架场</h3><h4 id="《Instant-field-aligned-meshes》-2015"><a href="#《Instant-field-aligned-meshes》-2015" class="headerlink" title="《Instant field-aligned meshes》-2015"></a>《Instant field-aligned meshes》-2015</h4><p>&emsp;&emsp;采用局部的高斯赛德尔迭代来求解表面网格的标架场和位置场，其在局部直接暴力比较（搜索空间其实很小，以4-Rosy为例，只有16）两个标架的不同来进行优化，并用<strong>多分辨率层次法（Multiresolution hierarchy）</strong>来避免陷入局部解，该方法<strong>速度快</strong>，<strong>鲁棒性好</strong>。<a href="https://senjay.github.io/2020/08/22/2020-08-22-Instant-Meshes-%E6%A0%87%E6%9E%B6%E5%9C%BA%E6%96%B9%E6%B3%95/" target="_blank" rel="noopener">笔记1</a>，<a href="https://senjay.github.io/2020/08/28/2020-02-22-Instant-Meshes-%E5%A5%87%E5%BC%82%E7%82%B9%E6%A3%80%E6%B5%8B/" target="_blank" rel="noopener">笔记2</a></p><p>Wenzel Jakob et al., “Instant Field-Aligned Meshes,” <em>ACM Transactions on Graphics</em> 34, no. 6 (November 4, 2015): 1–15, <a href="https://doi.org/10.1145/2816795.2818078" target="_blank" rel="noopener">https://doi.org/10.1145/2816795.2818078</a>.</p><h4 id="《LoopyCuts-practical-feature-preserving-block-decomposition》-2020"><a href="#《LoopyCuts-practical-feature-preserving-block-decomposition》-2020" class="headerlink" title="《LoopyCuts: practical feature-preserving block decomposition》-2020"></a>《<i>LoopyCuts</i>: practical feature-preserving block decomposition》-2020</h4><p>&emsp;&emsp;一阶段首先通过MIQ方法生成的标架场和确定好的特征来生成Field-Coherent Loops（方法采用《Tracing Field-Coherent Quad Layouts》），提出通过维护采样池和采样最远loop队列来对网格进行loop划分；二阶段通过划分好的loop通过中点细分生成体网格。（该方法对标架场质量要求高，速度慢，一些demo我测试没通过）<a href="https://senjay.github.io/2020/08/16/LoopyCuts%E7%BC%96%E8%AF%91%E8%BF%90%E8%A1%8C%E6%96%B9%E6%B3%95/" target="_blank" rel="noopener">编译方法</a>，<a href="https://senjay.github.io/2020/09/04/2020-09-04-LoopyCuts-Computer-Cutting-Loops/" target="_blank" rel="noopener">笔记</a></p><p>Livesu, Marco, Nico Pietroni, Enrico Puppo, Alla Sheffer, and Paolo Cignoni. “<em>LoopyCuts</em>: Practical Feature-Preserving Block Decomposition for Strongly Hex-Dominant Meshing.” <em>ACM Transactions on Graphics</em> 39, no. 4 (July 8, 2020). <a href="https://doi.org/10.1145/3386569.3392472" target="_blank" rel="noopener">https://doi.org/10.1145/3386569.3392472</a>.</p><h4 id="《Boundary-Aligned-Smooth-3D-Cross-Frame-Field》-2011"><a href="#《Boundary-Aligned-Smooth-3D-Cross-Frame-Field》-2011" class="headerlink" title="《Boundary Aligned Smooth 3D Cross-Frame Field》-2011"></a>《Boundary Aligned Smooth 3D Cross-Frame Field》-2011</h4><p>&emsp;&emsp;3d标架存在24个方向（坐标轴有6个选择，垂直它的有4种，即6x4=24种），为了表述两个相邻标架的差异，采用基函数来表示<strong>四面体网格面上的标架</strong>，而不是采用以前的使用vector pair来表示,该文首先提出了采用球谐函数作为基函数来描述标架,从而可以通过积分来描述标架的差异并据此定义能量函数来优化 ，最后使用L-BFGS来光滑标架场，该方法同时支持表面法向量约束对齐（有缺陷）。并通过3d标架来引导出流线划分网格并生成hexahedron-dominant mesh。（计算量大）</p><p>Huang, Jin, Yiying Tong, Hongyu Wei, and Hujun Bao. “Boundary Aligned Smooth 3D Cross-Frame Field.” In <em>Proceedings of the 2011 SIGGRAPH Asia Conference on - SA ’11</em>, 1. Hong Kong, China: ACM Press, 2011. <a href="https://doi.org/10.1145/2024156.2024177" target="_blank" rel="noopener">https://doi.org/10.1145/2024156.2024177</a>.</p><h4 id="《Practical-3D-frame-field-generation》-2016"><a href="#《Practical-3D-frame-field-generation》-2016" class="headerlink" title="《Practical 3D frame field generation》-2016"></a>《Practical 3D frame field generation》-2016</h4><p>&emsp;&emsp;先描述2D形式下使用基函数来描述标架场的可行性，进而拓展到3D采用球谐函数作为基函数来表述<strong>四面体网格顶点上的标架</strong>，该文的优化方法相比于《Boundary Aligned Smooth 3D Cross-Frame Field》性能更好，同时增加了约束限制条件的可行性。该文先以一个简化的方法来给出一个目标能量函数，并用最小二乘来初始化它，最后也已L-BFGS法来平滑。</p><p>Nicolas Ray, Dmitry Sokolov, and Bruno Lévy, “Practical 3D Frame Field Generation,” <em>ACM Transactions on Graphics</em> 35, no. 6 (November 11, 2016): 1–9, <a href="https://doi.org/10.1145/2980179.2982408" target="_blank" rel="noopener">https://doi.org/10.1145/2980179.2982408</a>.</p><h3 id="2-网格简化"><a href="#2-网格简化" class="headerlink" title="2.网格简化"></a>2.网格简化</h3><h4 id="《Surface-simplification-using-quadric-error-metrics》-1997"><a href="#《Surface-simplification-using-quadric-error-metrics》-1997" class="headerlink" title="《Surface simplification using quadric error metrics》-1997"></a>《Surface simplification using quadric error metrics》-1997</h4><p>&emsp;&emsp;通过Quadratic error Matrix来描述距离误差，进而塌陷边到合适的点来达到简化网格的目的。<a href="https://senjay.github.io/2020/07/14/2020-07-14-Quadric-error-metric/" target="_blank" rel="noopener">笔记</a></p><p>Michael Garland and Paul S. Heckbert, “Surface Simplification Using Quadric Error Metrics,” in <em>Proceedings of the 24th Annual Conference on Computer Graphics and Interactive Techniques - SIGGRAPH ’97</em> (the 24th annual conference, Not Known: ACM Press, 1997), 209–16, <a href="https://doi.org/10.1145/258734.258849" target="_blank" rel="noopener">https://doi.org/10.1145/258734.258849</a>.</p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>论文简介</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++易踩Bug持续更新</title>
    <link href="/2020/09/06/2020-08-12-C++%E6%98%93%E8%B8%A9Bug%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/"/>
    <url>/2020/09/06/2020-08-12-C++%E6%98%93%E8%B8%A9Bug%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/</url>
    
    <content type="html"><![CDATA[<h3 id="函数调用约定的常见问题"><a href="#函数调用约定的常见问题" class="headerlink" title="函数调用约定的常见问题"></a>函数调用约定的常见问题</h3><h4 id="1-参数传递顺序"><a href="#1-参数传递顺序" class="headerlink" title="1. 参数传递顺序"></a>1. 参数传递顺序</h4><p>&emsp;&emsp;常用的有<code>__cdecl</code>:参数从右至左传递放在栈中，堆栈由调用者清除，支持可变长参数。（另外十分不建议在参数中包含了多个类似<code>a++</code>,<code>++a</code>,<code>a</code>，即同个参数的变换,十分容易引发问题）</p><p>​        对于c/c++函数参数的读取顺序(默认<code>__cedel</code>)，参数入栈时顺序的确是从右向左入栈，但是在入栈前会先把参数列表里的表达式从右向左算一遍得到表达式的结果，最后再把这些运算结果统一入栈。也就是说在参数入栈前，编译器会先把参数的表达式都处理掉，哪怕这些运算会改变其中某些参数的值；然后对于一般的操作来说，参数入栈时取值是直接从变量的内存地址里取的，但是对于a++操作，<strong>编译器会开辟一个缓冲区来保存当前a的值</strong>，然后再对a继续操作，<strong>最后参数入栈时的取值是从缓冲区取，而不是直接从a的内存地址里取</strong>。</p><p>因此，对于下面的程序：</p><pre><code class="hljs c++">a=<span class="hljs-number">10</span>;<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d %d %d\n"</span>,a++,++a,a,a++)<span class="hljs-comment">//output:12 13 13 10</span></code></pre><p>&emsp;&emsp;首先从右向左处理表达式，最后a的结果变成13.但是在处理a++的时候，从最右边开始，第一个a++放进缓冲区的值为10，第二个a++放进缓冲区的值为12.因此最后处理结果如上。注意++a和a的值都是直接从a的内存中取出来的，都是13.</p><img src="/2020/09/06/2020-08-12-C++%E6%98%93%E8%B8%A9Bug%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/image-20200812165825425.png" srcset="/img/loading.gif" class="" title="image-20200812165825425"><p>&emsp;&emsp;其中<code>__vectorcall</code>则用寄存器传浮点类型和向量(SIMD vector)类型的参数，可提高速度。</p><h4 id="2-链接库的函数调用约定和名字修饰规则不匹配引起堆栈异常"><a href="#2-链接库的函数调用约定和名字修饰规则不匹配引起堆栈异常" class="headerlink" title="2. 链接库的函数调用约定和名字修饰规则不匹配引起堆栈异常"></a>2. 链接库的函数调用约定和名字修饰规则不匹配引起堆栈异常</h4><p>​                                                                                                                                                                    ——<a href="https://blog.csdn.net/guoliang624/article/details/7648823?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.channel_param&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.channel_param" target="_blank" rel="noopener">参考文章链接</a></p><p>&emsp;&emsp;函数调用时如果出现<strong>堆栈异常</strong>，可能由于函数调用约定不匹配引起的。比如动态链接库a有以下导出函数：</p><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">long</span> <span class="hljs-title">MakeFun</span><span class="hljs-params">(<span class="hljs-keyword">long</span> lFun)</span></span>;</code></pre><p>&emsp;&emsp;动态库生成的时候采用的函数调用约定是<code>__stdcall</code>,所以编译生成的a.dll中函数<code>MakeFun</code>的调用约定是<code>_stdcall</code>，也就是函数调用时参数从右向左入栈，函数返回时自己还原堆栈。现在某个程序模块b要引用a中的<code>MakeFun</code>，b和a一样使用  C++方式编译，只是b模块的函数调用方式是<code>__cdecl</code>，由于b包含了a提供的头文件中<code>MakeFun</code>函数声明，所以<code>MakeFun</code>在b模块中被其它调用<code>MakeFun</code>的函数认为是<code>__cdecl</code>调用方式，b模块中的这些函数在调用完<code>MakeFun</code>要恢复堆栈，可是<code>MakeFun</code>已经在结束时自己恢复了堆栈，b模块中的函数这样多此一举就引起了栈指针错误，从而引发堆栈异常。</p><p>&emsp;&emsp;宏观上的现象就是函数调用没有问题（因为参数传递顺序是一样的），<code>MakeFun</code>也完成了自己的功能，<strong>只是函数返回后引发错误</strong>。解决的方法也很简单，只要保证两个模块的在编译时设置相同的函数调用约定就行了。</p><p>&emsp;&emsp;在了解函数调用约定和函数的修饰规则之后，再来看在C++程序中使用C语言编译的库时经常出现的LNK  2001错误。还以上面例子的两个模块为例，这一次两个模块在编译的时候都采用<code>__stdcall</code>调用约定，但是a.dll使用C语言的语法编译的（C语言方式），所以a.dll的载入库a.lib中<code>MakeFun</code>函数的名字修饰就是<code>_MakeFun@4</code>。b包含了a提供的头文件中<code>MakeFun</code>函数声明，但是由于b采用的是C++语言编译，所以M<code>akeFun</code>在b模块中被按照C++的名字修饰规则命名为<code>?MakeFun@@YGJJ@Z</code>，编译过程相安无事，链接程序时c++的链接器就到a.lib中去找<code>?MakeFun@@YGJJ@Z</code>，但是a.lib中只有<code>_MakeFun@4</code>，没有<code>?MakeFun@@YGJJ@Z</code>，于是链接器就报告：</p><pre><code class="hljs markdown">error LNK2001: unresolved external symbol ?MakeFun@@YGJJ@Z</code></pre><p>&emsp;&emsp;解决的方法和简单，就是要让b模块知道这个函数是C语言编译的，<code>extern &quot;C&quot;</code>可以做到这一点。一个采用C语言编译的库应该考虑到使用这个库的程序可能是C++程序（使用C++编译器），所以在设计头文件时应该注意这一点。通常应该这样声明头文件：</p><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> _cplusplus</span><span class="hljs-keyword">extern</span> <span class="hljs-string">"C"</span> &#123;<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>    <span class="hljs-function"><span class="hljs-keyword">long</span> <span class="hljs-title">MakeFun</span><span class="hljs-params">(<span class="hljs-keyword">long</span> lFun)</span></span>;     <span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> _cplusplus</span>&#125;<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span></code></pre><p>​                                        </p><h3 id="QT"><a href="#QT" class="headerlink" title="QT"></a>QT</h3><h4 id="1-QString与std-string的转换-防止乱码"><a href="#1-QString与std-string的转换-防止乱码" class="headerlink" title="1. QString与std::string的转换(防止乱码)"></a>1. QString与std::string的转换(防止乱码)</h4><p>&emsp;&emsp;QString与std::string的转换在release模式下尤其容易造成乱码问题，使用如下方法可避免：</p><pre><code class="hljs c++">\\QString-&gt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>QString qstr = QString(<span class="hljs-string">"2|%1|%2"</span>).arg(<span class="hljs-string">"3"</span>).arg(<span class="hljs-string">"4"</span>);QByteArray qba = qstr.toLocal8Bit();<span class="hljs-comment">//第一步</span><span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> std_strsendmid = qba.data()<span class="hljs-comment">//第二步</span>\\<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>-&gt;QStringQString qstr = QString::fromLocal8Bit(std_str);<span class="hljs-comment">//一步</span></code></pre><p>&emsp;&emsp;PS:C++里另一种常见的字符问题是<code>std::string</code>的<code>c_str()</code>方法来转换<code>char*</code>。如果字符串是临时变量也容易被优化掉或者string改变后新得到的<code>char *</code>类型的字符串也会随之改变，因为<code>c_str()</code>返回的是string里封装好的<code>char *</code>指针（当前字符串的首字符的地址，虽然说返回的是<code>const char *</code>类型，但不要想当然的以为指向内容就不会改变了，因为我们只是无法通过它自身改变值，但是可以通过赋值给它的string改变它),因此最好使用<code>strcpy(str1,str2)</code>来拷贝一份。</p>]]></content>
    
    
    <categories>
      
      <category>bug</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LoopyCuts-Computer Cutting Loops</title>
    <link href="/2020/09/04/2020-09-04-LoopyCuts-Computer-Cutting-Loops/"/>
    <url>/2020/09/04/2020-09-04-LoopyCuts-Computer-Cutting-Loops/</url>
    
    <content type="html"><![CDATA[<h3 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1.基本概念"></a>1.基本概念</h3><p>&emsp;&emsp;feature line分为flat、concave、convex三种，由integrated curvature的<script type="math/tex">\theta</script>根据阈值<script type="math/tex">\bar \theta</script>判定:</p><script type="math/tex; mode=display">\left\{\begin{aligned}&\mathrm{flat},\ \ \ \ \ \ \ \ \ \ \ |\theta|<\bar\theta \\&\mathrm{concave},\ \ \ \ \theta<-\bar\theta\\&\mathrm{convex},\ \ \ \ \ \ \theta>\bar\theta\\\end{aligned}\right.</script><p>这里<script type="math/tex">\bar \theta=10^{\circ}</script>，例子如下图</p><p>&emsp;&emsp;标架场采用《Mixed-integer quadrangulation》中的方法建立</p><img src="/2020/09/04/2020-09-04-LoopyCuts-Computer-Cutting-Loops/image-20200904213438466.png" srcset="/img/loading.gif" class="" title="image-20200904213438466"><h3 id="2-Field-Coherent-Loops"><a href="#2-Field-Coherent-Loops" class="headerlink" title="2.Field-Coherent Loops"></a>2.Field-Coherent Loops</h3><p>&emsp;&emsp;由标架场引导出field-coherent geodesic path:<script type="math/tex">\ell</script>切线与p点标架夹角小于<script type="math/tex">\frac{\pi}{4}</script>。为了描述其偏离程度使用以下公式</p><script type="math/tex; mode=display">\|w\|_{\mathrm{X}}=|w|\left(1+\alpha \frac{\angle\left(p_{\theta}, w\right)}{\pi / 4}\right)</script><p>其中<script type="math/tex">w</script>为切向量，<script type="math/tex">p_{\theta}</script>为标架之一，<script type="math/tex">\alpha</script>为惩罚系数。我们的目标是由点沿着field-coherent geodesic path返回点，即得到闭合曲线。而上述公式是为了避免造成过度偏离现象，如下图</p><img src="/2020/09/04/2020-09-04-LoopyCuts-Computer-Cutting-Loops/image-20200904213304148.png" srcset="/img/loading.gif" class="" title="image-20200904213304148"><p>&emsp;&emsp;定义曲线之间的距离如下：</p><script type="math/tex; mode=display">d\left(\ell_{i}, \ell_{j}\right)=\frac{1}{\left|\ell_{j}\right|} \int_{\ell_{j}} \operatorname{dist}\left(\ell_{i}, p_{\theta}\right) d p_{\theta}</script><p>其中<script type="math/tex">\operatorname{dist}\left(\ell_{i}, p_{\theta}\right)</script>为<script type="math/tex">p_{\theta}</script>与<script type="math/tex">\ell</script>之间的最短field-coherent geodesic path长度。</p><p>&emsp;&emsp;设loop集合<script type="math/tex">\mathcal{L}=\{\ell_1 \dots \ell_k \}</script>,而<script type="math/tex">\ell \notin \mathcal{L}</script>，    </p><script type="math/tex; mode=display">d(\mathcal{L}, \ell)=\frac{1}{|\ell|} \int_{\ell} \min _{\ell_{i} \in \mathcal{L}} \operatorname{dist}\left(\ell_{i}, p_{\theta}\right) d p_{\theta}</script><p>则离<script type="math/tex">\mathcal{L}</script>最远的<script type="math/tex">\bar \ell</script>为</p><script type="math/tex; mode=display">\bar{\ell}=\operatorname{argmax}_{\ell \in \mathrm{L}} d(\mathcal{L}, \ell)</script><img src="/2020/09/04/2020-09-04-LoopyCuts-Computer-Cutting-Loops/image-20200904221853685.png" srcset="/img/loading.gif" class="" title="image-20200904221853685"><h3 id="3-特征loop"><a href="#3-特征loop" class="headerlink" title="3.特征loop"></a>3.特征loop</h3><p>&emsp;&emsp;维护一个初始队列<script type="math/tex">Q</script>用来装loop,feature line <script type="math/tex">\ell</script> 分为两类处理，如下：</p><ol><li>闭合：如果为flat特征则加入<script type="math/tex">Q</script>队列;如果为concave,拷贝正反方向两份入队</li><li>非闭合：如果为flat拓展成一个loop入队，如果为concave,沿两端点分别生成两个loop入队</li></ol><h3 id="4-采样最远loop"><a href="#4-采样最远loop" class="headerlink" title="4.采样最远loop"></a>4.采样最远loop</h3><p>&emsp;&emsp;每次采样最远的loop加入<script type="math/tex">Q</script>中，其终止条件需满足以下两个：</p><ol><li>Topological integrity ：Q中每个loop至少与其他loop相交三次。</li><li>Geometric fit  ：path的面积与polyon的面积相差不超过阈值</li></ol><h3 id="5-维护采样池"><a href="#5-维护采样池" class="headerlink" title="5. 维护采样池"></a>5. 维护采样池</h3><p>&emsp;&emsp;定义<script type="math/tex">\bar Q=Q \cup C\mathcal{F}</script>,其中<script type="math/tex">C\mathcal{F}</script>为convex feature,通过以下两种方式创建采样池<script type="math/tex">\mathcal{P}</script>:</p><ol><li>以固定间隔采样<script type="math/tex">\bar Q</script>中loop,对其中每个loop，跟踪一个垂直它自己新loop加入采样池<script type="math/tex">\mathcal{P}</script>，新loop需满足与<script type="math/tex">\bar Q</script>中loop不正切相交</li><li>在表面进行泊松分布采样（Poisson-Disk Sampling）获得点集<script type="math/tex">\mathrm{P}</script>,对于每个<script type="math/tex">p\in \mathrm{P}</script>跟踪两条新的loop,同样的他们需要满足与<script type="math/tex">\bar Q</script>中的不正切相交，加入采样池<script type="math/tex">\mathcal{P}</script></li></ol><p>每当从<script type="math/tex">\mathcal{P}</script>中选择一条最远loop加入<script type="math/tex">Q</script>中后，需要对采样池<script type="math/tex">\mathcal{P}</script>用方法1重新装填新的loop进去。</p><p>&emsp;&emsp;为提高Topological integrity，从采样池中选取loop不再是简单的选择与<script type="math/tex">\bar Q</script>中最远的loop,而使用新的规则：设<script type="math/tex">\hat Q</script>为<script type="math/tex">Q</script>的子集且不满足Topological integrity条件，我们使采样池<script type="math/tex">\mathcal{P}</script>中与<script type="math/tex">\hat Q</script>中相交的loop具有更大的优先度被选择，即除了距离因素外加入相交次数作为优先度来快速提高拓扑完整性。根据以上规则在采样池中选择与<script type="math/tex">\bar Q</script>最远的loop<script type="math/tex">\ell</script> 加入<script type="math/tex">Q</script>,然后在采样池<script type="math/tex">\mathcal{P}</script>中移除所有与<script type="math/tex">\ell</script>正切相交的loop,并重新跟踪它们的源点<script type="math/tex">p \in \mathrm{P}</script>的两条正交loop(满足与新更新的<script type="math/tex">\bar Q</script>中的loop不正切相交)</p><img src="/2020/09/04/2020-09-04-LoopyCuts-Computer-Cutting-Loops/image-20200905013318085.png" srcset="/img/loading.gif" class="" title="image-20200905013318085"><h3 id="6-输出"><a href="#6-输出" class="headerlink" title="6. 输出"></a>6. 输出</h3><p>&emsp;&emsp;输出由两部分组成：队列<script type="math/tex">Q</script>与凸特征<script type="math/tex">C\mathcal{F}</script>。其中每个loop都以<script type="math/tex">((p_1,n_1)\dots(p_h,n_h))</script>形式给出，<script type="math/tex">p</script>为点，<script type="math/tex">n</script>为法向量。</p><p>&emsp;&emsp;需要注意不是每个非闭合的feature都可以拓展成闭合loop，在拓展feature loop时也可能产生自相交的loop(这种类型舍弃)，而那些无法闭合的feature我们把它们称为incomplete loop并加入<script type="math/tex">Q</script>，在下一个阶段进行处理。</p><h3 id="附1-Tracing-loops"><a href="#附1-Tracing-loops" class="headerlink" title="附1.Tracing loops"></a>附1.Tracing loops</h3><p>&emsp;&emsp;trace loop使用《Tracing Field-Coherent Quad Layouts 》的方法在一个拓展出来的图<script type="math/tex">\mathcal{G}</script>上进行Dijkstra 算法，其中图<script type="math/tex">\mathcal{G}</script>由曲面M上的边和顶点，还有边上的采样得到斯坦纳点（Steiner point）和连接斯坦纳点和顶点的边组成。不同的是，这里的</p><p>&emsp;&emsp;距离测量：对于集合<script type="math/tex">\mathcal{L}</script>中的每条loop,在每条loop上的每个点作为源点跑Dijkstra,从而找到最远的<script type="math/tex">\ell \notin \mathcal{L}</script>（这里很耗时）</p><p>&emsp;&emsp;传播限制：在做Dijkstra时，搜索路径不能与<script type="math/tex">\bar Q</script>正切相交</p><h3 id="附2-相交说明"><a href="#附2-相交说明" class="headerlink" title="附2.相交说明"></a>附2.相交说明</h3><ol><li>正切相交判断：曲线相交，标架平行</li><li>垂直相交判断：曲线相交，标架相交</li></ol><img src="/2020/09/04/2020-09-04-LoopyCuts-Computer-Cutting-Loops/image-20200905005822283.png" srcset="/img/loading.gif" class="" title="image-20200905005822283">]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LoopyCuts</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Instant Meshes 奇异点检测</title>
    <link href="/2020/08/28/2020-02-22-Instant-Meshes-%E5%A5%87%E5%BC%82%E7%82%B9%E6%A3%80%E6%B5%8B/"/>
    <url>/2020/08/28/2020-02-22-Instant-Meshes-%E5%A5%87%E5%BC%82%E7%82%B9%E6%A3%80%E6%B5%8B/</url>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;对于<script type="math/tex">4-Rosy\ field</script>，每个三角形网格的顶点<script type="math/tex">V_i</script>,都有一个标架<script type="math/tex">q_{si}</script>,根据以下式子，可判断奇异点：</p><script type="math/tex; mode=display">\begin{align}&\mathop{\arg\min}_{si,sj}\{q_{si}\cdot q_{sj}\}\ \ \ \ \ \ \ \ \ \ \ \ si,sj\in [0,3]\\& \mathrm{index}=(\sum(si-sj))\bmod 4\end{align}</script><script type="math/tex; mode=display">\left\{\begin{aligned}&\mathrm{is\ singularity},\ \ \ \ \ \ \mathrm{index}=1\ or\ 3\\&\mathrm{not\ singularity},\ \ \ \mathrm{else}\\\end{aligned}\right.</script><p>即在三角形中，相邻两个点的标架夹成的最小角的标架方向的序号的差的和与方向场的方向数的余数若为1或者3即该三角形内有奇异点。</p><img src="/2020/08/28/2020-02-22-Instant-Meshes-%E5%A5%87%E5%BC%82%E7%82%B9%E6%A3%80%E6%B5%8B/image-20200828191106279.png" srcset="/img/loading.gif" class="" title="image-20200828191106279">]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>标架场</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Instant Meshes 标架场方法</title>
    <link href="/2020/08/22/2020-08-22-Instant-Meshes-%E6%A0%87%E6%9E%B6%E5%9C%BA%E6%96%B9%E6%B3%95/"/>
    <url>/2020/08/22/2020-08-22-Instant-Meshes-%E6%A0%87%E6%9E%B6%E5%9C%BA%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;在顶点<script type="math/tex">V_i</script>定义n-Rosy标架场，定义</p><script type="math/tex; mode=display">\begin{align}&\mathcal{R_{s_o}}(\mathbf{o},\mathbf{n},k):=rot(\mathbf{n},k\frac{2\pi}{s_o}),k \in \mathbb{Z} \\&\mathcal{R_{s_o}}(\mathbf{o},\mathbf{n}):=\{\mathcal{R_{s_o}}(\mathbf{o},\mathbf{n},0),\mathcal{R_{s_o}}(\mathbf{o},\mathbf{n},1),\dots,\mathcal{R_{s_o}}(\mathbf{o},\mathbf{n},s_o-1)\}\end{align}</script><p>第一个式子是将<script type="math/tex">\vec{o}</script>绕法向量<script type="math/tex">\vec{n}</script>旋转<script type="math/tex">k\frac{2\pi}{s_o}</script>角度，第二个式子即是在顶点处用<script type="math/tex">\vec{o}</script>对称旋转<script type="math/tex">n</script>次构成一个n-Rosy标架场</p><img src="/2020/08/22/2020-08-22-Instant-Meshes-%E6%A0%87%E6%9E%B6%E5%9C%BA%E6%96%B9%E6%B3%95/image-20200822165325984.png" srcset="/img/loading.gif" class="" title="image-20200822165325984"><h3 id="1-Intrinsic-smoothness"><a href="#1-Intrinsic-smoothness" class="headerlink" title="1.Intrinsic smoothness"></a>1.Intrinsic smoothness</h3><p>&emsp;&emsp;该方法为将顶点<script type="math/tex">V_i</script>的相邻顶点<script type="math/tex">V_j</script>旋转到<script type="math/tex">V_i</script>的切平面上，然后寻找<script type="math/tex">\vec{o_i}</script>与<script type="math/tex">\vec{o_j}</script>的最小旋转角度，并用高斯赛德尔方法进行迭代求解。</p><p>&emsp;&emsp;定义能量函数：</p><script type="math/tex; mode=display">E(O, \mathbf{k}):=\sum_{i \in \mathcal{V}} \sum_{j \in \mathcal{N}(i)} \angle\left(\mathbf{o}_{i}, \mathcal{R}_{s_{o}}\left(\mathbf{o}_{j i}, \mathbf{n}_{i}, k_{i j}\right)\right)^{2}</script><p>其中<script type="math/tex">\mathbf{o}_{j i}:=\operatorname{rot}\left(\mathbf{n}_{j} \times \mathbf{n}_{i}, \angle\left(\mathbf{n}_{j}, \mathbf{n}_{i}\right)\right) \mathbf{o}_{j}</script>,即<script type="math/tex">o_j</script>旋转到<script type="math/tex">V_i</script>切平面上后的向量。<script type="math/tex">k_{ij}</script>为旋转次数，要求解该能量函数，可通过以下方法</p><script type="math/tex; mode=display">\begin{align}&k_{i j}:=\underset{0 \leq k<s_{o}}{\arg \min } \angle\left(\mathbf{o}_{i}, \mathcal{R}_{s_{o}}\left(\mathbf{o}_{j i}, \mathbf{n}_{i}, k\right)\right)\\&\mathbf{o}_{i} \leftarrow \sum_{j \in \mathcal{N}(i)} w_{i j} \mathcal{R}_{s_{o}}\left(\mathbf{o}_{j i}, \mathbf{n}_{i}, k_{i j}\right), \quad \mathbf{o}_{i} \leftarrow \mathbf{o}_{i} /\left\|\mathbf{o}_{i}\right\|\end{align}</script><p>即先寻找最佳旋转次数，然后通过拉普拉斯权重归一化，由于搜寻空间是很小的(<script type="math/tex">s_o</script>，如果是n-Rosy,也就是n,而n通常是很小的一个常数)，可用暴力方法，若顶点<script type="math/tex">V_i</script>周围有<script type="math/tex">m</script>个点，那迭代一次的搜索空间大小也只有<script type="math/tex">mn</script></p><p>然后通过高斯赛德尔迭代：</p><script type="math/tex; mode=display">\begin{array}{ll}\mathbf{o}_{i}^{\prime} \leftarrow w_{i j_{1}} \mathcal{R}_{s_{o}}\left(\mathbf{o}_{j_{1} i}, \mathbf{n}_{i}, k_{i j_{1}}\right), & \mathbf{o}_{i} \leftarrow \mathbf{o}_{i}^{\prime} /\left\|\mathbf{o}_{i}^{\prime}\right\| \\\mathbf{o}_{i}^{\prime} \leftarrow \mathbf{o}_{i}^{\prime}+w_{i j_{2}} \mathcal{R}_{s_{o}}\left(\mathbf{o}_{j_{2} i}, \mathbf{n}_{i}, k_{i j_{2}}\right), & \mathbf{o}_{i} \leftarrow \mathbf{o}_{i}^{\prime} /\left\|\mathbf{o}_{i}^{\prime}\right\|\end{array}</script><h3 id="2-Extrinsic-smoothness"><a href="#2-Extrinsic-smoothness" class="headerlink" title="2.Extrinsic smoothness"></a>2.Extrinsic smoothness</h3><p>&emsp;&emsp;该方法区别于上面的方法为直接在三维空间里求解能量函数，即不再旋转到切平面，则能量函数改为：</p><script type="math/tex; mode=display">E_{\mathrm{e}}(O, k):=\sum_{i \in \mathcal{V}} \sum_{j \in \mathcal{N}(i)} \angle\left(\mathcal{R}_{s_{o}}\left(\mathbf{o}_{i}, \mathbf{n}_{i}, k_{i j}\right), \mathcal{R}_{s_{o}}\left(\mathbf{o}_{j}, \mathbf{n}_{j}, k_{j i}\right)\right)^{2}</script><p>则<script type="math/tex">k_{ij}</script>的最优解为</p><script type="math/tex; mode=display">\left(k_{i j}, k_{j i}\right):=\underset{0 \leq k, l<s_{o}}{\arg \min } \angle\left(\mathcal{R}_{s_{o}}\left(\mathbf{o}_{i}, \mathbf{n}_{i}, k\right), \mathcal{R}_{s_{o}}\left(\mathbf{o}_{j}, \mathbf{n}_{j}, l\right)\right)^{2}</script><p>可以看到搜索空间变为<script type="math/tex">n^2</script>,其实它还是很小的，也是可以暴力求的。下一步则依然还是高斯赛德尔迭代。</p><h3 id="3-说明"><a href="#3-说明" class="headerlink" title="3.说明"></a>3.说明</h3><ol><li>上述算法有解的条件是收敛，而事实就是它就是<strong>收敛</strong>的。</li><li>上述算法因为它是基于局部的，所以可以<strong>支持并行</strong>。</li><li>初始标架场被设置为随机的切向量，锐利特征则通过二面角阈值来判断，锐利边上顶点的法向量为任一面的法向量，而其余的可用角度权重等来定义。</li><li>Gauss–Seidel method可能陷入局部最小解，可通过随机法避免，而该文提出了另一种<strong>多分辨率层次法（Multiresolution hierarchy）</strong>来避免这种情况,如下。<img src="/2020/08/22/2020-08-22-Instant-Meshes-%E6%A0%87%E6%9E%B6%E5%9C%BA%E6%96%B9%E6%B3%95/image-20200822165143871.png" srcset="/img/loading.gif" class="" title="image-20200822165143871"></li></ol>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>标架场</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LoopyCuts编译运行方法</title>
    <link href="/2020/08/16/LoopyCuts%E7%BC%96%E8%AF%91%E8%BF%90%E8%A1%8C%E6%96%B9%E6%B3%95/"/>
    <url>/2020/08/16/LoopyCuts%E7%BC%96%E8%AF%91%E8%BF%90%E8%A1%8C%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>这绝对是目前我编译过的最心酸的代码:），第一部分的pro配置和部分源码头文件是有误的，第二部分的pro、源码有误，更是几乎翻遍了依赖库cinolib的issue和commit:(</p><h4 id="一-loop-distributor部分"><a href="#一-loop-distributor部分" class="headerlink" title="一.loop_distributor部分"></a>一.loop_distributor部分</h4><h5 id="1-windos-qtcreater下："><a href="#1-windos-qtcreater下：" class="headerlink" title="1. windos qtcreater下："></a>1. windos qtcreater下：</h5><p>如果使用windows且使用64位,按以下步骤：</p><ol><li><p>glwidget.h文件中在<code>#define GLWIDGET_H</code>后面添加以下代码（一定得按此顺序添加头文件）</p><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> GLEW_STATIC</span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;GL/glew.h&gt;</span></span></code></pre></li><li><p>将编译好的一份glew库放在loop_distributor文件夹下，同时我在里面lib下的glew库的64位lib库里添加了一份win下的<code>OpenGL32</code>和<code>GlU32</code>静态库</p></li><li><p>修改loop_distributor.pro文件，将以下修改</p><pre><code class="hljs cmake">win32&#123;  DEFINES += NOMINMAX  <span class="hljs-comment">#LIBS +=$$ANTDIR/lib/AntTweakBar.lib</span>  LIBS +=-L$$ANTDIR/lib/ -lAntTweakBar64<span class="hljs-comment">#需添加64位，并用该写法否则无法链接dll</span>&#125;</code></pre><p>同时在最后添加glew库的依赖</p><pre><code class="hljs cmake"><span class="hljs-comment">#windos下还需以下依赖，同时取消glwidget.h 中#include &lt;GL/glew.h&gt;的注释，并在其前面添加#define GLEW_STATIC</span>win32: LIBS += -L$$PWD/../lib/glew-<span class="hljs-number">2.1</span>.<span class="hljs-number">0</span>/lib/Release/x64/ -lglew32sINCLUDEPATH += $$PWD/../lib/glew-<span class="hljs-number">2.1</span>.<span class="hljs-number">0</span>/<span class="hljs-keyword">include</span>DEPENDPATH += $$PWD/../lib/glew-<span class="hljs-number">2.1</span>.<span class="hljs-number">0</span>/<span class="hljs-keyword">include</span>win32: LIBS += -lOpenGL32win32: LIBS += -lGlU32win32:QMAKE_CXXFLAGS += /bigobj<span class="hljs-comment">#debug模式下编译需要加该项</span></code></pre><p>编译完成运行时选择<code>test_data</code>文件夹下将里面的<code>.sharp</code>和<code>.rosy</code>改成和obj模型同名文件，同时将该模型路径以参数方式运行程序（项目-&gt;run-&gt;command line arguments），否则无法运行。</p><p>这样调试还不行，而且qtcreater调试体验也不好，不过按照以上方法设置后会为vs中的设置大大减轻压力，因为vs能识别一部分pro文件。</p></li></ol><h5 id="2-vs"><a href="#2-vs" class="headerlink" title="2.vs"></a>2.vs</h5><p>&emsp;&emsp;导入pro文件后运行，debug模式下提示缺少<code>AntTweakBar64.dll</code>,在调试-&gt;属性-&gt;配置属性-&gt;调试-&gt;环境中添加以下路径<code>PATH=%PATH%;G:\test\LoopyCuts\lib\AntTweakBar1.16\lib;E:\QT\5.12.9\msvc2015_64\bin</code></p><p>第二个是缺少dll的路径，第三个是qt中的dll路径（不添加会继续提示缺少）。缺少dll的解决方法也可以用其他的，我一直用这个，比其他的体验真的好。。</p><p>&emsp;&emsp;release下上述方法失效，解决方法就是拷贝缺少的dll到包含有exe的同文件夹下。</p><p>&emsp;&emsp;vs中添加命令行参数的方法为调试-&gt;属性-&gt;配置属性-&gt;调试-&gt;命令参数中设置</p><h4 id="二-volumetric-cutter部分"><a href="#二-volumetric-cutter部分" class="headerlink" title="二.volumetric_cutter部分"></a>二.volumetric_cutter部分</h4><h5 id="1-tetgen"><a href="#1-tetgen" class="headerlink" title="1. tetgen"></a>1. tetgen</h5><p>&emsp;&emsp;正常cmake,记得用msvc编译，选择x64,不然默认出linux下的.a静态库</p><h5 id="2-程序部分"><a href="#2-程序部分" class="headerlink" title="2.程序部分"></a>2.程序部分</h5><p>&emsp;&emsp;提前说明以下，这个程序依赖的一个库cinolib无法用msvc编译，巨坑，<a href="https://github.com/mlivesu/cinolib/issues/12" target="_blank" rel="noopener">issue链接</a>！首先在pro文件中配置好tetgen的依赖，然后如果有以下报错依次解决:</p><ol><li><p><code>octree.cpp</code>661行报错，改成以下代码,<a href="https://github.com/mlivesu/cinolib/commit/4849cb3beeb2ea1a26526bc6f7fc265da4ed2c4f" target="_blank" rel="noopener">相关commit链接</a>：</p><pre><code class="hljs c++"><span class="hljs-function">AABB <span class="hljs-title">s_box</span><span class="hljs-params">(s[<span class="hljs-number">0</span>],s[<span class="hljs-number">1</span>])</span></span>;</code></pre></li><li><p><code>hexmesh.cpp</code>405行和415行报错，<a href="https://github.com/mlivesu/cinolib/commit/df7cf8f4dfa6dbbebf1e6b04c26262185861335d" target="_blank" rel="noopener">相关commit链接</a>，依次修改为</p><pre><code class="hljs c++"><span class="hljs-keyword">this</span>-&gt;update_p_quality(pid);<span class="hljs-comment">//405</span><span class="hljs-keyword">this</span>-&gt;update_quality();<span class="hljs-comment">//415</span></code></pre></li><li><p><code>draw_lines_tris.cpp</code>160行<code>glGenerateMimap(GL_TEXTURE_2D)</code>报错，未找到相关解决方法，注释掉后能运行,有个为了兼容msvc的<a href="https://github.com/mlivesu/cinolib/commit/8a41a44642d75cc1725157effef222b8c27488a4" target="_blank" rel="noopener">commit</a>也是注释掉该方法，可是在后续commit又取消了该注释,<a href="https://github.com/mlivesu/cinolib/commit/2d9f95ccc8f63a0bc0a0a17989cdfec5649e41c0#diff-3fd1c919d023c8ba52b7932fc71fa5c9" target="_blank" rel="noopener">链接</a>，具体效果未知。ps:在linux中不注释该方法也无法运行，当前版本都是高于这两个commit的按理说不应该有这个问题。</p></li><li><p>以上步骤能在linux下编译，如果使用windows,还需以下步骤：</p><ul><li><p>在lib\cinolib\include\cinolib\gl文件夹下的draw_xxx.h中头文件中的win下的条件编译宏改成以下代码</p><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;windows.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;GL/gl.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;GL/glu.h&gt;</span></span></code></pre></li><li><p>如果在win下使用mingw编译的话不仅速度慢而且因为obj文件太大无法编译，<strong>不推荐</strong></p></li><li><p>使用msvc编译，msvc不支持变长数组，但源码中有些地方使用变长数组，所以在源码中做如下修改，使用动态申请，但勿忘delete</p><p>laplacian.cpp54行: </p><p>&emsp;&emsp;<code>uint base[n]</code>改用<code>uint *base=new uint[n]()</code>,勿忘delete！</p><p>ambient_occlusion.cpp195行：</p><p>&emsp;&emsp;<code>float depth_buffer[buffer_size*buffer_size]</code>改为<code>float *depth_buffer=new float[buffer_size*buffer_size]();</code>勿忘delete！</p></li></ul></li><li><p>关于这个的pro改动地方有点多，未作记录，就不列出</p></li></ol><h4 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h4><ol><li>第一部分在<strong>windos下编译运行成功</strong>，linux下的话应该可以添加glew库运行，我ubuntu机子上没有该库就没尝试。</li><li>第二部分第三个错误未完美解决，翻到两个相关commit（前一个注释，后一个取消注释？？），注释掉后在<strong>linux编译成功，windos下修改后能在msvc编译下编译成功</strong>，mingw编译特别慢，而且还出错。</li><li>以上两部分使用方法和运行效果还未测试。</li></ol>]]></content>
    
    
    <categories>
      
      <category>教程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>教程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Gauss、Stokes、Green公式</title>
    <link href="/2020/08/13/2020-02-22-Gauss%E3%80%81Stokes%E3%80%81Green%E5%85%AC%E5%BC%8F/"/>
    <url>/2020/08/13/2020-02-22-Gauss%E3%80%81Stokes%E3%80%81Green%E5%85%AC%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;以下<script type="math/tex">F</script>为向量场,<script type="math/tex">\mathbf{n}</script>为法向量，<script type="math/tex">\mathbf{\tau}</script>为切向量。</p><h4 id="1-Gauss"><a href="#1-Gauss" class="headerlink" title="1. Gauss"></a>1. Gauss</h4><script type="math/tex; mode=display">\int_{V}\nabla\cdot Fdv=\int_{S}F\cdot d\mathbf{A}=\int_{S}F\cdot \mathbf{n}dA</script><h4 id="2-Stokes"><a href="#2-Stokes" class="headerlink" title="2. Stokes"></a>2. Stokes</h4><script type="math/tex; mode=display">\int_{S}\nabla\times F\cdot d\mathbf{A}=\int_{S}\nabla\times F\cdot \mathbf{n}dA=\oint_{\partial S}F\cdot d\mathbf{l}=\oint_{\partial S}F\cdot \mathbf{\tau}dl</script><h4 id="3-Green"><a href="#3-Green" class="headerlink" title="3. Green"></a>3. Green</h4><h5 id="3-1-散度形式"><a href="#3-1-散度形式" class="headerlink" title="3.1 散度形式"></a>3.1 散度形式</h5><script type="math/tex; mode=display">\int_{S}\nabla\cdot F dA=\oint_{\partial S}F\cdot d\mathbf{l}=\int_{\partial S}F\cdot\mathbf{n}dl</script><h5 id="3-2-旋度形式"><a href="#3-2-旋度形式" class="headerlink" title="3.2 旋度形式"></a>3.2 旋度形式</h5><script type="math/tex; mode=display">\int_{S}\nabla\times F\cdot d\mathbf{A}=\oint_{\partial S}F\cdot d\mathbf{l}=\oint_{\partial S}F\cdot \mathbf{\tau}dl</script><h4 id="4-说明"><a href="#4-说明" class="headerlink" title="4. 说明"></a>4. 说明</h4><p>&emsp;&emsp;可理解为内部区域的性质通过边界来反映，即：</p><ol><li>Gauss:内部体积元的散度积分等于表面通量积分</li><li>Stokes:表面面积元矢量的旋度积分等于边界的环量积分</li><li>Green:两个形式分别为以上的退化形式</li></ol>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>math</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>空间曲线Frenet标架</title>
    <link href="/2020/08/10/2020-08-10-%E7%A9%BA%E9%97%B4%E6%9B%B2%E7%BA%BFFrenet%E6%A0%87%E6%9E%B6/"/>
    <url>/2020/08/10/2020-08-10-%E7%A9%BA%E9%97%B4%E6%9B%B2%E7%BA%BFFrenet%E6%A0%87%E6%9E%B6/</url>
    
    <content type="html"><![CDATA[<img src="/2020/08/10/2020-08-10-%E7%A9%BA%E9%97%B4%E6%9B%B2%E7%BA%BFFrenet%E6%A0%87%E6%9E%B6/%E7%A9%BA%E9%97%B4%E6%9B%B2%E7%BA%BFFrenet%E6%A0%87%E6%9E%B6.jpg" srcset="/img/loading.gif" class=""><p><script type="math/tex">k(s)</script>为曲率，而<script type="math/tex">\tau(s)</script>为挠率，用来描述扭转程度的，也可以理解为空间曲线离开密切平面的程度。</p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>math</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Directional field synthesis, design, and processing</title>
    <link href="/2020/08/08/2020-08-08-Directional-field-synthesis,-design,-and-processing/"/>
    <url>/2020/08/08/2020-08-08-Directional-field-synthesis,-design,-and-processing/</url>
    
    <content type="html"><![CDATA[<h3 id="1-Types-of-Directional-Fields"><a href="#1-Types-of-Directional-Fields" class="headerlink" title="1. Types of Directional Fields"></a>1. Types of Directional Fields</h3><ol><li>方向场：每个点上的方向或矢量组成的一个大小为<script type="math/tex">N</script>的集合。</li><li><em>RoSy fields</em>: <em>rotationally-symmetric direction fields</em>，对称角度为<script type="math/tex">\frac{2\pi}{N}</script></li></ol><img src="/2020/08/08/2020-08-08-Directional-field-synthesis,-design,-and-processing/image-20200808150152601.png" srcset="/img/loading.gif" class="" title="image-20200808150152601"><p>以上右上角带小标的代表模大小相同。</p><h3 id="2-Differential-Geometry-of-Directional-Fields"><a href="#2-Differential-Geometry-of-Directional-Fields" class="headerlink" title="2. Differential Geometry of Directional Fields"></a>2. Differential Geometry of Directional Fields</h3><h4 id="2-1-Differential-and-Riemannian-Structure"><a href="#2-1-Differential-and-Riemannian-Structure" class="headerlink" title="2.1 Differential and Riemannian Structure"></a>2.1 Differential and Riemannian Structure</h4><ol><li><p>Tangent Bundle and Vector Fields：切丛和向量场，由曲面M的切向量组成。</p></li><li><p>Cotangent Bundle and 1-forms      ×</p></li><li><p>Connections and Parallel Transport   ×</p></li><li><p>Riemannian Metric   ×</p></li><li><p>Levi-Civita Connection    ×</p></li><li><p>Holonomy  ×</p></li></ol><h4 id="2-2-Vector-Field-Topology"><a href="#2-2-Vector-Field-Topology" class="headerlink" title="2.2 Vector Field Topology"></a>2.2 Vector Field Topology</h4><p>&emsp;&emsp;奇异点的指标，是包围奇异点的封闭曲线上的向量逆时针遍历一圈后所旋转的次数。而<em>Poincare–Hopf theorem</em>指出在向量场上所有奇异点指标之和<script type="math/tex">\sum index =2-2g</script>,其中<script type="math/tex">g</script>为规格</p><h3 id="2-3-Vector-Calculus"><a href="#2-3-Vector-Calculus" class="headerlink" title="2.3 Vector Calculus"></a>2.3 Vector Calculus</h3><ol><li>梯度、散度、旋度的介绍。</li><li>霍奇分解和协变场 ×</li><li>外积分</li></ol><p>​        </p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>图形学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>记一个QT中QOpenGLWidget 与 QGLWidget的坑</title>
    <link href="/2020/08/07/2020-08-07-%E8%AE%B0%E4%B8%80%E4%B8%AAQT%E4%B8%ADQOpenGLWidget-%E4%B8%8E-QGLWidget%E7%9A%84%E5%9D%91/"/>
    <url>/2020/08/07/2020-08-07-%E8%AE%B0%E4%B8%80%E4%B8%AAQT%E4%B8%ADQOpenGLWidget-%E4%B8%8E-QGLWidget%E7%9A%84%E5%9D%91/</url>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;因为QGLWidget在文档中显示过时，就采用了QOpenGLWidget,因为要用到多重采样来抗锯齿</p><pre><code class="hljs c++">QSurfaceFormat format;format.setSamples(<span class="hljs-number">4</span>);QSurfaceFormat::setDefaultFormat(format);</code></pre><p>结果造成像素深度<code>winz</code>无法读取</p><pre><code class="hljs c++">glReadPixels((<span class="hljs-keyword">int</span>)winx, (<span class="hljs-keyword">int</span>)winy, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, GL_DEPTH_COMPONENT, GL_FLOAT,&amp;winz);</code></pre><p><code>winz</code>一直不会改变。</p><p>&emsp;&emsp;这个bug找了两天多，最终才确定是QOpenGLWidget的多重采样造成的。在QT文档中有</p><pre><code class="hljs c++">QOpenGLWidget always renders offscreen, <span class="hljs-keyword">using</span> framebuffer objects. QGLWidget on the other hand uses a native window <span class="hljs-keyword">and</span> surface.</code></pre><p>同时关于Multisampling的记录是</p><pre><code class="hljs C++">MultisamplingTo enable multisampling, set the number of requested samples on the QSurfaceFormat that is passed to setFormat(). On systems that do not support it the request may get ignored.Multisampling support <span class="hljs-keyword">requires</span> support <span class="hljs-keyword">for</span> multisampled renderbuffers <span class="hljs-keyword">and</span> framebuffer blits. On OpenGL ES <span class="hljs-number">2.0</span> implementations it is likely that these will <span class="hljs-keyword">not</span> be present. This means that multisampling will <span class="hljs-keyword">not</span> be <span class="hljs-built_in">available</span>. With modern OpenGL versions <span class="hljs-keyword">and</span> OpenGL ES <span class="hljs-number">3.0</span> <span class="hljs-keyword">and</span> up <span class="hljs-keyword">this</span> is usually <span class="hljs-keyword">not</span> a problem anymore.</code></pre><p>&emsp;&emsp;可以看到它是<strong>离屏渲染（offscreen）</strong>的，要求使用<code>multisampled renderbuffers</code>和<code>framebuffer</code>,这是一个很大的不同，所以如果坚持要使用它并且要用到读取深度之类的可行思路是重新绑定FBO后去读取。而在QGLWidget中只需要在构造函数的初始化列表中用</p><pre><code class="hljs c++">:QGLWidget(QGLFormat(QGL::SampleBuffers | QGL::AlphaChannel), parent)</code></pre>]]></content>
    
    
    <categories>
      
      <category>bug</category>
      
    </categories>
    
    
    <tags>
      
      <tag>bug</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Mathematics for 3D Game Programming and Computer Graphics 1-4章笔记</title>
    <link href="/2020/07/19/Mathematics-for-3D-Game-Programming-and-Computer-Graphics/"/>
    <url>/2020/07/19/Mathematics-for-3D-Game-Programming-and-Computer-Graphics/</url>
    
    <content type="html"><![CDATA[<h1 id="3D游戏与计算机图形学中的数学方法"><a href="#3D游戏与计算机图形学中的数学方法" class="headerlink" title="3D游戏与计算机图形学中的数学方法"></a>3D游戏与计算机图形学中的数学方法</h1><h2 id="第一章-渲染管线"><a href="#第一章-渲染管线" class="headerlink" title="第一章 渲染管线"></a>第一章 渲染管线</h2><h3 id="1-1-图形处理器"><a href="#1-1-图形处理器" class="headerlink" title="1.1 图形处理器"></a>1.1 图形处理器</h3><p>CPU-GPU通信：</p><p>​        内存&lt;——&gt;CPU——&gt;应用程序——&gt;渲染库(如OpenGL)——&gt;图形卡驱动——&gt;GPU&lt;——&gt;显存</p><p>显存主要缓冲区：</p><ol><li>前后图像缓冲区切换,前：用户可见；后：用户不可见。切换要与屏幕刷新率同步，否则会画面撕裂，即不同时刻的画面出现在屏幕上，屏幕不同部分的画面来自不同缓冲区。</li><li>深度缓冲区（z-缓冲区）：每个像素在图像中的深度值，即该像素里虚拟相机距离。因此可用于隐藏面剔除（只允许显示深度值小于图像缓冲区中像素的深度值的像素）。</li></ol><h3 id="1-2-顶点变换"><a href="#1-2-顶点变换" class="headerlink" title="1.2 顶点变换"></a>1.2 顶点变换</h3><p>​        为了将三维数据变换为二维的图像显示在屏幕上(这是目的，真正进行这步操作的是光栅化)，在模型坐标在世界坐标中映射入相机视界，再通过投影变换来实现近大远小，通过齐次裁剪保证只渲染视界以内元素。注意，顶点也是携带纹理坐标的，这样可以通过纹理映射找到颜色值。</p><p>​        个人理解为坐标变换。</p><h3 id="1-3-光栅化和段操作"><a href="#1-3-光栅化和段操作" class="headerlink" title="1.3 光栅化和段操作"></a>1.3 光栅化和段操作</h3><p>​        将几何元素经过变换填充至屏幕的过程称为光栅化。</p><p>​        光栅化后，GPU计算出每个像素的深度、各顶点插值的颜色、差值得出的纹理坐标与像素自己的位置合称为段数据。段数据经过段操作处理后便可写入图像缓冲区，以下是操作的过程</p><pre><code class="hljs flow">st&#x3D;&gt;start: 段数据op2&#x3D;&gt;operation: 像素包含测试op3&#x3D;&gt;operation: 裁剪测试op4&#x3D;&gt;operation: Alpha测试op5&#x3D;&gt;operation: 模板测试op6&#x3D;&gt;operation: 深度测试op7&#x3D;&gt;operation: 混合ed&#x3D;&gt;end: 图像缓冲区st(right)-&gt;op2(right)-&gt;op3(right)-&gt;op4(right)-&gt;op5(right)-&gt;op6(right)-&gt;op7(right)-&gt;ed</code></pre><h3 id="1-4-总结"><a href="#1-4-总结" class="headerlink" title="1.4  总结"></a>1.4  总结</h3><p>​        这章主要介绍了3维物体在2维屏幕上展现的基本过程，主要是概念上的介绍。</p><pre><code class="hljs flow">st&#x3D;&gt;start: 三维数据op1&#x3D;&gt;operation: 坐标变换op2&#x3D;&gt;operation: 颜色计算op3&#x3D;&gt;operation: 光栅化ed&#x3D;&gt;end: 二维屏幕st(right)-&gt;op1(right)-&gt;op2(right)-&gt;op3(right)-&gt;ed</code></pre><h2 id="第二章-向量"><a href="#第二章-向量" class="headerlink" title="第二章 向量"></a>第二章 向量</h2><p>​        列向量$P$在$Q$上的投影$proj_QP$通过矩阵可表示为:</p><script type="math/tex; mode=display">\begin{align}    proj_QP    &=\frac{Q^TP}{||Q||}\\    &=Q\frac{Q^TP}{||Q||^2}\\    &=\frac{QQ^T}{Q^TQ}P\\\end{align}</script><p>,其中$\frac{QQ^T}{Q^TQ}$为投影矩阵。    </p><p>​        施密特正交化，<strong>将集合中的每个向量减去该向量在其前面的所有向量上的投影</strong>，则处理完后所有向量正交。</p><img src="/2020/07/19/Mathematics-for-3D-Game-Programming-and-Computer-Graphics/image-20200801230112225.png" srcset="/img/loading.gif" class="" title="image-20200801230112225"><h2 id="第三章-矩阵"><a href="#第三章-矩阵" class="headerlink" title="第三章 矩阵"></a>第三章 矩阵</h2><p>​        逆矩阵，行列式，伴随矩阵，线性方程组，克莱姆法则，特征向量，实对称矩阵，矩阵对角化。</p><h2 id="第四章-坐标变换"><a href="#第四章-坐标变换" class="headerlink" title="第四章 坐标变换"></a>第四章 坐标变换</h2><h3 id="4-1-线性变换"><a href="#4-1-线性变换" class="headerlink" title="4.1 线性变换"></a>4.1 线性变换</h3><p>&emsp;&emsp;设在3D坐标系$C_1$中$P$点坐标为$(x,y,z)$,将其转换到坐标系$C_2$，则$(x^{‘},y^{‘},z^{‘})$为：</p><script type="math/tex; mode=display">\begin{bmatrix} x^{'}\\y^{'}\\z^{'}\end{bmatrix} =\begin{bmatrix} U_1&V_1&W_1\\U_2&V_2&W_2\\U_3&V_3&W_3\end{bmatrix} \begin{bmatrix} x\\y\\z\end{bmatrix}+ \begin{bmatrix} T_1\\T_2\\T_3\end{bmatrix}</script><p>其中$U,V,W$组成的矩阵表示坐标轴变换的方式，$T$向量为$C_1$坐标系到$C_2$坐标系平移向量。</p><p>​        若变换矩阵为<strong>正交矩阵</strong>，则该变换可保持向量的长度和角度不变（向量的模不变确保物体的大小不变，向量的点乘不变确保物体的角度不变），因此正交矩阵只可用于旋转变换和反射变换或者是二者的组合。</p><p>​        旋转变换不改变手性，反射变换改变手性。因此，奇数次反射变换改变<strong>原坐标系</strong>手性，偶数次反射变换不改变<strong>原坐标系</strong>手性，且等价于旋转变换，故任意多的反射变换可分解为一次旋转变换加<strong>最多一次</strong>反射变换。若$M$为变换矩阵，$detM<0$说明改变了手性，$detM>0$说明为改变手性。</p><p>​        若$M$为正交阵，应用上述规律，由$detM=\pm1$,当$detM=1$，说明为一个旋转变换；$detM=-1$说明为一个旋转变换和一个反射变换的组合变换。</p><h3 id="4-2-比例变换"><a href="#4-2-比例变换" class="headerlink" title="4.2 比例变换"></a>4.2 比例变换</h3><p>​        通过左乘对角阵来进行$x,y,z$轴的比例变换，如果要沿任意轴变换，可先进行坐标系变换，再比例变换，再还原坐标系，如下。</p><script type="math/tex; mode=display">\begin{bmatrix} x^{'}\\y^{'}\\z^{'}\end{bmatrix} =\begin{bmatrix} U_1&V_1&W_1\\U_2&V_2&W_2\\U_3&V_3&W_3\end{bmatrix}\begin{bmatrix} a&0&0\\0&b&0\\0&0&c\end{bmatrix}\begin{bmatrix} U_1&V_1&W_1\\U_2&V_2&W_2\\U_3&V_3&W_3\end{bmatrix}^{-1}\begin{bmatrix} x\\y\\z\end{bmatrix}</script><h3 id="4-3-旋转变换"><a href="#4-3-旋转变换" class="headerlink" title="4.3 旋转变换"></a>4.3 旋转变换</h3><h4 id="4-3-1-二维"><a href="#4-3-1-二维" class="headerlink" title="4.3.1 二维"></a>4.3.1 二维</h4><p>​        如果要求$P$逆时针旋转$\theta$得到的$P^{‘}$，记$Q$为$P$逆时针旋转90°后的向量,即$(-P_y,P_x)$,则$P$与$Q$正好组成了<strong>该平面内的一组正交向量</strong>，任何向量都可由其线性表出，由基本几何和三角学可得到：</p><script type="math/tex; mode=display">P^{'}=Pcos\theta+Qsin\theta</script><p>则</p><script type="math/tex; mode=display">\begin{aligned}P_x^{'}&=P_xcos\theta-P_ysin\theta\\P_{y}^{'}&=P_ysin\theta-P_xcos\theta\\\end{aligned}</script><p>写成矩阵为</p><script type="math/tex; mode=display">P^{'}=\begin{bmatrix}cos\theta&-sin\theta\\sin\theta&cos\theta\end{bmatrix}P</script><h4 id="4-3-2-三维绕坐标轴旋转"><a href="#4-3-2-三维绕坐标轴旋转" class="headerlink" title="4.3.2 三维绕坐标轴旋转"></a>4.3.2 三维绕坐标轴旋转</h4><img src="/2020/07/19/Mathematics-for-3D-Game-Programming-and-Computer-Graphics/image-20200606132127655.png" srcset="/img/loading.gif" class="" title="image-20200606132127655"><p>​        注意$R_y(\theta)$与其他不同是因为如果按照逆时针旋转，由$x\times z=-y$,则得到$y$轴负方向，因此需改为顺时针，即$-\theta$,这无论是在左手坐标系还是右手系都是相同的。</p><h4 id="4-3-3-三维绕任意轴旋转"><a href="#4-3-3-三维绕任意轴旋转" class="headerlink" title="4.3.3 三维绕任意轴旋转"></a>4.3.3 三维绕任意轴旋转</h4><p>​          <strong>向量$P$绕任意轴$A$旋转$\theta$角度证明：</strong></p><p>​        不妨设$A$为单位向量，同时$P$可分解为与$A$平行和垂直的两个分量，分别为：</p><script type="math/tex; mode=display">\begin{align}P_{projA}&=(A\cdot P)A=AA^TP\\P_{perpA}&=P-(A\cdot P)A=P-AA^TP\end{align}</script><p>如图所示</p><img src="/2020/07/19/Mathematics-for-3D-Game-Programming-and-Computer-Graphics/image-20200606161620614.png" srcset="/img/loading.gif" class="" title="image-20200606161620614"><p>故最终结果</p><script type="math/tex; mode=display">P^{'}=P_{perpA}^{'}+P_{ProjA}</script><p>其中<script type="math/tex">P_{PerpA}^{'}</script>为<script type="math/tex">P_{perpA}</script>旋转<script type="math/tex">\theta</script>后得到的向量，如图</p><img src="/2020/07/19/Mathematics-for-3D-Game-Programming-and-Computer-Graphics/image-20200801231223987.png" srcset="/img/loading.gif" class="" title="image-20200801231223987"><p>为求得其值，需找到一组线性组合来表示它，可选$P<em>{perpA}$与其旋转90°后的向量这两个向量作为组合，可以得知$A\times P$即为该向量，同时它的长度是与$P</em>{perpA}$相等的，这是因为</p><script type="math/tex; mode=display">|A\times P|=|P|sin\alpha=|P-(A\cdot P)A|</script><p>所以</p><script type="math/tex; mode=display">P_{perpA}^{'}=[P-(A\cdot P)A]cos\theta+(A \times P)sin \theta</script><p>所以</p><script type="math/tex; mode=display">\begin{align}P^{'}&=[P-(A\cdot P)A]cos\theta+(A \times P)sin \theta+(A\cdot P)A\\&=Pcos\theta+A\times P sin\theta+(A\cdot P)A(1-cos\theta)\end{align}</script><p>记$I$为单位阵，则矩阵形式为</p><script type="math/tex; mode=display">P^{'}=\{Icos\theta+\begin{bmatrix} 0&-A_z&A_y\\A_z&0&-A_x\\-A_y&A_x&0\end{bmatrix}sin\theta+AA^T(1-cos\theta)\}P</script><p>其中记</p><script type="math/tex; mode=display">R=Icos\theta+\begin{bmatrix} 0&-A_z&A_y\\A_z&0&-A_x\\-A_y&A_x&0\end{bmatrix}sin\theta+AA^T(1-cos\theta)</script><p>为罗德里格斯旋转公式，而将其展开写成一个矩阵就可得到旋转矩阵。</p><h3 id="4-4-齐次坐标"><a href="#4-4-齐次坐标" class="headerlink" title="4.4 齐次坐标"></a>4.4 齐次坐标</h3><p>​        引入第四维度，即四维矩阵$F$得描述来取代之前得三维矩阵的线性变换，这两者是等效的。</p><script type="math/tex; mode=display">F=\begin{bmatrix}M_{33}&\vdots&T_{13}\\0&\vdots&1\end{bmatrix}</script><p>这是一个分块矩阵，由之前线性变换中的三维矩阵$M$和三维向量$T$组成，同时我们用${x,y,z,1}$代表点，${x,y,z,1}$代表向量。</p><h3 id="4-5-法向量变换"><a href="#4-5-法向量变换" class="headerlink" title="4.5 法向量变换"></a>4.5 法向量变换</h3><p>​        当物体经过变换后，其原表面上的法向量就不一定与原来相同了，尤其是发生形变后。不妨设$n,t$分别为变换前的法向量与切向量，$n^{‘},t^{‘}$为变换后正确的法向量与切向量。则</p><script type="math/tex; mode=display">\begin{align}t^Tn=0\\t^TM^T(M^T)^{-1}n=0\\(Mt)^T(M^{-1})^Tn=0\\t^{'T}n^{'}=0\end{align}</script><p>即切向量的变换方法为左乘$(M^{-1})^T$,那么如果$M$为正交阵，法向量的变换为$Mn$,这也就是说，如果变换时不改变物体的大小形状，法向量的变换是与物体相同的。</p><h3 id="4-6-四元数"><a href="#4-6-四元数" class="headerlink" title="4.6 四元数"></a>4.6 四元数</h3><p>​        $q=(w,x,y,z)=w+xi+yj+zk$为四元数，有实部和虚部组成。四元数$q=s+v$的共轭为$\bar q=s-v$,</p><p>有，</p><script type="math/tex; mode=display">q\bar q=\bar q q=|q|^2=q^2</script><p>故$q$的倒数$q^{-1}$为：</p><script type="math/tex; mode=display">q^{-1}=\frac{\bar q}{|q|^2}</script><p>​        三维中P点的旋转描述为：</p><script type="math/tex; mode=display">\varphi(P)=qPq^{-1}</script><p>其中，$q=cos\frac{\theta}{2}+Asin\frac{\theta}{2}$,${A}$为任意单位旋转轴，$\theta$为旋转角度。函数$\varphi$为同态函数，其映射满足长度，角度，偏手性不变。</p><h4 id="4-6-1-球面线性插值"><a href="#4-6-1-球面线性插值" class="headerlink" title="4.6.1 球面线性插值"></a>4.6.1 球面线性插值</h4><p>​        普通线性插值方法：</p><script type="math/tex; mode=display">q(t)=\frac{(1-t)q_1+tq_2}{||(1-t)q_1+tq_2||}</script><p>​        </p><p>其变化率可用$cos^{-1}(q(t)\cdot q_1)$表示，由于其随$t$的变化率不为常数，因此旋转不是匀速的。</p><p>​        引入球面线性插值：</p><script type="math/tex; mode=display">q(t)=\frac{sin[(1-t)\theta]}{sin\theta}q_1+\frac{sin(t\theta)}{sin\theta}q_2</script><p>其中$\theta=cos^{-1}(q_1\cdot q_2)$,也可用$sin\theta=\sqrt{1-(q_1\cdot q_2)^2}$来计算。</p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Graphics</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Quadric error metric</title>
    <link href="/2020/07/14/2020-07-14-Quadric-error-metric/"/>
    <url>/2020/07/14/2020-07-14-Quadric-error-metric/</url>
    
    <content type="html"><![CDATA[<h3 id="1-推导"><a href="#1-推导" class="headerlink" title="1.推导"></a>1.推导</h3><p>&emsp;&emsp;(以下向量均为列向量)</p><p>&emsp;&emsp;设平面$p_i$的法向量为$n_i$,$x_i$为该平面上任一点，则其在齐次坐标下的方程为：</p><script type="math/tex; mode=display">\bar n_i=(n_i,-n_i \cdot x_i)</script><p>设空间中任意一点$x$的齐次坐标为$\bar x=(x, 1)$</p><img src="/2020/07/14/2020-07-14-Quadric-error-metric/image-20200714231049940.png" srcset="/img/loading.gif" class="" title="image-20200714231049940"><p>由几何关系可知$x$到$p_i$的距离的平方$d(x,p_i)$为：</p><script type="math/tex; mode=display">\begin{align}d(x,p_i)&=((x-x_i)\cdot n_i)^2\\&=(\begin{bmatrix}n_i,-n_i\cdot x_i\end{bmatrix}\begin{bmatrix}x\\1\end{bmatrix})^2\\&=(\bar n_i^T\bar x)^2\\&=\bar x^T(\bar n_i\bar n_i^T) \bar x\\&=\bar x^TQ_i\bar x\end{align}</script><p>其中$Q_i$称为Quadratic error Matrix,注意到这个$Q_i$由于是法向量生成的，所以是定义面上的，现在分别定义顶点和边上的Quadratic error Matrix $Q_i^v$和$Q^e$:</p><script type="math/tex; mode=display">\begin{align}Q_i^v&=\sum_{j\in \Omega(i)}Q_j\\Q^e&=Q_1^v+Q_2^v\end{align}</script><img src="/2020/07/14/2020-07-14-Quadric-error-metric/image-20200714233952827.png" srcset="/img/loading.gif" class="" title="image-20200714233952827"><p>所以每条边上的 $\bar v$要满足</p><script type="math/tex; mode=display">\bar v=min(v^TQ^ev)</script><p>若$Q^e$可逆，记$\Delta=v^TQ^ev$,当取最小值时，应该满足$\frac{\partial \Delta}{\partial x}=0$，$\frac{\partial \Delta}{\partial y}=0$，$\frac{\partial \Delta}{\partial z}=0$，即：</p><script type="math/tex; mode=display">\left[\begin{array}{cccc}q_{11} & q_{12} & q_{13} & q_{14} \\q_{12} & q_{22} & q_{23} & q_{24} \\q_{13} & q_{23} & q_{33} & q_{34} \\0 & 0 & 0 & 1\end{array}\right] \mathbf{\mathbf { \bar v }}=\left[\begin{array}{c}0 \\0 \\0 \\1\end{array}\right]</script><p>（ps:如果$Q^e$不满秩，则可取$\bar v=\frac{v_1+v_2}{2}$,即为两顶点中点）</p><h3 id="2-算法流程"><a href="#2-算法流程" class="headerlink" title="2. 算法流程"></a>2. 算法流程</h3><p>&emsp;输入：网格，目标定点数n，cost阈值t</p><p>&emsp;输出：简化后的网格</p><ol><li><p>计算每条边的 $Q^e$</p></li><li><p>计算每条边上的新的$\bar v$</p></li><li><p>while <script type="math/tex">N_v</script> &gt;n and <script type="math/tex">Cost_{min}</script>&lt;t:   </p><p>​        将每条边的$cost=\bar v^TQ^e\bar v$放入最小堆；</p><p>​        删除堆顶的cost,并且塌陷该条边（即将该边的两个顶点并到$\bar v$上去，该新点上的Quadratic error Matrix则更新为刚才的$Q^e$）；</p><p>​        更新堆(更新相邻的$Q^e$和cost)；    </p><p>end;</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Shader笔记1</title>
    <link href="/2020/07/02/2020-07-02-Shader/"/>
    <url>/2020/07/02/2020-07-02-Shader/</url>
    
    <content type="html"><![CDATA[<h2 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h2><div class="table-container"><table><thead><tr><th>类型</th><th>含义</th></tr></thead><tbody><tr><td><code>vecn</code></td><td>包含<code>n</code>个float分量的默认向量</td></tr><tr><td><code>bvecn</code></td><td>包含<code>n</code>个bool分量的向量</td></tr><tr><td><code>ivecn</code></td><td>包含<code>n</code>个int分量的向量</td></tr><tr><td><code>uvecn</code></td><td>包含<code>n</code>个unsigned int分量的向量</td></tr><tr><td><code>dvecn</code></td><td>包含<code>n</code>个double分量的向量</td></tr></tbody></table></div><h3 id="Swizzling-重组"><a href="#Swizzling-重组" class="headerlink" title="Swizzling(重组)"></a>Swizzling(重组)</h3><pre><code class="hljs glsl"><span class="hljs-type">vec2</span> someVec;<span class="hljs-type">vec4</span> differentVec = someVec.xyxx;<span class="hljs-type">vec3</span> anotherVec = differentVec.zyw;<span class="hljs-type">vec4</span> otherVec = someVec.xxxx + anotherVec.yxzy;</code></pre><h2 id="Uniform"><a href="#Uniform" class="headerlink" title="Uniform"></a>Uniform</h2><p>&emsp;&emsp;Uniform是一种从CPU中的应用向GPU中的着色器发送数据的方式，但uniform和顶点属性有些不同。首先，uniform是全局的(Global)。全局意味着uniform变量必须在每个着色器程序对象中都是独一无二的，而且它可以被着色器程序的任意着色器在任意阶段访问。第二，无论你把uniform值设置成什么，uniform会一直保存它们的数据，直到它们被重置或更新。</p><pre><code class="hljs glsl"><span class="hljs-meta">#version 330 core</span><span class="hljs-keyword">out</span> <span class="hljs-type">vec4</span> color;<span class="hljs-keyword">uniform</span> <span class="hljs-type">vec4</span> ourColor; <span class="hljs-comment">// 在OpenGL程序代码中设定这个变量</span><span class="hljs-type">void</span> main()&#123;    color = ourColor;&#125;</code></pre><h3 id="传值"><a href="#传值" class="headerlink" title="传值"></a>传值</h3><p>&emsp;&emsp;通过opengl向uniform变量传值。用<code>glGetUniformLocation</code>查询uniform <code>ourColor</code>的位置值。如果返回<code>-1</code>就代表没有找到这个位置值。最后，我们可以通过glUniform4f函数设置uniform值。注意，查询uniform地址不要求你之前使用过着色器程序，但是更新一个unform之前你<strong>必须</strong>先使用程序（调用glUseProgram)，因为它是在当前激活的着色器程序中设置unform的。</p><pre><code class="hljs glsl">GLfloat timeValue = glfwGetTime();GLfloat greenValue = (<span class="hljs-built_in">sin</span>(timeValue) / <span class="hljs-number">2</span>) + <span class="hljs-number">0.5</span>;GLint vertexColorLocation = glGetUniformLocation(shaderProgram, "ourColor");glUseProgram(shaderProgram);<span class="hljs-comment">//必须先使用程序</span>glUniform4f(vertexColorLocation, <span class="hljs-number">0.0</span>f, greenValue, <span class="hljs-number">0.0</span>f, <span class="hljs-number">1.0</span>f);</code></pre>]]></content>
    
    
    <categories>
      
      <category>Shader</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Shader</tag>
      
      <tag>GLSL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OpenGL笔记1</title>
    <link href="/2020/07/01/2020-07-01-OpenGL%E7%AC%94%E8%AE%B01/"/>
    <url>/2020/07/01/2020-07-01-OpenGL%E7%AC%94%E8%AE%B01/</url>
    
    <content type="html"><![CDATA[<h2 id="1-初始化"><a href="#1-初始化" class="headerlink" title="1.初始化"></a>1.初始化</h2><pre><code class="hljs c++">glewExperimental = GL_TRUE;<span class="hljs-comment">//让GLEW在管理OpenGL的函数指针时更多地使用现代化的技术</span><span class="hljs-keyword">if</span> (glewInit() != GLEW_OK)<span class="hljs-comment">//初始化</span>&#123;    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Failed to initialize GLEW"</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;&#125;</code></pre><div class="note note-warning">            <p>如果是以静态库调用glew,务必在开头加上预编译的头<code>#define GLEW_STATIC</code></p>          </div><h2 id="2-基本流程"><a href="#2-基本流程" class="headerlink" title="2.基本流程"></a>2.基本流程</h2><p>&emsp;&emsp;首先创建一个对象，然后用一个id保存它的引用（实际数据被储存在后台）。然后将对象绑定至上下文的目标位置（例子中窗口对象目标的位置被定义成<code>GL_WINDOW_TARGET</code>）。接下来设置窗口的选项。最后将目标位置的对象id设回0，解绑这个对象。设置的选项将被保存在<code>objectId</code>所引用的对象中，一旦我们重新绑定这个对象到<code>GL_WINDOW_TARGET</code>位置，这些选项就会重新生效。</p><pre><code class="hljs c++"><span class="hljs-comment">// 创建对象</span>GLuint objectId = <span class="hljs-number">0</span>;glGenObject(<span class="hljs-number">1</span>, &amp;objectId);<span class="hljs-comment">// 绑定对象至上下文</span>glBindObject(GL_WINDOW_TARGET, objectId);<span class="hljs-comment">// 设置当前绑定到 GL_WINDOW_TARGET 的对象的一些选项</span>glSetObjectOption(GL_WINDOW_TARGET, GL_OPTION_WINDOW_WIDTH, <span class="hljs-number">800</span>);glSetObjectOption(GL_WINDOW_TARGET, GL_OPTION_WINDOW_HEIGHT, <span class="hljs-number">600</span>);<span class="hljs-comment">// 将上下文对象设回默认</span>glBindObject(GL_WINDOW_TARGET, <span class="hljs-number">0</span>);</code></pre><div class="note note-info">            <p>简单的理解就是像创建id,然后绑定至OpenGL中的对象，这两步也可以近似理解为实例化一个对象，然后就可以对这个对象进行操作。</p>          </div><h2 id="3-FSM"><a href="#3-FSM" class="headerlink" title="3. FSM"></a>3. FSM</h2><p>&emsp;&emsp;OpenGL的系统是一个有限状态机，因此其函数有两种，状态设置函数(State-changing Function)和状态应用函数(State-using Function)，前者改变OpenGL的状态，只有当进入相应状态，然后执行该状态下的应用函数才会起作用。</p><p>比如</p><pre><code class="hljs c++">glClearColor(<span class="hljs-number">0.2f</span>, <span class="hljs-number">0.3f</span>, <span class="hljs-number">0.3f</span>, <span class="hljs-number">1.0f</span>);<span class="hljs-comment">//rgb(范围0-1),alpha channel    状态设置函数</span>glClear(GL_COLOR_BUFFER_BIT);<span class="hljs-comment">//状态应用函数，真正应用清除颜色</span></code></pre><h2 id="4-VBO"><a href="#4-VBO" class="headerlink" title="4. VBO"></a>4. VBO</h2><p>&emsp;&emsp;顶点缓冲对象为cpu-&gt;gpu的图形的顶点数据，简而言之，通过缓冲一次传一批顶点。</p><pre><code class="hljs c++">GLuint VBO;glGenBuffers(<span class="hljs-number">1</span>, &amp;VBO);  <span class="hljs-comment">//获得VBO id</span>glBindBuffer(GL_ARRAY_BUFFER, VBO);<span class="hljs-comment">//绑定顶点缓冲  </span>glBufferData(GL_ARRAY_BUFFER, <span class="hljs-keyword">sizeof</span>(vertices), vertices, GL_STATIC_DRAW);<span class="hljs-comment">//绑定顶点数据，这一步才真正将顶点数据vertices与buffer绑定</span></code></pre><p>介绍一下第四个参数</p><ul><li><code>GL_STATIC_DRAW</code> ：数据不会或几乎不会改变。</li><li><code>GL_DYNAMIC_DRAW</code>：数据会被改变很多。</li><li><code>GL_STREAM_DRAW</code> ：数据每次绘制时都会改变。</li></ul><h2 id="5-Vertex-Shader"><a href="#5-Vertex-Shader" class="headerlink" title="5.Vertex Shader"></a>5.Vertex Shader</h2><pre><code class="hljs glsl"><span class="hljs-meta">#version 330 core //声明版本</span><span class="hljs-keyword">layout</span> (<span class="hljs-keyword">location</span> = <span class="hljs-number">0</span>) <span class="hljs-keyword">in</span> <span class="hljs-type">vec3</span> position;<span class="hljs-comment">//in关键字声明输入变量的属性，layout(location=x)为输入变量的位置</span><span class="hljs-type">void</span> main()&#123;    <span class="hljs-built_in">gl_Position</span> = <span class="hljs-type">vec4</span>(position.x, position.y, position.z, <span class="hljs-number">1.0</span>);<span class="hljs-comment">//输出给后面，因为输入的是三维向量，将其改成后面需要的齐次坐标形式</span>&#125;</code></pre><div class="note note-info">            <p>Shader 我理解为将一道完整的工序中独立出一个步骤，而这个步骤是由用户自定的，这个步骤有上一道步骤的输入，而我们可以在这里进行编程操作，只要保证输出是符合下一道步骤的输入即可。有点面向切面的味道。</p>          </div><h3 id="5-1-编译Shader"><a href="#5-1-编译Shader" class="headerlink" title="5.1.编译Shader"></a>5.1.编译Shader</h3><pre><code class="hljs c++">GLuint vertexShader;vertexShader = glCreateShader(GL_VERTEX_SHADER);<span class="hljs-comment">//创建一个shader id</span><span class="hljs-comment">//绑定shader代码，参数一次为id,shader 数量，shader代码，第四个如果不为null,它会返回源码数组相应的长度数组</span>glShaderSource(vertexShader, <span class="hljs-number">1</span>, &amp;vertexShaderSource, <span class="hljs-literal">NULL</span>);glCompileShader(vertexShader);<span class="hljs-comment">//编译</span></code></pre><h2 id="6-Fragment-Shader"><a href="#6-Fragment-Shader" class="headerlink" title="6.Fragment Shader"></a>6.Fragment Shader</h2><p>用于颜色</p><pre><code class="hljs glsl"><span class="hljs-meta">#version 330 core</span><span class="hljs-keyword">out</span> <span class="hljs-type">vec4</span> color;<span class="hljs-comment">//out 关键字声明输出该变量</span><span class="hljs-type">void</span> main()&#123;    color = <span class="hljs-type">vec4</span>(<span class="hljs-number">1.0</span>f, <span class="hljs-number">0.5</span>f, <span class="hljs-number">0.2</span>f, <span class="hljs-number">1.0</span>f);<span class="hljs-comment">//输出颜色</span>&#125;</code></pre><h3 id="6-1-编译Shader"><a href="#6-1-编译Shader" class="headerlink" title="6.1 编译Shader"></a>6.1 编译Shader</h3><pre><code class="hljs c++">GLuint fragmentShader;fragmentShader = glCreateShader(GL_FRAGMENT_SHADER);glShaderSource(fragmentShader, <span class="hljs-number">1</span>, &amp;fragmentShaderSource, null);glCompileShader(fragmentShader);</code></pre><h2 id="7-Shader-Program-Object"><a href="#7-Shader-Program-Object" class="headerlink" title="7.Shader Program Object"></a>7.Shader Program Object</h2><p>&emsp;&emsp;要使用刚才编译的着色器我们必须把它们链接为一个着色器程序对象，然后在渲染对象的时候激活这个着色器程序。已激活着色器程序的着色器将在我们发送渲染调用的时候被使用。当链接着色器至一个程序的时候，它会把每个着色器的输出链接到下个着色器的输入。当输出和输入不匹配的时候，你会得到一个连接错误。</p><pre><code class="hljs c++">GLuint shaderProgram;shaderProgram = glCreateProgram();<span class="hljs-comment">//创建一个程序对象</span>glAttachShader(shaderProgram, vertexShader);glAttachShader(shaderProgram, fragmentShader);<span class="hljs-comment">//将shader附加至Program</span>glLinkProgram(shaderProgram);<span class="hljs-comment">//将gl与该program链接，即渲染时采用这个program</span><span class="hljs-comment">//激活使用该着色器对象，调用之后，每个着色器调用和渲染调用都会使用这个程序对象</span>glUseProgram(shaderProgram);<span class="hljs-comment">//链接shader到program后别忘记删除</span>glDeleteShader(vertexShader);glDeleteShader(fragmentShader);</code></pre><h2 id="8-读取顶点（解释自定义的顶点）"><a href="#8-读取顶点（解释自定义的顶点）" class="headerlink" title="8.读取顶点（解释自定义的顶点）"></a>8.读取顶点（解释自定义的顶点）</h2><p>&emsp;&emsp;如果是自定义的顶点数据，该如何解释也是一个问题，可以使用下面的方法解决</p><pre><code class="hljs c++"><span class="hljs-comment">// 0. 复制顶点数组到缓冲中供OpenGL使用</span>glBindBuffer(GL_ARRAY_BUFFER, VBO);glBufferData(GL_ARRAY_BUFFER, <span class="hljs-keyword">sizeof</span>(vertices), vertices, GL_STATIC_DRAW);<span class="hljs-comment">// 1. 设置顶点属性指针</span>glVertexAttribPointer(<span class="hljs-number">0</span>, <span class="hljs-number">3</span>, GL_FLOAT, GL_FALSE, <span class="hljs-number">3</span> * <span class="hljs-keyword">sizeof</span>(GLfloat), (GLvoid*)<span class="hljs-number">0</span>);glEnableVertexAttribArray(<span class="hljs-number">0</span>);<span class="hljs-comment">// 2. 当我们渲染一个物体时要使用着色器程序</span>glUseProgram(shaderProgram);<span class="hljs-comment">// 3. 绘制物体</span>someOpenGLFunctionThatDrawsOurTriangle();</code></pre><p><code>glVertexAttribPointer</code>函数的参数：</p><ul><li>第一个参数指定配置的顶点属性。比如在顶点着色器中使用<code>layout(location = 0)</code>定义了position顶点属性的位置值(Location)它可以把顶点属性的位置值设置为<code>0</code>。因为我们希望把数据传递到这一个顶点属性中，所以这里传入<code>0</code>。</li><li>第二个参数指定顶点属性的大小。顶点属性是一个<code>vec3</code>，它由3个值组成，所以大小是3。</li><li>第三个参数指定数据的类型，这里是<code>GL_FLOAT</code>(GLSL中<code>vec*</code>都是由浮点数值组成的)。</li><li>第四个参数定义是否希望数据被标准化(Normalize)。如果我们设置为<code>GL_TRUE</code>，所有数据都会被映射到0（对于有符号型signed数据是-1）到1之间。它设置为GL_FALSE。</li><li>第五个参数叫做步长(Stride)，它告诉我们在连续的顶点属性组之间的间隔。由于下个组位置数据在3个<code>GLfloat</code>之后，我们把步长设置为<code>3 * sizeof(GLfloat)</code>。</li><li>最后一个参数的类型是<code>GLvoid*</code>，所以需要进行这个奇怪的强制类型转换。它表示位置数据在缓冲中起始位置的偏移量(Offset)。由于位置数据在数组的开头，所以这里是0。</li></ul><div class="note note-success">            <p>每个顶点属性从一个VBO管理的内存中获得它的数据，而具体是从哪个VBO（程序中可以有多个VBO）获取则是通过在调用<code>glVetexAttribPointer</code>时绑定到<code>GL_ARRAY_BUFFER</code>的VBO决定的。由于在调用<code>glVetexAttribPointer</code>之前绑定的是先前定义的VBO对象，顶点属性<code>0</code>现在会链接到它的顶点数据。</p>          </div><h2 id="9-VAO"><a href="#9-VAO" class="headerlink" title="9.VAO"></a>9.VAO</h2><p>&emsp;&emsp;顶点数组对象(Vertex Array Object, VAO)可以像顶点缓冲对象那样被绑定，任何随后的顶点属性调用都会储存在这个VAO中。这样的好处就是，当配置顶点属性指针时，你只需要将那些调用执行一次，之后再绘制物体的时候只需要绑定相应的VAO就行了。这使在不同顶点数据和属性配置之间切换变得非常简单，只需要绑定不同的VAO就行了。刚刚设置的所有状态都将存储在VAO中</p><pre><code class="hljs c++">GLuint VAO;glGenVertexArrays(<span class="hljs-number">1</span>, &amp;VAO); <span class="hljs-comment">//创建VAO</span><span class="hljs-comment">// ..:: 初始化代码（只运行一次 (除非你的物体频繁改变)） :: ..</span><span class="hljs-comment">// 1. 绑定VAO</span>glBindVertexArray(VAO);<span class="hljs-comment">// 2. 把顶点数组复制到缓冲中供OpenGL使用</span>glBindBuffer(GL_ARRAY_BUFFER, VBO);glBufferData(GL_ARRAY_BUFFER, <span class="hljs-keyword">sizeof</span>(vertices), vertices, GL_STATIC_DRAW);<span class="hljs-comment">// 3. 设置顶点属性指针</span>glVertexAttribPointer(<span class="hljs-number">0</span>, <span class="hljs-number">3</span>, GL_FLOAT, GL_FALSE, <span class="hljs-number">3</span> * <span class="hljs-keyword">sizeof</span>(GLfloat), (GLvoid*)<span class="hljs-number">0</span>);glEnableVertexAttribArray(<span class="hljs-number">0</span>);<span class="hljs-comment">//4. 解绑VAO,相当于买完东西后离开，这个东西自己拿去用(比如在绘制东西时再绑定上去)</span>glBindVertexArray(<span class="hljs-number">0</span>);<span class="hljs-comment">// 5. 绘制物体</span>glUseProgram(shaderProgram);<span class="hljs-comment">//使用shader渲染</span>glBindVertexArray(VAO);<span class="hljs-comment">//再绑定</span>glDrawArrays(GL_TRIANGLES, <span class="hljs-number">0</span>, <span class="hljs-number">3</span>);<span class="hljs-comment">//形状，起始点，顶点数量</span>glBindVertexArray(<span class="hljs-number">0</span>);<span class="hljs-comment">//解绑</span></code></pre><p>&emsp;&emsp;流程是：打算绘制多个物体时，首先要生成/配置所有的VAO（和必须的VBO及属性指针)，然后储存它们供后面使用。当要绘制物体的时候就拿出相应的VAO，绑定它，绘制完物体后，再解绑VAO。</p><h2 id="10-EBO"><a href="#10-EBO" class="headerlink" title="10.EBO"></a>10.EBO</h2><p>&emsp;&emsp;索引缓冲对象，通过索引来重用顶点。</p><pre><code class="hljs c++">glDrawArrays(GL_TRIANGLES, <span class="hljs-number">0</span>, <span class="hljs-number">3</span>);GLuint EBO;glGenBuffers(<span class="hljs-number">1</span>, &amp;EBO);<span class="hljs-comment">//创建对象id</span>glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, EBO);glBufferData(GL_ELEMENT_ARRAY_BUFFER,<span class="hljs-keyword">sizeof</span>(indices),indices,GL_STATIC_DRAW); <span class="hljs-comment">//绑定索引</span><span class="hljs-comment">//此时，绘制方法改变，即不再使用glDrawArrays</span>glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, EBO);<span class="hljs-comment">//绑定EBO</span>glDrawElements(GL_TRIANGLES, <span class="hljs-number">6</span>, GL_UNSIGNED_INT, <span class="hljs-number">0</span>);<span class="hljs-comment">//通过索引方法来绘制，形状，顶点数，索引类型，EBO偏移量</span></code></pre><h2 id="11-线框模式"><a href="#11-线框模式" class="headerlink" title="11.线框模式"></a>11.线框模式</h2><p>&emsp;&emsp;要想用线框模式绘制你的三角形，可以通过<code>glPolygonMode(GL_FRONT_AND_BACK, GL_LINE)</code>函数配置OpenGL如何绘制图元。第一个参数表示将其应用到所有的三角形的正面和背面，第二个参数表示用线来绘制。之后的绘制调用会一直以线框模式绘制三角形，直到我们用<code>glPolygonMode(GL_FRONT_AND_BACK, GL_FILL)</code>将其设置回默认模式。</p><h2 id="12-总结"><a href="#12-总结" class="headerlink" title="12.总结"></a>12.总结</h2><p>&emsp;&emsp;在绑定VAO时如果绑定了EBO，VAO也会存储索引。当目标是<code>GL_ELEMENT_ARRAY_BUFFER</code>的时候，VAO会储存<code>glBindBuffer</code>的函数调用。这也意味着它也会储存解绑调用，所以确保你没有在解绑VAO之前解绑索引数组缓冲，否则它就没有这个EBO配置了。</p><pre><code class="hljs c++"><span class="hljs-comment">// ..:: 初始化代码 :: ..</span><span class="hljs-comment">// 1. 绑定顶点数组对象</span>glBindVertexArray(VAO);<span class="hljs-comment">// 2. 把我们的顶点数组复制到一个顶点缓冲中，供OpenGL使用</span>glBindBuffer(GL_ARRAY_BUFFER, VBO);glBufferData(GL_ARRAY_BUFFER, <span class="hljs-keyword">sizeof</span>(vertices), vertices, GL_STATIC_DRAW);<span class="hljs-comment">// 3. 复制索引数组到一个索引缓冲中，供OpenGL使用</span>glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, EBO);glBufferData(GL_ELEMENT_ARRAY_BUFFER, <span class="hljs-keyword">sizeof</span>(indices), indices, GL_STATIC_DRAW);<span class="hljs-comment">// 3. 设定顶点属性指针</span>glVertexAttribPointer(<span class="hljs-number">0</span>, <span class="hljs-number">3</span>, GL_FLOAT, GL_FALSE, <span class="hljs-number">3</span> * <span class="hljs-keyword">sizeof</span>(GLfloat), (GLvoid*)<span class="hljs-number">0</span>);glEnableVertexAttribArray(<span class="hljs-number">0</span>);<span class="hljs-comment">// 4. 解绑VAO(不是EBO!)</span>glBindVertexArray(<span class="hljs-number">0</span>);<span class="hljs-comment">//...</span><span class="hljs-comment">// ..:: 绘制代码（游戏循环中） :: ..</span>glUseProgram(shaderProgram);glBindVertexArray(VAO);glDrawElements(GL_TRIANGLES, <span class="hljs-number">6</span>, GL_UNSIGNED_INT, <span class="hljs-number">0</span>)glBindVertexArray(<span class="hljs-number">0</span>);</code></pre>]]></content>
    
    
    <categories>
      
      <category>OpenGL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OpenGL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>VS项目配置项说明</title>
    <link href="/2020/06/28/2020-06-28-VS%E9%A1%B9%E7%9B%AE%E9%85%8D%E7%BD%AE%E9%A1%B9%E8%AF%B4%E6%98%8E/"/>
    <url>/2020/06/28/2020-06-28-VS%E9%A1%B9%E7%9B%AE%E9%85%8D%E7%BD%AE%E9%A1%B9%E8%AF%B4%E6%98%8E/</url>
    
    <content type="html"><![CDATA[<p>​        记录一下vs配置时项目的属性设置，主要是引入三方库时需要用到，不同于cmake这种通过配置文件来操作的，感觉vs这种通过鼠标来设置又蠢又麻烦。。。</p><ul><li>VC++目录：<ul><li>可执行目录：寻找依赖的可执行的文件的目录</li><li>包含目录：寻找#include<xxxx.h>中的xxxx.h的搜索目录</li><li>库目录：寻找.lib文件的搜索目录</li></ul></li><li><p>C/C++:</p><ul><li>常规-&gt;附加包含目录：寻找#include<xxxx.h>中的xxxx.h的搜索目录（每一项对应一个文件夹XXXX，文件夹中包含了编译时所需的头文件，使用时直接#include<XXXX>即可）</li></ul></li><li><p>链接器：</p><ul><li>常规-&gt;附加库目录：寻找.lib文件的搜索目录</li><li>输入-&gt;附加依赖项：lib库（C++的库会把函数、类的声明放在*.h中，实现放在*.cpp或* .cc中。编译之后，*.cpp，*.cc，*.c会被打包成一个.lib文件，这样可以保护源代码）</li></ul></li></ul><p>最终方法为:</p><ol><li>附加包含目录—-添加工程的头文件目录：   项目-&gt;属性-&gt;配置属性-&gt;C/C++-&gt;常规-&gt;附加包含目录：加上头文件的存放目录； </li><li>附加库目录—-添加文件引用的lib静态库路径：   项目-&gt;属性-&gt;配置属性-&gt;链接器-&gt;常规-&gt;附加库目录：加上lib文件的存放目录； </li><li>附加依赖项—-添加工程引用的lib文件名：   项目-&gt;属性-&gt;配置属性-&gt;链接器-&gt;输入-&gt;附加依赖项：加上lib文件名。</li></ol><p>​        <strong>ps</strong>:包含目录：修改了系统的include宏的值，是全局的； 附加包含目录：用于当前项目，对其他项目没有影响。</p><img src="/2020/06/28/2020-06-28-VS%E9%A1%B9%E7%9B%AE%E9%85%8D%E7%BD%AE%E9%A1%B9%E8%AF%B4%E6%98%8E/image-20200628225451830.png" srcset="/img/loading.gif" class="" title="image-20200628225451830"><img src="/2020/06/28/2020-06-28-VS%E9%A1%B9%E7%9B%AE%E9%85%8D%E7%BD%AE%E9%A1%B9%E8%AF%B4%E6%98%8E/image-20200628225507115.png" srcset="/img/loading.gif" class="" title="image-20200628225507115"><img src="/2020/06/28/2020-06-28-VS%E9%A1%B9%E7%9B%AE%E9%85%8D%E7%BD%AE%E9%A1%B9%E8%AF%B4%E6%98%8E/image-20200628225519543.png" srcset="/img/loading.gif" class="" title="image-20200628225519543"><img src="/2020/06/28/2020-06-28-VS%E9%A1%B9%E7%9B%AE%E9%85%8D%E7%BD%AE%E9%A1%B9%E8%AF%B4%E6%98%8E/image-20200628225540868.png" srcset="/img/loading.gif" class="" title="image-20200628225540868"><p><a href="https://blog.csdn.net/raodotcong/article/details/8998379" target="_blank" rel="noopener">更详细的文章</a></p>]]></content>
    
    
    <categories>
      
      <category>配置</category>
      
    </categories>
    
    
    <tags>
      
      <tag>配置</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Blinn-Phong Reflectance Model</title>
    <link href="/2020/06/17/2020-06-17-Blinn-Phong-Reflectance-Model/"/>
    <url>/2020/06/17/2020-06-17-Blinn-Phong-Reflectance-Model/</url>
    
    <content type="html"><![CDATA[<h2 id="光照模型"><a href="#光照模型" class="headerlink" title="光照模型"></a>光照模型</h2><script type="math/tex; mode=display">L=L_d+L_s+L_a</script><p>$L_d$为漫反射光，$L_s$为高光，$L_a$为环境光。</p><h3 id="1-漫反射"><a href="#1-漫反射" class="headerlink" title="1.漫反射"></a>1.漫反射</h3><p>理解：漫反射散向四面八方，与观察方向无关，只与表面接受到的光源的<strong>有效光</strong>有关</p><script type="math/tex; mode=display">L_d=k_d\frac{I}{r^2}max\{0,n\cdot l\}</script><p>$k_d$漫反射系数(范围0至1，表明反射的强度)，$I$光源,$r$表面距光源距离，$n$表明法向量，$l$入射光向量(注意方向为负)</p><p>ps:均为单位向量</p><h3 id="2-高光"><a href="#2-高光" class="headerlink" title="2.高光"></a>2.高光</h3><p>相比于Phong模型，Blinn-Phong模型的高光项采用$l,v$两者的角平分线与$n$的夹角来表示观察方向与镜面反射方向的夹角，从而提高计算效率。</p><script type="math/tex; mode=display">L_s=k_s\frac{I}{r^2}max\{0,n\cdot h\}^p</script><p>$k_s$镜面反射系数(范围0至1，表明反射的强度)，$I$光源,$r$表面距光源距离，$n$表明法向量，$h=\frac{l+v}{|l+v|}$,$p$表示角度的影响，因为高光只在小角度才会起作用，下面是$cos^px$的几个变化图</p><h3 id="3-环境光"><a href="#3-环境光" class="headerlink" title="3.环境光"></a>3.环境光</h3><p>在Blinn-Phong模型中环境光被当作常数处理</p><script type="math/tex; mode=display">L_a=k_aI_a</script><h3 id="4-展示"><a href="#4-展示" class="headerlink" title="4. 展示"></a>4. 展示</h3>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>旋转变换矩阵推导</title>
    <link href="/2020/06/06/2020-06-06-%E6%97%8B%E8%BD%AC%E5%8F%98%E6%8D%A2%E7%9F%A9%E9%98%B5%E6%8E%A8%E5%AF%BC/"/>
    <url>/2020/06/06/2020-06-06-%E6%97%8B%E8%BD%AC%E5%8F%98%E6%8D%A2%E7%9F%A9%E9%98%B5%E6%8E%A8%E5%AF%BC/</url>
    
    <content type="html"><![CDATA[<p>​        </p><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>&emsp;&emsp;先介绍二维旋转变换，然后由此推广到三维绕坐标轴旋转，再推广得到绕三维任意轴旋转的罗德里格斯旋转公式。</p><h2 id="1-二维"><a href="#1-二维" class="headerlink" title="1.二维"></a>1.二维</h2><p>&emsp;&emsp;如果要求$P$逆时针旋转$\theta$得到的$P^{‘}$，记$Q$为$P$逆时针旋转90°后的向量,即$(-P_y,P_x)$,则$P$与$Q$正好组成了<strong>该平面内的一组正交向量</strong>，任何向量都可由其线性表出，由基本几何和三角学可得到：</p><script type="math/tex; mode=display">P^{'}=Pcos\theta+Qsin\theta</script><p>则</p><script type="math/tex; mode=display">\begin{aligned}P_x^{'}&=P_xcos\theta-P_ysin\theta\\P_{y}^{'}&=P_ysin\theta-P_xcos\theta\\\end{aligned}</script><p>写成矩阵为</p><script type="math/tex; mode=display">P^{'}=\begin{bmatrix}cos\theta&-sin\theta\\sin\theta&cos\theta\end{bmatrix}P</script><h2 id="2-三维绕坐标轴旋转"><a href="#2-三维绕坐标轴旋转" class="headerlink" title="2.三维绕坐标轴旋转"></a>2.三维绕坐标轴旋转</h2><img src="/2020/06/06/2020-06-06-%E6%97%8B%E8%BD%AC%E5%8F%98%E6%8D%A2%E7%9F%A9%E9%98%B5%E6%8E%A8%E5%AF%BC/image-20200606172922405.png" srcset="/img/loading.gif" class=""><p>&emsp;&emsp;注意$R_y(\theta)$与其他不同是因为如果按照逆时针旋转，由$x\times z=-y$,则得到$y$轴负方向，因此需改为顺时针，即$-\theta$,这无论是在左手坐标系还是右手系都是相同的。</p><h2 id="3-三维绕任意轴旋转"><a href="#3-三维绕任意轴旋转" class="headerlink" title="3. 三维绕任意轴旋转"></a>3. 三维绕任意轴旋转</h2><p><strong>向量$P$绕任意轴$A$旋转$\theta$角度证明：</strong></p><p>&emsp;&emsp;不妨设$A$为单位向量，同时$P$可分解为与$A$平行和垂直的两个分量，分别为：</p><script type="math/tex; mode=display">\begin{align}P_{projA}&=(A\cdot P)A=AA^TP\\P_{perpA}&=P-(A\cdot P)A=P-AA^TP\end{align}</script><p>如图所示</p><img src="/2020/06/06/2020-06-06-%E6%97%8B%E8%BD%AC%E5%8F%98%E6%8D%A2%E7%9F%A9%E9%98%B5%E6%8E%A8%E5%AF%BC/image-20200606161620614.png" srcset="/img/loading.gif" class=""><p>故最终结果</p><script type="math/tex; mode=display">P^{'}=P_{perpA}^{'}+P_{ProjA}</script><p>其中<script type="math/tex">P_{PerpA}^{'}</script>为<script type="math/tex">P_{perpA}</script>旋转<script type="math/tex">\theta</script>后得到的向量，如图</p><img src="/2020/06/06/2020-06-06-%E6%97%8B%E8%BD%AC%E5%8F%98%E6%8D%A2%E7%9F%A9%E9%98%B5%E6%8E%A8%E5%AF%BC/image-20200606161747676.png" srcset="/img/loading.gif" class=""><p>为求得其值，需找到一组线性组合来表示它，可选<script type="math/tex">P_{perpA}</script>与其旋转90°后的向量这两个向量作为组合，可以得知<script type="math/tex">A\times P</script>即为该向量，同时它的长度是与<script type="math/tex">P_{perpA}</script>相等的，这是因为</p><script type="math/tex; mode=display">|A\times P|=|P|sin\alpha=|P-(A\cdot P)A|</script><p>所以</p><script type="math/tex; mode=display">P_{perpA}^{'}=[P-(A\cdot P)A]cos\theta+(A \times P)sin \theta</script><p>所以</p><script type="math/tex; mode=display">\begin{align}P^{'}&=[P-(A\cdot P)A]cos\theta+(A \times P)sin \theta+(A\cdot P)A\\&=Pcos\theta+A\times P sin\theta+(A\cdot P)A(1-cos\theta)\end{align}</script><p>记$I$为单位阵，则矩阵形式为</p><script type="math/tex; mode=display">P^{'}=\{Icos\theta+\begin{bmatrix} 0&-A_z&A_y\\A_z&0&-A_x\\-A_y&A_x&0\end{bmatrix}sin\theta+AA^T(1-cos\theta)\}P</script><p>其中记</p><script type="math/tex; mode=display">R=Icos\theta+\begin{bmatrix} 0&-A_z&A_y\\A_z&0&-A_x\\-A_y&A_x&0\end{bmatrix}sin\theta+AA^T(1-cos\theta)</script><p>为罗德里格斯旋转公式，而将其展开写成一个矩阵就可得到旋转矩阵。</p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Lagrange插值法与Newton插值法</title>
    <link href="/2020/05/30/Lagrange%E6%8F%92%E5%80%BC%E6%B3%95%E4%B8%8ENewton%E6%8F%92%E5%80%BC%E6%B3%95/"/>
    <url>/2020/05/30/Lagrange%E6%8F%92%E5%80%BC%E6%B3%95%E4%B8%8ENewton%E6%8F%92%E5%80%BC%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h2 id="Lagrange插值法"><a href="#Lagrange插值法" class="headerlink" title="Lagrange插值法"></a>Lagrange插值法</h2><p>​        考虑有$n$个<strong>不同的点</strong> <script type="math/tex">(x_1,y_1),(x_2,y_2),(x_i,y_i)\dots (x_n,y_n)</script> , 定义函数<script type="math/tex">f_i(x)</script>满足在<script type="math/tex">l_i(x_j)</script>满足克罗内克符号函数 <script type="math/tex">\delta_{ij}</script>，</p><script type="math/tex; mode=display">l_i(x_j)=\delta_{ij}=\begin{cases}1\quad\quad\quad i=j\\0\quad\quad\quad i\not=j\end{cases}</script><p>此时，若另</p><script type="math/tex; mode=display">L(x)=\sum_{i=1}^n y_il_i(x)</script><p>则对于任意$x_i$有</p><script type="math/tex; mode=display">y_i=l_i(x_i)</script><p>即$n$个点必然经过$L(x)$,即为所求。</p><p>​        再考虑$l_i(x)$,其应为一个<strong>$n-1$次多项式</strong>,则可由因式法写出满足要求的函数:</p><script type="math/tex; mode=display">\begin{align}l_i(x)&=\frac{(x-x_1)(x-x_2)(x-x_3)\dots(x-x_{i-1})(x-x_{i+1})\dots(x_i-x_n)}{(x_i-x_1)(x_i-x_2)(x_i-x_3)\dots(x_i-x_{i-1})(x_i-x_{i+1})\dots(x_i-x_n)}\\\\&=\prod_{j\not=i}^{ 1\le j\le n }\frac{x-x_j}{x_i-x_j}\end{align}</script><p>这里的$l_i(x)$称为插值基函数。</p><p>​        以下是代码实现</p><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><span class="hljs-keyword">float</span> x[<span class="hljs-number">7</span>] = &#123;<span class="hljs-number">1.20</span>, <span class="hljs-number">1.24</span>, <span class="hljs-number">1.28</span>, <span class="hljs-number">1.32</span>, <span class="hljs-number">1.36</span>, <span class="hljs-number">1.40</span>&#125;;<span class="hljs-keyword">float</span> y1[<span class="hljs-number">7</span>] = &#123;<span class="hljs-number">1.09545</span>, <span class="hljs-number">1.11355</span>, <span class="hljs-number">1.13137</span>,<span class="hljs-number">1.14891</span>, <span class="hljs-number">1.16619</span>, <span class="hljs-number">1.18322</span>&#125;;<span class="hljs-keyword">float</span> y2[<span class="hljs-number">7</span>] = &#123;<span class="hljs-number">0.07918</span>, <span class="hljs-number">0.09342</span>, <span class="hljs-number">0.10721</span>, <span class="hljs-number">0.12057</span>, <span class="hljs-number">0.13354</span>, <span class="hljs-number">0.14613</span>&#125;;<span class="hljs-keyword">float</span> xi[<span class="hljs-number">6</span>] = &#123;<span class="hljs-number">1.22</span>, <span class="hljs-number">1.26</span>, <span class="hljs-number">1.30</span>, <span class="hljs-number">1.34</span>, <span class="hljs-number">1.38</span>&#125;;<span class="hljs-function"><span class="hljs-keyword">float</span> <span class="hljs-title">Lagrange</span><span class="hljs-params">(<span class="hljs-keyword">float</span> *y,<span class="hljs-keyword">float</span> cx)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> n=<span class="hljs-number">6</span>;    <span class="hljs-keyword">float</span> temp[<span class="hljs-number">10</span>],ans=<span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)    &#123;        temp[i] = y[i];        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;n;j++)        <span class="hljs-keyword">if</span>(j!=i)            temp[i] *= (cx - x[j]) / (x[i] - x[j]);        ans += temp[i];    &#125;    <span class="hljs-keyword">return</span> ans;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>;i++)        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"当x=%.2f,y1=%.5f,y2=%.5f\n"</span>, xi[i], Lagrange(y1,xi[i]),Lagrange(y2,xi[i]));    system(<span class="hljs-string">"pause"</span>);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p>​        我们可以发现假如新加入一个点,就必须得重新计算,这是它的缺点.</p><h2 id="Newton插值法"><a href="#Newton插值法" class="headerlink" title="Newton插值法"></a>Newton插值法</h2><p>​        该方法确定了一组新的基函数,确保能加入新的点能够重用之前的计算结果:</p><script type="math/tex; mode=display">\begin{aligned}        \phi_{1}(x) &=1 \\\phi_{2}(x) &=\left(x-x_{1}\right) \\\phi_{3}(x) &=\left(x-x_{1}\right)\left(x-x_{2}\right) \\\cdots &=\cdots \\\phi_{n+1}(x) &=\prod_{i=1}^{n}\left(x-x_{i}\right)\end{aligned}</script><p>可以看到由于<script type="math/tex">\phi_{n+1}(x)=\phi_{n}(x)(x-x_{n})</script>,因此可以重用之前的结果。</p><p>则最终的多项式为:</p><script type="math/tex; mode=display">N(x)=\sum_{i=1}^{n+1}a_i\phi_i(x)</script><p>现在仅仅需要确定$a_i$的值就可以确定$N(x)$。</p><p>​        我们将每个点依次带入相减可得到一个神奇的规律：</p><script type="math/tex; mode=display">\begin{aligned}a_1&=y_1\\a_2&=\frac{y_2-y_1}{x_2-x_1}\\a_3&=\frac{\frac{y_3-y_2}{x_3-x_2}-\frac{y_2-y_1}{x_2-x_1}}{x_3-x_1}\\\vdots\end{aligned}</script><p>我们把这种叫做<strong>差商</strong>,0阶均差定义为$f[x_i]=f(x_i)$,$n-1$阶差商为：</p><script type="math/tex; mode=display">f[x_1,x_2,x_3\dots x_n]=\frac{f[x_1,x_2,x_3\dots x_{n-1}]-f[x_2,x_3,x_4\dots x_n]}{x_n-x_1}</script><p>下面是差商表,每次迭代也可重用上一步的结果</p><p>所以最终为</p><script type="math/tex; mode=display">\begin{aligned}N(x)=& f\left(x_{1}\right)+\\& f\left[x_{1}, x_{2}\right]\left(x-x_{1}\right)+\\& f\left[x_{1}, x_{2}, x_{3}\right]\left(x-x_{1}\right)\left(x-x_{2}\right)+\\& f\left[x_{1}, \ldots, x_{4}\right]\left(x-x_{1}\right)\left(x-x_{2}\right)\left(x-x_{3}\right)+\\& \ldots\end{aligned}</script><p>以下是代码,可想而知，虽然Newton插值效率提高了，但是也要多出一部分来计算差商</p><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">float</span> x[<span class="hljs-number">7</span>] = &#123;<span class="hljs-number">1.20</span>, <span class="hljs-number">1.24</span>, <span class="hljs-number">1.28</span>, <span class="hljs-number">1.32</span>, <span class="hljs-number">1.36</span>, <span class="hljs-number">1.40</span>&#125;;<span class="hljs-keyword">float</span> y1[<span class="hljs-number">7</span>] = &#123;<span class="hljs-number">1.09545</span>, <span class="hljs-number">1.11355</span>, <span class="hljs-number">1.13137</span>,<span class="hljs-number">1.14891</span>, <span class="hljs-number">1.16619</span>, <span class="hljs-number">1.18322</span>&#125;;<span class="hljs-keyword">float</span> y2[<span class="hljs-number">7</span>] = &#123;<span class="hljs-number">0.07918</span>, <span class="hljs-number">0.09342</span>, <span class="hljs-number">0.10721</span>, <span class="hljs-number">0.12057</span>, <span class="hljs-number">0.13354</span>, <span class="hljs-number">0.14613</span>&#125;;<span class="hljs-keyword">float</span> xi[<span class="hljs-number">6</span>] = &#123;<span class="hljs-number">1.22</span>, <span class="hljs-number">1.26</span>, <span class="hljs-number">1.30</span>, <span class="hljs-number">1.34</span>, <span class="hljs-number">1.38</span>&#125;;<span class="hljs-keyword">float</span> diff[<span class="hljs-number">10</span>][<span class="hljs-number">10</span>];<span class="hljs-comment">//差商值表</span><span class="hljs-keyword">float</span> phi[<span class="hljs-number">10</span>];<span class="hljs-comment">//基函数值</span><span class="hljs-keyword">int</span> n=<span class="hljs-number">6</span>;<span class="hljs-comment">//求差商表，有点像动态规划</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">DifferenceQuotient</span><span class="hljs-params">(<span class="hljs-keyword">float</span> *y)</span></span><span class="hljs-function"></span>&#123;  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n;i++)    diff[i][<span class="hljs-number">0</span>] = y[i];      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; n;i++)  &#123;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span> ; j &lt; i+<span class="hljs-number">1</span>;j++)      diff[i][j] = (diff[i][j - <span class="hljs-number">1</span>] - diff[i<span class="hljs-number">-1</span>][j - <span class="hljs-number">1</span>]) / (x[i] - x[i-j]);  &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">float</span> <span class="hljs-title">Newton</span><span class="hljs-params">(<span class="hljs-keyword">float</span> *y,<span class="hljs-keyword">float</span> cx)</span></span><span class="hljs-function"></span>&#123;  phi[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;  <span class="hljs-keyword">float</span> ans = <span class="hljs-number">0</span>;  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; n;i++) <span class="hljs-comment">//其基函数的值</span>    phi[i] = phi[i<span class="hljs-number">-1</span>]*(cx - x[i<span class="hljs-number">-1</span>]);    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n;i++)    ans += phi[i] * diff[i][i];<span class="hljs-comment">//多项式求和为最终结果</span>    <span class="hljs-keyword">return</span> ans;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;  DifferenceQuotient(y1);  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>;i++)        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"当x=%.2f,y1=%.5f\n"</span>, xi[i], Newton(y1,xi[i]));  <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-built_in">endl</span>;  DifferenceQuotient(y2);  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>;i++)        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"当x=%.2f,y2=%.5f\n"</span>, xi[i],Newton(y2,xi[i]));  system(<span class="hljs-string">"pause"</span>);&#125;</code></pre><p>​        如果要新增节点，可以增量更新差商表</p><h2 id="两者关系"><a href="#两者关系" class="headerlink" title="两者关系"></a>两者关系</h2><p>​        其实我们可以发现两个方法都是通过$n$个点确定了一组$n$个方程的方程组:</p><script type="math/tex; mode=display">\begin{cases}y_1&=a_0+a_1x_1+a_2x_1^2+\dots+a_nx_1^n\\y_2&=a_0+a_1x_2+a_2x_2^2+\dots+a_nx_2^n\\\vdots\\y_n&=a_0+a_1x_n+a_2x_n^2+\dots+a_nx_n^n\\\end{cases}</script><p>矩阵形式为$Y=XA$</p><script type="math/tex; mode=display">\begin{bmatrix} y_1\\y_2\\ \vdots \\y_n\end{bmatrix}=\begin{bmatrix} 1&x_1&x_1^2&\dots&x_1^n\\1&x_2&x_2^2&\dots&x_2^n\\ \vdots&\vdots&\vdots&\dots&\vdots\\1&x_n&x_n^2&\dots&x_n^n\end{bmatrix}\begin{bmatrix} a_0\\a_1\\ \vdots \\a_n\end{bmatrix}</script><p>系数矩阵$X$为范德蒙行列式,则$|X|\not =0$,因此可以得出其解$A$唯一,故最终确定的多项式唯一,即两者等效.Largrane法较为简单，而Newton法在需要新增节点时可以保持很好的效率。</p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>打家劫舍</title>
    <link href="/2020/05/29/%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D/"/>
    <url>/2020/05/29/%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D/</url>
    
    <content type="html"><![CDATA[<h2 id="LeetCode-198-打家劫舍"><a href="#LeetCode-198-打家劫舍" class="headerlink" title="LeetCode 198 打家劫舍"></a>LeetCode 198 <a href="https://leetcode-cn.com/problems/house-robber/" target="_blank" rel="noopener">打家劫舍</a></h2><p>​        你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。</p><p>给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。</p><pre><code class="hljs plain">输入: [2,7,9,3,1]输出: 12解释: 偷窃 1 号房屋 (金额 &#x3D; 2), 偷窃 3 号房屋 (金额 &#x3D; 9)，接着偷窃 5 号房屋 (金额 &#x3D; 1)。     偷窃到的最高金额 &#x3D; 2 + 9 + 1 &#x3D; 12 。</code></pre><p>​        动态规划，自然而然想到每个房子有两种状态偷与不偷：偷的话只能是最走到<strong>前前一个房子是偷盗的金额总和</strong>加上当前房子金额，不偷的话就是等于走到<strong>前一个房子时偷到的金额总和</strong>，定义$dp[i]$为$nums[0…i]$的能偷到的最高金额，则转移方程为</p><script type="math/tex; mode=display">dp[i]=\begin{cases}          max(dp[i-1],dp[i-2]+nums[i])      \quad\quad\quad\quad\quad &i\in[ 2,j]\\        nums[0]   &i=0\\        max(nums[0],nums[1])  &i=1\end{cases}</script><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">rob</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;        <span class="hljs-keyword">if</span>(nums.<span class="hljs-built_in">size</span>()==<span class="hljs-number">0</span>)<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        <span class="hljs-keyword">if</span>(nums.<span class="hljs-built_in">size</span>()==<span class="hljs-number">1</span>)<span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>];<span class="hljs-comment">//边界情况</span>        <span class="hljs-keyword">int</span> dp[<span class="hljs-number">1000</span>]=&#123;<span class="hljs-number">0</span>&#125;;        dp[<span class="hljs-number">0</span>]=nums[<span class="hljs-number">0</span>];        dp[<span class="hljs-number">1</span>]=<span class="hljs-built_in">max</span>(nums[<span class="hljs-number">0</span>],nums[<span class="hljs-number">1</span>]);        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">2</span>;i&lt;nums.<span class="hljs-built_in">size</span>();i++)        &#123;            dp[i]=<span class="hljs-built_in">max</span>(dp[i<span class="hljs-number">-2</span>]+nums[i],dp[i<span class="hljs-number">-1</span>]);        &#125;        <span class="hljs-keyword">return</span> dp[nums.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>];    &#125;&#125;;</code></pre>]]></content>
    
    
    <categories>
      
      <category>习题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>习题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCodeのTree</title>
    <link href="/2020/05/26/Tree/"/>
    <url>/2020/05/26/Tree/</url>
    
    <content type="html"><![CDATA[<h1 id="关于树"><a href="#关于树" class="headerlink" title="关于树"></a>关于树</h1><h2 id="简单"><a href="#简单" class="headerlink" title="简单"></a>简单</h2><h3 id="100-相同的树"><a href="#100-相同的树" class="headerlink" title="100 相同的树"></a>100 <a href="https://leetcode-cn.com/problems/same-tree/" target="_blank" rel="noopener">相同的树</a></h3><p>给定两个二叉树，编写一个函数来检验它们是否相同。</p><p>如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。</p><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isSameTree</span><span class="hljs-params">(TreeNode* p, TreeNode* q)</span> </span>&#123;        <span class="hljs-keyword">if</span>(!p&amp;&amp;!q)<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; <span class="hljs-comment">//都为空返回true</span>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(p&amp;&amp;q&amp;&amp;p-&gt;val==q-&gt;val)<span class="hljs-comment">//相等往下做判断</span>        <span class="hljs-keyword">return</span> isSameTree(p-&gt;left,q-&gt;left)&amp;&amp;isSameTree(p-&gt;right,q-&gt;right);        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;    &#125;&#125;;</code></pre><h3 id="101-对称二叉树"><a href="#101-对称二叉树" class="headerlink" title="101 对称二叉树"></a>101 <a href="https://leetcode-cn.com/problems/symmetric-tree/" target="_blank" rel="noopener">对称二叉树</a></h3><p>给定一个二叉树，检查它是否是镜像对称的。</p><p>上题的引申</p><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isSymmetric</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;        <span class="hljs-keyword">return</span> judge(root,root);    &#125;    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">judge</span><span class="hljs-params">(TreeNode* p,TreeNode* q)</span></span><span class="hljs-function">    </span>&#123;            <span class="hljs-keyword">if</span>(!p&amp;&amp;!q)<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(p&amp;&amp;q&amp;&amp;p-&gt;val==q-&gt;val)            <span class="hljs-keyword">return</span> judge(p-&gt;left,q-&gt;right)&amp;&amp;judge(p-&gt;right,q-&gt;left);            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;    &#125;&#125;;</code></pre><h3 id="104-二叉树的最大深度"><a href="#104-二叉树的最大深度" class="headerlink" title="104 二叉树的最大深度"></a>104 <a href="https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/" target="_blank" rel="noopener">二叉树的最大深度</a></h3><p>给定一个二叉树，找出其最大深度。</p><p>二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。</p><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">maxDepth</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;        <span class="hljs-keyword">if</span>(!root)<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(maxDepth(root-&gt;left),maxDepth(root-&gt;right))+<span class="hljs-number">1</span>;<span class="hljs-comment">//返回左右最大值    </span>    &#125;&#125;;</code></pre><h2 id="中等"><a href="#中等" class="headerlink" title="中等"></a>中等</h2><h3 id="94-二叉树的中序遍历"><a href="#94-二叉树的中序遍历" class="headerlink" title="94 二叉树的中序遍历"></a>94 <a href="https://leetcode-cn.com/problems/binary-tree-inorder-traversal/" target="_blank" rel="noopener">二叉树的中序遍历</a></h3><p>非递归方法</p><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">inorderTraversal</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;        <span class="hljs-built_in">stack</span>&lt;TreeNode*&gt;s;        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; ans;        <span class="hljs-keyword">while</span>(!s.empty()||root)        &#123;            <span class="hljs-keyword">if</span>(root)            &#123;                s.push(root);                root=root-&gt;left;            &#125;            <span class="hljs-keyword">else</span>            &#123;                TreeNode* temp=s.top();                s.pop();                ans.push_back(temp-&gt;val);                root=temp-&gt;right;            &#125;        &#125;        <span class="hljs-keyword">return</span> ans;    &#125;&#125;;</code></pre><h3 id="105-从前序与中序遍历序列构造二叉树"><a href="#105-从前序与中序遍历序列构造二叉树" class="headerlink" title="105 从前序与中序遍历序列构造二叉树"></a>105 <a href="https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/" target="_blank" rel="noopener">从前序与中序遍历序列构造二叉树</a></h3><p>递归构造，常规。</p><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function">TreeNode* <span class="hljs-title">build</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; pre,<span class="hljs-keyword">int</span> ps,<span class="hljs-keyword">int</span> pe, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; inorder,<span class="hljs-keyword">int</span> is,<span class="hljs-keyword">int</span> ie)</span></span><span class="hljs-function">    </span>&#123;        <span class="hljs-keyword">if</span>(ps&gt;pe||is&gt;ie)<span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;        TreeNode* t=<span class="hljs-keyword">new</span> TreeNode();        t-&gt;val=pre[ps];        <span class="hljs-keyword">int</span> k=is;        <span class="hljs-keyword">while</span>(is&lt;ie&amp;&amp;inorder[k]!=t-&gt;val)k++;<span class="hljs-comment">//寻找中序中的头节点</span>        t-&gt;left=build(pre,ps+<span class="hljs-number">1</span>,ps+k-is,inorder,is,k<span class="hljs-number">-1</span>);<span class="hljs-comment">//构造左子树</span>        t-&gt;right=build(pre,ps+k-is+<span class="hljs-number">1</span>,pe,inorder,k+<span class="hljs-number">1</span>,ie);<span class="hljs-comment">//构造右子树</span>        <span class="hljs-keyword">return</span> t;    &#125;    <span class="hljs-function">TreeNode* <span class="hljs-title">buildTree</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; preorder, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; inorder)</span> </span>&#123;        <span class="hljs-keyword">return</span> build(preorder,<span class="hljs-number">0</span>,preorder.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>,inorder,<span class="hljs-number">0</span>,inorder.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>);    &#125;&#125;;</code></pre><h2 id="困难"><a href="#困难" class="headerlink" title="困难"></a>困难</h2>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>习题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>通过可逆运算交换变量的值</title>
    <link href="/2020/05/23/%E9%80%9A%E8%BF%87%E5%8F%AF%E9%80%86%E8%BF%90%E7%AE%97%E4%BA%A4%E6%8D%A2%E5%8F%98%E9%87%8F%E7%9A%84%E5%80%BC/"/>
    <url>/2020/05/23/%E9%80%9A%E8%BF%87%E5%8F%AF%E9%80%86%E8%BF%90%E7%AE%97%E4%BA%A4%E6%8D%A2%E5%8F%98%E9%87%8F%E7%9A%84%E5%80%BC/</url>
    
    <content type="html"><![CDATA[<h1 id="通过可逆运算交换变量的值"><a href="#通过可逆运算交换变量的值" class="headerlink" title="通过可逆运算交换变量的值"></a>通过可逆运算交换变量的值</h1><h3 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1 介绍"></a>1 介绍</h3><p>​        交换两个变量的值除了引入临时变量，还有通过加减或异或等奇淫技巧来完成，现在来介绍其原理并且推广它们。</p><h2 id="2-交换的原理"><a href="#2-交换的原理" class="headerlink" title="2 交换的原理"></a>2 交换的原理</h2><p>​        加减、异或都是可逆运算，现在定义一种可逆运算规则$f$,它的逆运算是$f^{-1}$，不妨设$f(a,b)=c$,则有$f^{-1}(c,a)=b$，则有如下推导,注意我用<code>:=</code>来表示赋值：</p><script type="math/tex; mode=display">\begin{align}a& :=f(a,b)  \tag{1}\label{1}\\b& :=f^{-1}(a,b)=f^{-1}(f(a,b),b)=a \tag{2}\label{2}\\a& :=f^{-1}(a,b)=f^{-1}(f(a,b),a)=b \tag{3}\label{3}\end{align}</script><p>可以看到，最终$a,b$交换了两者的值，因此可见只要是逆运算就可以满足要求，比如使用乘除：</p><pre><code class="hljs c++">a=a*b;b=a/b;a=a/b;</code></pre><p>我们可以代入数字验证一下，可以发现它也是正确的。</p><h2 id="3-交换律的影响"><a href="#3-交换律的影响" class="headerlink" title="3 交换律的影响"></a>3 交换律的影响</h2><p>​        但是，如果你细心点，你会发现既然乘除可以，那为什么要先乘后除，或者干脆使用乘方与开方，因为它们也是一组逆运算，可是当我们这样操作会发现答案是与预期不符的。因为问题出在交换律上。</p><h3 id="3-1-f-与-f-1-只有一者满足交换律"><a href="#3-1-f-与-f-1-只有一者满足交换律" class="headerlink" title="3.1 $f$与$f^{-1}$只有一者满足交换律"></a>3.1 $f$与$f^{-1}$只有一者满足交换律</h3><p>​        如果$f(a,b)\not= f(b,a)$,我们也就能得出$f^{-1}(c,a)\not=f^{-1}(c,b)$,而公式$\eqref{2}\eqref{3}$正是依赖于此的。也可这样想，不妨设$f(a,b)=c_1,f(b,a)=c_2$，则正确的应该是$f^{-1}(c_1,a)=b,f^{-1}(c_2,b)=a$。所以运算规则$f$应满足交换律，其逆运算则无要求。</p><p>​        那么，如果$f$不满足交换律，可以实现交换变量而不引入临时变量吗？答案当然是可以的，不过这就对不同的$f$就有不同的方法了，因为我们要知道$c_1$与$c_2$的关系，如果$f$是减法，则$c_1=-c_2$;如果是除法，则$c_1=c_2^{-1}$。</p><h3 id="3-2-f-与-f-1-都不满足交换律"><a href="#3-2-f-与-f-1-都不满足交换律" class="headerlink" title="3.2 $f$与$f^{-1}$都不满足交换律"></a>3.2 $f$与$f^{-1}$都不满足交换律</h3><p>​        这个条件下很好的例子就是矩阵和幂两种。矩阵涉及左乘、右乘、逆；幂涉及乘方、开方、对数。它们的运算时涉及到三种运算规则的。</p><p>​        以矩阵为例：</p><script type="math/tex; mode=display">\begin{align}A&:=AB\\B&:=AB^{-1}=ABB^{-1}=A\\A&:=B^{-1}A=A^{-1}AB=B\\\end{align}</script><p>​        幂运算：</p><p>​        </p><script type="math/tex; mode=display">\begin{align}a&:=a^b\\b&:=\sqrt[b]{a}=\sqrt[b]{a^b}=a\\a&:=\log_{a}{a}=\log_{a}{a^b}=b\end{align}</script><p>这种情况下是每种运算规则都是需要用到才能完成交换的。</p><h3 id="3-3-f-与-f-1-都满足交换律"><a href="#3-3-f-与-f-1-都满足交换律" class="headerlink" title="3.3  $f$与$f^{-1}$都满足交换律"></a>3.3  $f$与$f^{-1}$都满足交换律</h3><p>​        这个的最好的例子就是异或运算$\oplus $,因为它除了自身就满足交换，同时它的逆运算就是自身$f=f^{-1}$,</p><script type="math/tex; mode=display">\begin{align}a&:=a\oplus b\\b&:=a\oplus b=a\oplus b\oplus b =a\\a&:=a\oplus b=a\oplus b\oplus a =b\end{align}</script><h3 id="4-总结"><a href="#4-总结" class="headerlink" title="4 总结"></a>4 总结</h3><p>​        主要讲了讲这种变量交换操作的背后原理即推广，但是需要提醒的是在实际应用中，我还是建议通过临时变量来进行交换，上面的操作虽然给人眼前一亮，同时也有理论支持，可应用在实际中还是可能会出现错误，比如溢出，甚至交换变量类型根本就不是数字。我的建议是虽然这很有趣但请不要用。</p><p>​        </p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2020/05/23/hello-world/"/>
    <url>/2020/05/23/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre><code class="hljs bash">$ hexo new <span class="hljs-string">"My New Post"</span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre><code class="hljs bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre><code class="hljs bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre><code class="hljs bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Template类模板</title>
    <link href="/2020/05/21/Template%E7%B1%BB%E6%A8%A1%E6%9D%BF/"/>
    <url>/2020/05/21/Template%E7%B1%BB%E6%A8%A1%E6%9D%BF/</url>
    
    <content type="html"><![CDATA[<h1 id="Template"><a href="#Template" class="headerlink" title="Template"></a>Template</h1><h2 id="1-函数模板"><a href="#1-函数模板" class="headerlink" title="1.函数模板"></a>1.函数模板</h2><p>编译期间编译器自动分析参数类型，<code>template</code>函数模板是支持默认参数的，<code>T1 、T2</code> 顺序在默认情况下是可以任意的，不用严格按照从右到左的顺序，例如：<code>template &lt;typename T1 ,typename T2 = int&gt;</code></p><pre><code class="hljs cpp"><span class="hljs-comment">//函数模板化    </span><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<span class="hljs-function">T <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">const</span> T lval,<span class="hljs-keyword">const</span> T rval)</span></span><span class="hljs-function"></span>&#123;    T ans = lval + rval;    <span class="hljs-keyword">return</span> ans; &#125;</code></pre><pre><code class="hljs cpp"><span class="hljs-built_in">cout</span> &lt;&lt; add(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>) &lt;&lt; <span class="hljs-built_in">endl</span>;<span class="hljs-built_in">cout</span> &lt;&lt; add(<span class="hljs-number">2.1</span>, <span class="hljs-number">1.2</span>) &lt;&lt; <span class="hljs-built_in">endl</span>;<span class="hljs-comment">//add(2, 1.2)会报错,因为变成了add(int,double)</span>输出：    <span class="hljs-number">3</span>    <span class="hljs-number">3.3</span></code></pre><h2 id="2-类模板"><a href="#2-类模板" class="headerlink" title="2.类模板"></a>2.类模板</h2><p>将模板思想应用于类,类模板也支持默认参数，但是类模板必须严格从右往左默认化。</p><pre><code class="hljs cpp"><span class="hljs-comment">//类模板</span><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T</span>&gt;</span><span class="hljs-class"><span class="hljs-title">class</span> <span class="hljs-title">Myclass</span></span><span class="hljs-class">&#123;</span>    T a;    <span class="hljs-keyword">public</span>:        <span class="hljs-function">T <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">const</span> T lval, <span class="hljs-keyword">const</span> T rval)</span></span>;&#125;;<span class="hljs-keyword">template</span> &lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T</span>&gt;</span><span class="hljs-class"><span class="hljs-title">T</span> <span class="hljs-title">Myclass</span> &lt;T&gt;:</span>:add(<span class="hljs-keyword">const</span> T lval, <span class="hljs-keyword">const</span> T rval)&#123;    a = lval + rval;    <span class="hljs-keyword">return</span> a;&#125;</code></pre><pre><code class="hljs cpp">Myclass&lt;<span class="hljs-keyword">double</span>&gt; myclass;<span class="hljs-built_in">cout</span> &lt;&lt; myclass.add(<span class="hljs-number">1.2</span>, <span class="hljs-number">3.3</span>) &lt;&lt; <span class="hljs-built_in">endl</span>;输出：    <span class="hljs-number">4.5</span></code></pre><h2 id="3-成员模板"><a href="#3-成员模板" class="headerlink" title="3.成员模板"></a>3.成员模板</h2><p>在模板类内使用模板函数。</p><pre><code class="hljs cpp"><span class="hljs-comment">//成员模板</span><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T</span>&gt;</span><span class="hljs-class"><span class="hljs-title">class</span> <span class="hljs-title">Mylove</span></span><span class="hljs-class">&#123;</span>    <span class="hljs-keyword">public</span>:        T a;        <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> type_1, <span class="hljs-keyword">typename</span> type_2&gt;        <span class="hljs-function">type_1 <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">const</span> type_1 lval, <span class="hljs-keyword">const</span> type_2 rval)</span></span>;&#125;;<span class="hljs-keyword">template</span> &lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T</span>&gt;</span><span class="hljs-class"><span class="hljs-title">template</span> &lt;typename type_1, typename type_2&gt;</span><span class="hljs-class"><span class="hljs-title">type_1</span> <span class="hljs-title">Mylove</span>&lt;T&gt;:</span>:add(<span class="hljs-keyword">const</span> type_1 lval, <span class="hljs-keyword">const</span> type_2 rval)&#123;    a = lval + rval;    <span class="hljs-keyword">return</span> a;&#125;</code></pre><pre><code class="hljs cpp">Mylove&lt;<span class="hljs-keyword">double</span>&gt; mylove;<span class="hljs-built_in">cout</span> &lt;&lt; mylove.add(<span class="hljs-number">0</span>, <span class="hljs-number">20.2</span>) &lt;&lt; <span class="hljs-built_in">endl</span>; <span class="hljs-comment">//答案为20，因为该函数返回为第一个参数相同,该过程为int+double=double,但最终返回int</span>输出:<span class="hljs-number">20</span></code></pre><h2 id="4-嵌套类模板"><a href="#4-嵌套类模板" class="headerlink" title="4.嵌套类模板"></a>4.嵌套类模板</h2><p>模板类内嵌套模板类。</p><pre><code class="hljs cpp"><span class="hljs-comment">//嵌套类模板</span><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T</span>&gt;</span><span class="hljs-class"><span class="hljs-title">class</span> <span class="hljs-title">Mylife</span></span><span class="hljs-class">&#123;</span>    <span class="hljs-keyword">public</span>:        T a;        <span class="hljs-keyword">template</span> &lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">type_3</span>&gt;</span><span class="hljs-class">        <span class="hljs-title">class</span> <span class="hljs-title">Mystory</span>;</span><span class="hljs-comment">//先声明，在外部定义</span>        Mystory&lt;T&gt; mystory;<span class="hljs-comment">//用T实例化</span>&#125;;<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T</span>&gt;</span><span class="hljs-class">    <span class="hljs-title">template</span>&lt;class type_3&gt;</span><span class="hljs-class">        <span class="hljs-title">class</span> <span class="hljs-title">Mylife</span>&lt;T&gt;:</span>:Mystory        &#123;            <span class="hljs-keyword">public</span>:                type_3 c;                <span class="hljs-function">type_3 <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">const</span> type_3 lval, <span class="hljs-keyword">const</span> type_3 rval)</span> </span><span class="hljs-function">                </span>&#123;                    c = lval + rval;                    <span class="hljs-keyword">return</span> c;                &#125;;        &#125;;</code></pre><pre><code class="hljs cpp">Mylife&lt;<span class="hljs-keyword">double</span>&gt; mylife;<span class="hljs-built_in">cout</span> &lt;&lt; mylife.mystory.add(<span class="hljs-number">1</span>, <span class="hljs-number">1.1</span>) &lt;&lt; <span class="hljs-built_in">endl</span>;输出：    <span class="hljs-number">2.1</span></code></pre><h2 id="5-总结"><a href="#5-总结" class="headerlink" title="5.总结"></a>5.总结</h2><p>使用<code>template</code>,以不变应万变，平常使用的STL正是基于此。</p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Unity下计步器Pedometer算法的实现</title>
    <link href="/2020/05/15/Unity%E4%B8%8B%E8%AE%A1%E6%AD%A5%E5%99%A8Pedometer%E7%AE%97%E6%B3%95%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
    <url>/2020/05/15/Unity%E4%B8%8B%E8%AE%A1%E6%AD%A5%E5%99%A8Pedometer%E7%AE%97%E6%B3%95%E7%9A%84%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="Unity下计步器Pedometer的实现"><a href="#Unity下计步器Pedometer的实现" class="headerlink" title="Unity下计步器Pedometer的实现"></a>Unity下计步器Pedometer的实现</h2><p><strong>1.环境</strong><br>unity2018,Android(小米5)<br><strong>2.原理</strong><br><a href="https://blog.csdn.net/qq_36490364/article/details/104522980" target="_blank" rel="noopener">加速度传感器的计步算法Pedometer</a><br><strong>3.实现</strong><br>注释写的很清楚了应该<br><pre><code class="hljs c#">using UnityEngine;using UnityEngine.Networking;using UnityEngine.UI;#pragma warning disable CS0618public class pedometer : MonoBehaviour&#123;    public Text statusText,stepsText;    public float lowLimit &#x3D; 0.005f; &#x2F;&#x2F;平缓    public float highLimit &#x3D; 0.1f; &#x2F;&#x2F; 走路时的波峰波谷    public float vertHighLimit &#x3D; 0.25f;&#x2F;&#x2F;跳跃时的波峰波谷    private bool isHigh &#x3D; false; &#x2F;&#x2F; 状态    private float filterCurrent &#x3D; 10.0f; &#x2F;&#x2F; 滤波参数 得到拟合值    private float filterAverage &#x3D; 0.1f; &#x2F;&#x2F;   滤波参数  得到均值    private float accelerationCurrent &#x3D; 0f; &#x2F;&#x2F;拟合值    private float accelerationAverage &#x3D; 0f;&#x2F;&#x2F;均值    private int steps &#x3D; 0; &#x2F;&#x2F; 步数    private int oldSteps;    private float deltaTime &#x3D; 0f;&#x2F;&#x2F;计时器    private int jumpCount &#x3D; 0;&#x2F;&#x2F;跳跃数    private int oldjumpCount &#x3D; 0;        private bool startTimer &#x3D; false;&#x2F;&#x2F;开始计时    private bool isWalking &#x3D; false;    private bool isJumping &#x3D; false;    void Awake()    &#123;        accelerationAverage &#x3D; Input.acceleration.magnitude;         oldSteps &#x3D; steps;        oldjumpCount &#x3D;jumpCount ;    &#125;    void Update()    &#123;        checkWalkingAndJumping(); &#x2F;&#x2F; 检测是否行走        if (isWalking)        &#123;            statusText.text &#x3D; (&quot;状态:行走&quot;);                    &#125;        else if (!isWalking)        &#123;            statusText.text &#x3D; (&quot;状态:不动&quot;);        &#125;        if (isJumping)        &#123;            statusText.text &#x3D; (&quot;状态:跳跃&quot;);        &#125;    &#125;    void FixedUpdate()    &#123;        &#x2F;&#x2F;通过Lerp对Input.acceleration.magnitude(加速度标量和)滤波        &#x2F;&#x2F;这里使用线性插值的公式正好为EMA一次指数滤波 y[i]&#x3D;y[i-1]+(x[i]-y[i])*k&#x3D;(1-k)*y[i]+kx[i]        accelerationCurrent &#x3D; Mathf.Lerp(accelerationCurrent, Input.acceleration.magnitude, Time.deltaTime * filterCurrent);        accelerationAverage &#x3D; Mathf.Lerp(accelerationAverage, Input.acceleration.magnitude, Time.deltaTime * filterAverage);        float delta &#x3D; accelerationCurrent - accelerationAverage; &#x2F;&#x2F; 获取差值，即坡度        if (!isHigh)        &#123;               if (delta &gt; highLimit)&#x2F;&#x2F;往高            &#123;                isHigh &#x3D; true;                steps++;                stepsText.text &#x3D; &quot;步数: &quot; + steps+&quot;\n跳跃数：&quot;+jumpCount;            &#125;            if(delta&gt;vertHighLimit)            &#123;                isHigh &#x3D; true;                jumpCount++;                stepsText.text &#x3D; &quot;步数: &quot; + steps + &quot;\n跳跃数：&quot; + jumpCount;            &#125;        &#125;        else        &#123;            if (delta &lt; lowLimit)&#x2F;&#x2F;往低            &#123;                                isHigh &#x3D; false;            &#125;        &#125;    &#125;       private void checkWalkingAndJumping()    &#123;        if ((steps !&#x3D; oldSteps)||(oldjumpCount !&#x3D; jumpCount))        &#123;            startTimer &#x3D; true;            deltaTime &#x3D; 0f;        &#125;        if (startTimer)&#x2F;&#x2F;计时器，让更新UI的慢一点，因为你不可能走路只用一帧的时间QAQ        &#123;            deltaTime +&#x3D; Time.deltaTime;            if (deltaTime !&#x3D; 0)           &#123;                if (oldjumpCount !&#x3D; jumpCount)&#x2F;&#x2F;检测是否是跳跃                    isJumping &#x3D; true;                else                    isWalking &#x3D; true;                      &#125;            if (deltaTime &gt; 2)           &#123;                deltaTime &#x3D; 0F;                startTimer &#x3D; false;           &#125;        &#125;        else if (!startTimer)        &#123;            isWalking &#x3D; false;            isJumping &#x3D; false;        &#125;        oldSteps &#x3D; steps;        oldjumpCount &#x3D; jumpCount;    &#125;&#125;</code></pre></p>]]></content>
    
    
    <categories>
      
      <category>Unity</category>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>Unity</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>加速度传感器的计步算法Pedometer</title>
    <link href="/2020/05/15/%E5%8A%A0%E9%80%9F%E5%BA%A6%E4%BC%A0%E6%84%9F%E5%99%A8%E7%9A%84%E8%AE%A1%E6%AD%A5%E7%AE%97%E6%B3%95Pedometer/"/>
    <url>/2020/05/15/%E5%8A%A0%E9%80%9F%E5%BA%A6%E4%BC%A0%E6%84%9F%E5%99%A8%E7%9A%84%E8%AE%A1%E6%AD%A5%E7%AE%97%E6%B3%95Pedometer/</url>
    
    <content type="html"><![CDATA[<h2 id="加速度传感器的计步算法Pedometer"><a href="#加速度传感器的计步算法Pedometer" class="headerlink" title="加速度传感器的计步算法Pedometer"></a>加速度传感器的计步算法Pedometer</h2><p><strong>1.前言</strong><br>&emsp;&emsp;最近要使用到计步，查了很多资料，以下是一个简易的计步算法，也能检测跳跃</p><p><strong>2.工具</strong><br>&emsp;&emsp;<a href="https://download.csdn.net/download/qq_36490364/12193880" target="_blank" rel="noopener">一个实时绘制Android加速度的APP</a></p><p><strong>3.内容</strong></p><ol><li><p>Android的加速传感器的介绍</p><p>&emsp;&emsp;Android上的加速度传感器的方向如下所示（当你面朝手机屏幕观察），这是一个右手坐标系。因此加速度是由三个正交的向量组成的，例如当你平放手机在桌子上屏幕朝上，此时应为（0，0，9.6左右）<img src="/2020/05/15/%E5%8A%A0%E9%80%9F%E5%BA%A6%E4%BC%A0%E6%84%9F%E5%99%A8%E7%9A%84%E8%AE%A1%E6%AD%A5%E7%AE%97%E6%B3%95Pedometer/image-20200524015251937.png" srcset="/img/loading.gif" class="" title="image-20200524015251937"></p></li></ol><ol><li>使用g-sensor对数据进行分析<br> &emsp;&emsp;打开这个工具后进行走路和跳跃，然后导出数据，以时间为横轴画出折线图<img src="/2020/05/15/%E5%8A%A0%E9%80%9F%E5%BA%A6%E4%BC%A0%E6%84%9F%E5%99%A8%E7%9A%84%E8%AE%A1%E6%AD%A5%E7%AE%97%E6%B3%95Pedometer/20200226221501436-1590254598388.png" srcset="/img/loading.gif" class="" title="在这里插入图片描述"><br> 我们多实验几组实验后会发现，当手机以不同的姿态放入口袋然后进行运动时，xyz三轴的数据是不确定的，但是三者矢量和的模却是有规律的（其实真正的加速度被正交分解了），因此我们接下来应该分析的是它们的模|V|<br> <img src="/2020/05/15/%E5%8A%A0%E9%80%9F%E5%BA%A6%E4%BC%A0%E6%84%9F%E5%99%A8%E7%9A%84%E8%AE%A1%E6%AD%A5%E7%AE%97%E6%B3%95Pedometer/202002262042493.png" srcset="/img/loading.gif" class="" title="在这里插入图片描述">&emsp;&emsp;上图中可以知道，每次走路都会产生一个波峰和波谷，而跳跃的振幅相对大一些。因此判断行走只需判断波峰波谷就行</li></ol><ol><li>数据处理<br>&emsp;&emsp;不妨记第$i$个时间单位获取到的加速度的三个矢量和的模大小为$x_i$，为了使数据更加平滑，分别使用两次的指数滤波(EMA)<script type="math/tex; mode=display">\left\{\begin{aligned}a_{i}&=（1-p_1）a_{i-1}+p_{1}x_{i}\\b_{i}&=（1-p_2）b_{i-1}+p_{2}x_{i}\\a_{0}&=b_{0}=x_{0}\\p_{1}&>p_{2}\\\end{aligned}\right.</script></li></ol><p>&emsp;&emsp;其中$a_i$是拟合曲线，$b_i$均值，因此${\Delta{h}=a_i-b_i}$即波峰波谷的高度差,得到${\Delta{h}}$后再跟设置好的${k_1,k_2,k_3}$比较（其中${k_1&gt;k_2&gt;k_3}$)。判别结果如下,</p><script type="math/tex; mode=display">\left\{\begin{aligned}&jump,\Delta{h}>k_1\\&walking,\Delta{h}>k_2\\&standing,\Delta{h}<k_3\\\end{aligned}\right.</script><p>&emsp;&emsp;需要注意的是.一旦检测到跳跃或者行走,就得有计时器计时,当经过$\Delta t$后再进行判别,因为人走路和跳跃是需要时间的!!!</p><p>​        其中$p_1$,$p_2$,$k_1$,$k_2$,$k_3$,$\Delta t$ 都是需要我们设置的参数，下面分享一组<strong>手调</strong>测出来的参数QAQ，不一定最优但能行。。。</p><script type="math/tex; mode=display">\left\{\begin{aligned}p_1&=0.2\\p_2&=0.002\\k_1&=0.25\\k_2&=0.13\\k_3&=0.008\\\Delta t&=2s\end{aligned}\right.</script><img src="/2020/05/15/%E5%8A%A0%E9%80%9F%E5%BA%A6%E4%BC%A0%E6%84%9F%E5%99%A8%E7%9A%84%E8%AE%A1%E6%AD%A5%E7%AE%97%E6%B3%95Pedometer/20200227144604718.png" srcset="/img/loading.gif" class="" title="在这里插入图片描述"><p>&emsp;&emsp;上图是带入这些参数得到的曲线，我们可以看到经过$p_1$参数的滤波得到的曲线(红色)，已经大致拟合原数据(蓝色)，而经过$p_2$参数得到的曲线(绿色)大致为均值,要说一下的是其实绿线的值大致在9.8附近,就是重力加速度,为什么不直接采用9.8的原因是实际会有误差。</p><p>​        至于为什么会选EMA，简单有效！我们其实可以发现其公式可以用线性插值函数快速实现,虽然没人说，但我觉得在很多时候我们平滑移动物体和相机用到这个插值基于的原理就是这个，在每帧不断迭代才产生了平滑。</p><script type="math/tex; mode=display">a_i=Mathf.Lerp(a_{i-1 },x_i,p_1)=a_{i-1}+(1-p_1)x_i=(1-p_1)a_{i-1}+p_1x_i</script><p><strong>3.实现</strong><br><a href="https://blog.csdn.net/qq_36490364/article/details/104515912" target="_blank" rel="noopener">Unity下的实现</a></p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>求解最长回文子串</title>
    <link href="/2020/03/11/%E6%B1%82%E8%A7%A3%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/"/>
    <url>/2020/03/11/%E6%B1%82%E8%A7%A3%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/</url>
    
    <content type="html"><![CDATA[<p><strong>描述</strong><br>&emsp;&emsp;给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。</p><pre><code class="hljs c++">输入: <span class="hljs-string">"babad"</span>输出: <span class="hljs-string">"bab"</span>(注意: <span class="hljs-string">"aba"</span> 也是一个有效答案。)输入: <span class="hljs-string">"cbbd"</span>输出: <span class="hljs-string">"bb"</span></code></pre><p>&emsp;&emsp;dp,除此之外还有一些很炫的解法，这里只讲dp这是一道很好的入门题。<br>&emsp;&emsp;我一向认为dp第一步不是写状态转移方程，而是把状态设对。涉及到字符串的子串起码应该想到二维数组$dp<em>{ij}$,至于这个代表什么，就是手感了，设的好方程<del>推</del> （猜）的轻松，否则基本gg；<br>&emsp;&emsp;这里直接给答案，$dp</em>{ij}$表示以$s<em>i开头至以s_j$结尾的串.如果$s_i…s_j$为回文串，那么$s</em>{i-1}…s<em>{j+1}$为回文串的条件就是$s</em>{i-1}==s_{j+1}$。</p><pre><code class="hljs c++">初始状态：dp[i][i]==<span class="hljs-literal">true</span>;           i∈<span class="hljs-number">1.</span>..ndp[i][j]=dp[i+<span class="hljs-number">1</span>]d[j<span class="hljs-number">-1</span>]&amp;&amp;(s[i]==s[j])</code></pre><p>画表理解一下，以babad为例，填的顺序是斜着填的</p><div class="table-container"><table><thead><tr><th>1</th><th>0</th><th>1</th><th>0</th><th>0</th></tr></thead><tbody><tr><td></td><td>1</td><td>0</td><td>1</td><td>0</td></tr><tr><td></td><td></td><td>1</td><td>0</td><td>0</td></tr><tr><td></td><td></td><td></td><td>1</td><td>0</td></tr><tr><td></td><td></td><td></td><td></td><td>1</td></tr></tbody></table></div><img src="/2020/03/11/%E6%B1%82%E8%A7%A3%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/20200311204401984.png" srcset="/img/loading.gif" class="" title="在这里插入图片描述">上代码<pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-function"><span class="hljs-built_in">string</span> <span class="hljs-title">longestPalindrome</span><span class="hljs-params">(<span class="hljs-built_in">string</span> s)</span> </span>&#123;        <span class="hljs-keyword">int</span> len=s.length();        <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">bool</span>&gt;&gt; <span class="hljs-title">d</span><span class="hljs-params">(len, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">bool</span>&gt;(len))</span></span>;        <span class="hljs-keyword">int</span> <span class="hljs-built_in">max</span>=<span class="hljs-number">1</span>,p=<span class="hljs-number">0</span>,flag=<span class="hljs-number">1</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;len;i++)<span class="hljs-comment">//初始化</span>            d[i][i]=<span class="hljs-literal">true</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j&lt;len;j++)        &#123;            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;len-j;i++)            &#123;                <span class="hljs-keyword">if</span>(j==<span class="hljs-number">1</span>)<span class="hljs-comment">//长度为2的串</span>                &#123;                    d[i][j+i]=(s[i]==s[i+<span class="hljs-number">1</span>]);                    <span class="hljs-keyword">if</span>(d[i][i+<span class="hljs-number">1</span>]&amp;&amp;flag)<span class="hljs-comment">//flag用于只记录第一个长度为2的回文串，不用也没关系</span>                    &#123;                        <span class="hljs-built_in">max</span>=<span class="hljs-number">2</span>;                        p=i;                        flag=<span class="hljs-number">0</span>;                    &#125;                &#125;                <span class="hljs-keyword">else</span><span class="hljs-comment">//长度大与2的串</span>                &#123;                    d[i][j+i]=d[i+<span class="hljs-number">1</span>][i+j<span class="hljs-number">-1</span>]&amp;&amp;(s[i]==s[i+j]);<span class="hljs-comment">//转移方程</span>                    <span class="hljs-keyword">if</span>(d[i][j+i]&amp;&amp;j+<span class="hljs-number">1</span>&gt;<span class="hljs-built_in">max</span>)                    &#123;                        <span class="hljs-built_in">max</span>=j+<span class="hljs-number">1</span>;                        p=i;                    &#125;                &#125;            &#125;        &#125;        <span class="hljs-keyword">return</span> s.substr(p, <span class="hljs-built_in">max</span>);<span class="hljs-comment">//从p开始切割max位</span>    &#125;&#125;;</code></pre>]]></content>
    
    
    <categories>
      
      <category>习题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>习题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Unity Mega Fiers导入PC2文件失败</title>
    <link href="/2020/03/07/Unity-Mega-Fiers%E5%AF%BC%E5%85%A5PC2%E6%96%87%E4%BB%B6%E5%A4%B1%E8%B4%A5/"/>
    <url>/2020/03/07/Unity-Mega-Fiers%E5%AF%BC%E5%85%A5PC2%E6%96%87%E4%BB%B6%E5%A4%B1%E8%B4%A5/</url>
    
    <content type="html"><![CDATA[<p><strong>1.前言</strong><br>&emsp;&emsp;如何导入看这篇文章，<a href="https://blog.csdn.net/woerxi/article/details/64922563?depth_1-utm_source=distribute.pc_relevant.none-task&amp;utm_source=distribute.pc_relevant.none-task" target="_blank" rel="noopener">链接</a>，讲的很清楚了<br><strong>2.问题及解决</strong><br>&emsp;&emsp;出现mapping of XXX failed,查了好多资料，最后还是好不容易翻墙找到了<a href="http://www.west-racing.com/mf/?page_id=1335" target="_blank" rel="noopener">官网</a>才知道，这个也太偏僻了</p><pre><code class="hljs plain">Make sure you are using local space point cache files, so for exampleif you are using Max make sure you use the Object Space Point Cache Modifier as opposed to the World Space version and in other packages be sure to click the local space option box in the exporters.Also if you have Mapping Failures check to see if the Optimize Meshoption is turned off in the Unity FBX import settings.</code></pre><p>第一种是坐标问题，我是第二种情况，这个勾去掉就ok</p><img src="/2020/03/07/Unity-Mega-Fiers%E5%AF%BC%E5%85%A5PC2%E6%96%87%E4%BB%B6%E5%A4%B1%E8%B4%A5/20200307193324247.png" srcset="/img/loading.gif" class="" title="在这里插入图片描述"><p>还有，我补充一句，添加point cache组件的object一定是max里用点缓存的，也就是说，该是哪个物体就给哪个物体，这个不要给了父物体</p>]]></content>
    
    
    <categories>
      
      <category>Unity</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Unity</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Unity使用导入FBX的自带动画产生位移</title>
    <link href="/2020/03/06/Unity%E4%BD%BF%E7%94%A8%E5%AF%BC%E5%85%A5FBX%E7%9A%84%E8%87%AA%E5%B8%A6%E5%8A%A8%E7%94%BB%E4%BA%A7%E7%94%9F%E4%BD%8D%E7%A7%BB/"/>
    <url>/2020/03/06/Unity%E4%BD%BF%E7%94%A8%E5%AF%BC%E5%85%A5FBX%E7%9A%84%E8%87%AA%E5%B8%A6%E5%8A%A8%E7%94%BB%E4%BA%A7%E7%94%9F%E4%BD%8D%E7%A7%BB/</url>
    
    <content type="html"><![CDATA[<p><strong>1.描述</strong><br>&emsp;&emsp;在使用3dsMax导出模型带的动画时，再导入Unity，模型会一直移动到一个固定点。<br><strong>2.解决</strong><br>&emsp;&emsp;导出动画时不要选bake烘培，因为这个似乎是带着坐标信息的，我测试了好几次，把这个去掉就ok了。但是不选这个的画如果模型有做一些绑定物品，比如手中握着的东西在导入到unity时会产生一些小偏差，不过可以再重新绑定。</p><img src="/2020/03/06/Unity%E4%BD%BF%E7%94%A8%E5%AF%BC%E5%85%A5FBX%E7%9A%84%E8%87%AA%E5%B8%A6%E5%8A%A8%E7%94%BB%E4%BA%A7%E7%94%9F%E4%BD%8D%E7%A7%BB/20200306141331820.png" srcset="/img/loading.gif" class="" title="在这里插入图片描述">]]></content>
    
    
    <categories>
      
      <category>Unity</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Unity</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Unity使用NetworkServer与NetWorkClient实现服务端与客户端传递消息</title>
    <link href="/2020/02/26/Unity%E4%BD%BF%E7%94%A8NetworkServer%E4%B8%8ENetWorkClient%E5%AE%9E%E7%8E%B0%E6%9C%8D%E5%8A%A1%E7%AB%AF%E4%B8%8E%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%BC%A0%E9%80%92%E6%B6%88%E6%81%AF/"/>
    <url>/2020/02/26/Unity%E4%BD%BF%E7%94%A8NetworkServer%E4%B8%8ENetWorkClient%E5%AE%9E%E7%8E%B0%E6%9C%8D%E5%8A%A1%E7%AB%AF%E4%B8%8E%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%BC%A0%E9%80%92%E6%B6%88%E6%81%AF/</url>
    
    <content type="html"><![CDATA[<h2 id="Unity使用NetworkServer与NetWorkClient实现服务端与客户端传递消息"><a href="#Unity使用NetworkServer与NetWorkClient实现服务端与客户端传递消息" class="headerlink" title="Unity使用NetworkServer与NetWorkClient实现服务端与客户端传递消息"></a>Unity使用NetworkServer与NetWorkClient实现服务端与客户端传递消息</h2><p><strong>1.环境</strong><br>&emsp;&emsp;Unity2018<br><strong>2.前述</strong><br>&emsp;&emsp;第一个想到的方法是使用Socket,也实现了功能,但是我想Unity应该有自带的API用来实现,可是查阅了好多资料,发现大多是使用NetWorkManager,鉴于我的项目对网络的要求十分微小,因此我选择了较为低级NetworkServer和NetWorkClient类<br><strong>3.实现</strong><br>&emsp;&emsp;create一个Emty GameOjbect,挂载以下脚本,注意一下开启客户端方法setClient需要绑定在一个button上,服务端发送信息sendMessage也要绑定在一个button上。<br>&emsp;&emsp;注意，这是从我项目中直接拷贝过来稍微改了一下，可能并不能直接使用，但是应该可以很好的帮助理解这两个类的大致用法,下面是两个文档，好像需要翻墙<br><a href="https://docs.unity3d.com/2018.1/Documentation/ScriptReference/Networking.NetworkServer.html" target="_blank" rel="noopener">NetworkServer文档</a><br><a href="https://docs.unity3d.com/2018.1/Documentation/ScriptReference/Networking.NetworkClient.html" target="_blank" rel="noopener">NetworkClient文档</a></p><p>服务端与客户端的实现<br><pre><code class="hljs c#">using System.Net;using System.Net.Sockets;using UnityEngine;using UnityEngine.Networking;using UnityEngine.UI;public class MyNetWork : MonoBehaviour&#123;    public Text ipText;    private NetworkClient myClient;    void Start()    &#123;        getIp();          &#125;    void Update()    &#123;            &#125;    public void getIp()&#x2F;&#x2F;获取本机IP    &#123;        try        &#123;            IPHostEntry IpEntry &#x3D; Dns.GetHostEntry(Dns.GetHostName());            foreach (IPAddress item in IpEntry.AddressList)            &#123;                &#x2F;&#x2F;AddressFamily.InterNetwork  ipv4                if (item.AddressFamily &#x3D;&#x3D; AddressFamily.InterNetwork)                &#123;                    ipText.text &#x3D; &quot;IP:&quot; + item.ToString();                    MyMessage.ipAddress &#x3D; item.ToString();                    &#x2F;&#x2F;开启服务端                    if(NetworkServer.active)                    &#123;                        NetworkServer.Shutdown();                    &#125;                    else                    &#123;                        starServer();                    &#125;                    return;                &#125;            &#125;            return ;        &#125;        catch &#123; return; &#125;    &#125;    private void starServer()&#x2F;&#x2F;开启服务器    &#123;        NetworkServer.Listen(MyMessage.ipAddress, MyMessage.serverPort);&#x2F;&#x2F;参数为IP和Port        Debug.Log(NetworkServer.active);        &#125;  public void sendMessage()&#x2F;&#x2F;服务端发送消息    &#123;        if(NetworkServer.connections.Count&gt;0)        NetworkServer.SendToAll(MyMessage.msgTypeSend, new MessageInfo(isWalking, steps));    &#125;    public void setClient()&#x2F;&#x2F;开启客户端    &#123;        myClient &#x3D; new NetworkClient();        myClient.RegisterHandler(503, receiveMessage);&#x2F;&#x2F;注册回调函数,参数1为消息类型,数字可以自定义,用于识别回调函数,参数2为回调函数        myClient.Connect(MyMessage.ipAddress, MyMessage.serverPort);&#x2F;&#x2F;连接服务端,参数分别为IP和Port    &#125;    private void receiveMessage(NetworkMessage netMsg)&#x2F;&#x2F;客户端接收信息的回调函数的实现    &#123;        MessageInfo hostMessage &#x3D; netMsg.ReadMessage&lt;MessageInfo&gt;();        bool isWalking&#x3D; hostMessage.isWalking;        long steps  &#x3D; hostMessage.stepCount;        &#x2F;&#x2F;Output the Player name and comment        Debug.Log(&quot;isWalking: &quot; + isWalking);        Debug.Log(&quot;steps  : &quot; + steps);    &#125;&#125;</code></pre><br>MessgafeInfo类是封装的用来发送信息的自定义实体类,继承MessageBase<br><pre><code class="hljs c#">using UnityEngine.Networking;public class MessageInfo : MessageBase&#123;    public bool isWalking;    public long stepCount;    public MessageInfo() &#123; &#125;    public MessageInfo(bool iswalk,long stepcount)    &#123;        this.isWalking &#x3D; iswalk;        this.stepCount &#x3D; stepcount;    &#125;&#125;</code></pre></p>]]></content>
    
    
    <categories>
      
      <category>Unity</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Unity</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Unity Android真机测试</title>
    <link href="/2020/02/22/Unity-Android%E7%9C%9F%E6%9C%BA%E6%B5%8B%E8%AF%95/"/>
    <url>/2020/02/22/Unity-Android%E7%9C%9F%E6%9C%BA%E6%B5%8B%E8%AF%95/</url>
    
    <content type="html"><![CDATA[<h2 id="Unity-Android真机测试"><a href="#Unity-Android真机测试" class="headerlink" title="Unity Android真机测试"></a>Unity Android真机测试</h2><p>两种方法,首先在你需要debug的代码位置用Debug.log(“你想要的信息”)</p><h2 id="一-wifi"><a href="#一-wifi" class="headerlink" title="一.wifi"></a>一.wifi</h2><p>1.手机连数据线,要求电脑,手机同一网段,手机调试模式<br>2.adb tcpip 5555 //port<br>3.adb connect <ip><br>4.adb devices //检查是否连接<br>5.unity中build and run<br>6.unity中edit-&gt;preferences 找到sdk路径 复制 在我的电脑中打开 找到tools文件夹下的monitor打开，搜索栏输入：tag:Unity 观察</p><h2 id="二-usb"><a href="#二-usb" class="headerlink" title="二.usb"></a>二.usb</h2><p>1.手机连数据线,手机调试模式,允许usb 安装 (发现有些手机要有sim卡才能开启usb安装)<br>2.unity中build and run<br>3.unity中edit-&gt;preferences 找到sdk路径 复制 在我的电脑中打开 找到tools文件夹下的monitor打开，搜索栏输入：tag:Unity 观察<br>ps:其中第2步可用以下2步代替<br>①.unity打包出apk<br>②.cmd中adb -s &lt;设备号&gt; install -r <apk路径> //设备号可用adb devices 查看</p><p><strong>Montitor的界面</strong><br><img src="/2020/02/22/Unity-Android%E7%9C%9F%E6%9C%BA%E6%B5%8B%E8%AF%95/20200222155222186.png" srcset="/img/loading.gif" class="" title="在这里插入图片描述">下面是通法,不仅仅适用于unity,可以测试任何apk,这是以前开发安卓时用到的,上面两种其实是特例罢了,<br>1.连数据线,手机调试模式,允许usb 安装<br>2.用android studio(或者其他IDE)打包出apk<br>3.adb -s &lt;设备号&gt; install -r <apk路径> //设备号可用adb devices 查看<br>4.找到sdk路径 复制 在我的电脑中打开 找到tools文件夹下的monitor打开，搜索栏输入：tag:<xxx> 观察,也可以是pid:<xxx>,app:<xxx>,text:<xxx></p><p>ps:以上所有&lt;&gt; 在输入的时候都不同打出来,我只为为了表示这里填的是一个值;<br>用wifi的方法我没试过,因为以前都是用usb连接的习惯了,如果第一种方法有失效请告知</p>]]></content>
    
    
    <categories>
      
      <category>Unity</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Unity</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Unity打包apk后雾效果消失</title>
    <link href="/2020/02/22/Unity%E6%89%93%E5%8C%85apk%E5%90%8E%E9%9B%BE%E6%95%88%E6%9E%9C%E6%B6%88%E5%A4%B1/"/>
    <url>/2020/02/22/Unity%E6%89%93%E5%8C%85apk%E5%90%8E%E9%9B%BE%E6%95%88%E6%9E%9C%E6%B6%88%E5%A4%B1/</url>
    
    <content type="html"><![CDATA[<h2 id="Unity打包apk后雾效果消失"><a href="#Unity打包apk后雾效果消失" class="headerlink" title="Unity打包apk后雾效果消失"></a>Unity打包apk后雾效果消失</h2><p>&emsp;&emsp;今天测试一个雾的效果时，发现在电脑上play有用，等打包到apk时就失效了。讲一下避免以下坑吧。</p><p> <strong>1.环境</strong><br>unity2018</p><p><strong>2.解决方法</strong><br>Edit-&gt;Project Settings-&gt;Graphics 找到Shader Stripping 中fog mode设置为custom（原来是Automatic）,然后选中你想要的模式，最后重新打包就ok</p><img src="/2020/02/22/Unity%E6%89%93%E5%8C%85apk%E5%90%8E%E9%9B%BE%E6%95%88%E6%9E%9C%E6%B6%88%E5%A4%B1/20200222150033160.png" srcset="/img/loading.gif" class="" title="在这里插入图片描述"><p>这三种模式的介绍请看另一篇吧<br><a href="https://blog.csdn.net/qq_36490364/article/details/104444197" target="_blank" rel="noopener">unity fog雾的三种模式</a></p>]]></content>
    
    
    <categories>
      
      <category>Unity</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Bug</tag>
      
      <tag>Unity</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Unity fog雾的三种模式</title>
    <link href="/2020/02/22/Unity-fog%E9%9B%BE%E7%9A%84%E4%B8%89%E7%A7%8D%E6%A8%A1%E5%BC%8F/"/>
    <url>/2020/02/22/Unity-fog%E9%9B%BE%E7%9A%84%E4%B8%89%E7%A7%8D%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h2 id="unity-fog雾的三种模式"><a href="#unity-fog雾的三种模式" class="headerlink" title="unity fog雾的三种模式"></a>unity fog雾的三种模式</h2><p><strong>1.Linear</strong><br>线性模式，有fogStartDistance和fogEndDistance两个参数，雾从Start开始到End越来越浓，End之后也为最大浓度，计算方法为$\frac{end-|z|}{end-start}$，z为相机距离<br><strong>2.Exponential</strong><br>指数模式，有参数fogDensity（取值范围0-1），表示雾的浓度，浓度越大雾越大，计算方法为$e^{-d|z|}$,其中d为浓度，z为相机距离<br><strong>3.Exponential Squared</strong><br>指数平方，有参数fogDensity，越大表示雾越浓，计算方法为$e^{-(dz)^2}$</p><p>ps:fogDensity参数只适用于2，3，fogStartDistance和fogEndDistance只适用于1</p><p>下面是使用代码开启雾气的效果</p><pre><code class="hljs c#">RenderSettings.fog &#x3D; true;&#x2F;&#x2F;开启RenderSettings.fogMode &#x3D; FogMode.ExponentialSquared;&#x2F;&#x2F;模式RenderSettings.fogColor &#x3D; Color.red;&#x2F;&#x2F;颜色RenderSettings.fogDensity &#x3D; 0.04f;&#x2F;&#x2F;浓度</code></pre><p><a href="https://blog.csdn.net/qq_36490364/article/details/104443965" target="_blank" rel="noopener">关于打包apk后雾效果消失的解决方法</a></p>]]></content>
    
    
    <categories>
      
      <category>Unity</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Unity</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HDU1728逃离迷宫DFS</title>
    <link href="/2019/09/03/HDU1728%E9%80%83%E7%A6%BB%E8%BF%B7%E5%AE%ABDFS/"/>
    <url>/2019/09/03/HDU1728%E9%80%83%E7%A6%BB%E8%BF%B7%E5%AE%ABDFS/</url>
    
    <content type="html"><![CDATA[<h2 id="逃离迷宫"><a href="#逃离迷宫" class="headerlink" title="逃离迷宫"></a>逃离迷宫</h2><p>Problem Description</p><p>　　给定一个m × n (m行, n列)的迷宫，迷宫中有两个位置，gloria想从迷宫的一个位置走到另外一个位置，当然迷宫中有些地方是空地，gloria可以穿越，有些地方是障碍，她必须绕行，从迷宫的一个位置，只能走到与它相邻的4个位置中,当然在行走过程中，gloria不能走到迷宫外面去。令人头痛的是，gloria是个没什么方向感的人，因此，她在行走过程中，不能转太多弯了，否则她会晕倒的。我们假定给定的两个位置都是空地，初始时，gloria所面向的方向未定，她可以选择4个方向的任何一个出发，而不算成一次转弯。gloria能从一个位置走到另外一个位置吗？</p><p>Input</p><p>　　第1行为一个整数t (1 ≤ t ≤ 100),表示测试数据的个数，接下来为t组测试数据，每组测试数据中，<br>　　第1行为两个整数m, n (1 ≤ m, n ≤ 100),分别表示迷宫的行数和列数，接下来m行，每行包括n个字符，其中字符’.’表示该位置为空地，字符’*’表示该位置为障碍，输入数据中只有这两种字符，每组测试数据的最后一行为5个整数k, x1, y1, x2, y2 (1 ≤ k ≤ 10, 1 ≤ x1, x2 ≤ n, 1 ≤ y1, y2 ≤ m),其中k表示gloria最多能转的弯数，(x1, y1), (x2, y2)表示两个位置，其中x1，x2对应列，y1, y2对应行。</p><p>Output</p><p>　　每组测试数据对应为一行，若gloria能从一个位置走到另外一个位置，输出“yes”，否则输出“no”。</p><p>Sample Input<br><pre><code class="hljs c++"><span class="hljs-number">2</span><span class="hljs-number">5</span> <span class="hljs-number">5</span>...***.**...........*....<span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">3</span><span class="hljs-number">5</span> <span class="hljs-number">5</span>...***.**...........*....<span class="hljs-number">2</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">3</span></code></pre></p><p>Sample Output<br><pre><code class="hljs plain">noyes</code></pre></p><p><strong>思路:dfs,并且用一个辅助二维数组记录当前坐标的最小转向次数,每次转向path+1,同时每次向四周走的时候用turn记录当前方向,此题的坑在输入的x代表列，y代表行。</strong></p><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">char</span> <span class="hljs-built_in">map</span>[<span class="hljs-number">100</span>][<span class="hljs-number">100</span>];<span class="hljs-keyword">int</span> tt[<span class="hljs-number">100</span>][<span class="hljs-number">100</span>];<span class="hljs-comment">//记录最小转向次数 </span><span class="hljs-keyword">int</span> n, m;<span class="hljs-keyword">int</span> k, x1, yy1, x2, y2;<span class="hljs-keyword">int</span> ans;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y, <span class="hljs-keyword">int</span> path, <span class="hljs-keyword">int</span> <span class="hljs-built_in">turn</span>)</span><span class="hljs-comment">//x,y 坐标,path 转向次数, turn 方向分别为2468，下左右上,参考街机 </span></span><span class="hljs-function"></span>&#123;<span class="hljs-keyword">if</span> (x == y2 - <span class="hljs-number">1</span> &amp;&amp; y == x2 - <span class="hljs-number">1</span> &amp;&amp; tt[y2 - <span class="hljs-number">1</span>][x2 - <span class="hljs-number">1</span>] &lt;= k)<span class="hljs-comment">//出口 </span><span class="hljs-keyword">return</span>;<span class="hljs-keyword">if</span> (x&lt;<span class="hljs-number">0</span> || x&gt;n - <span class="hljs-number">1</span> || y&lt;<span class="hljs-number">0</span> || y&gt;m - <span class="hljs-number">1</span> || <span class="hljs-built_in">map</span>[x][y] == <span class="hljs-string">'*'</span> || tt[x][y] &gt; k)<span class="hljs-comment">//不符合 </span><span class="hljs-keyword">return</span>;<span class="hljs-keyword">if</span> (<span class="hljs-built_in">map</span>[x + <span class="hljs-number">1</span>][y] == <span class="hljs-string">'.'</span>)<span class="hljs-comment">//向左 </span>&#123;<span class="hljs-keyword">if</span> (<span class="hljs-built_in">turn</span> == <span class="hljs-number">2</span> || <span class="hljs-built_in">turn</span> == <span class="hljs-number">0</span>)<span class="hljs-comment">//检查当前方向是否为左或初始点 </span>&#123;<span class="hljs-keyword">if</span> (path&lt;=tt[x + <span class="hljs-number">1</span>][y])<span class="hljs-comment">//转向次数是否比tt数组记录中的小或等于,这边一定要用小于等于, 因为可能有不同路径 </span>&#123;tt[x + <span class="hljs-number">1</span>][y] = path;dfs(x + <span class="hljs-number">1</span>, y, path, <span class="hljs-number">2</span>);&#125;&#125;<span class="hljs-keyword">else</span><span class="hljs-comment">//方向不同要转向 path+1,并调整方向 </span>&#123;<span class="hljs-keyword">if</span> (path + <span class="hljs-number">1</span>&lt;=tt[x + <span class="hljs-number">1</span>][y])&#123;tt[x + <span class="hljs-number">1</span>][y] = path + <span class="hljs-number">1</span>;dfs(x + <span class="hljs-number">1</span>, y, path + <span class="hljs-number">1</span>, <span class="hljs-number">2</span>);&#125;&#125;&#125;<span class="hljs-keyword">if</span> (<span class="hljs-built_in">map</span>[x - <span class="hljs-number">1</span>][y] == <span class="hljs-string">'.'</span>)&#123;<span class="hljs-keyword">if</span> (<span class="hljs-built_in">turn</span> == <span class="hljs-number">8</span> || <span class="hljs-built_in">turn</span> == <span class="hljs-number">0</span>)&#123;<span class="hljs-keyword">if</span> (path&lt;=tt[x - <span class="hljs-number">1</span>][y])&#123;tt[x - <span class="hljs-number">1</span>][y] = path;dfs(x - <span class="hljs-number">1</span>, y, path, <span class="hljs-number">8</span>);&#125;&#125;<span class="hljs-keyword">else</span>&#123;<span class="hljs-keyword">if</span> (path + <span class="hljs-number">1</span>&lt;=tt[x - <span class="hljs-number">1</span>][y])&#123;tt[x - <span class="hljs-number">1</span>][y] = path + <span class="hljs-number">1</span>;dfs(x - <span class="hljs-number">1</span>, y, path + <span class="hljs-number">1</span>, <span class="hljs-number">8</span>);&#125;&#125;&#125;<span class="hljs-keyword">if</span> (<span class="hljs-built_in">map</span>[x][y + <span class="hljs-number">1</span>] == <span class="hljs-string">'.'</span>)&#123;<span class="hljs-keyword">if</span> (<span class="hljs-built_in">turn</span> == <span class="hljs-number">6</span> || <span class="hljs-built_in">turn</span> == <span class="hljs-number">0</span>)&#123;<span class="hljs-keyword">if</span> (path&lt;=tt[x][y + <span class="hljs-number">1</span>])&#123;tt[x][y + <span class="hljs-number">1</span>] = path;dfs(x, y + <span class="hljs-number">1</span>, path, <span class="hljs-number">6</span>);&#125;&#125;<span class="hljs-keyword">else</span>&#123;<span class="hljs-keyword">if</span> (path + <span class="hljs-number">1</span>&lt;=tt[x][y + <span class="hljs-number">1</span>])&#123;tt[x][y + <span class="hljs-number">1</span>] = path + <span class="hljs-number">1</span>;dfs(x, y + <span class="hljs-number">1</span>, path + <span class="hljs-number">1</span>, <span class="hljs-number">6</span>);&#125;&#125;&#125;<span class="hljs-keyword">if</span> (<span class="hljs-built_in">map</span>[x][y - <span class="hljs-number">1</span>] == <span class="hljs-string">'.'</span>)&#123;<span class="hljs-keyword">if</span> (<span class="hljs-built_in">turn</span> == <span class="hljs-number">4</span> || <span class="hljs-built_in">turn</span> == <span class="hljs-number">0</span>)&#123;<span class="hljs-keyword">if</span> (path&lt;=tt[x][y - <span class="hljs-number">1</span>])&#123;tt[x][y - <span class="hljs-number">1</span>] = path;dfs(x, y - <span class="hljs-number">1</span>, path, <span class="hljs-number">4</span>);&#125;&#125;<span class="hljs-keyword">else</span>&#123;<span class="hljs-keyword">if</span> (path + <span class="hljs-number">1</span>&lt;=tt[x][y - <span class="hljs-number">1</span>])&#123;tt[x][y - <span class="hljs-number">1</span>] = path + <span class="hljs-number">1</span>;dfs(x, y - <span class="hljs-number">1</span>, path + <span class="hljs-number">1</span>, <span class="hljs-number">4</span>);&#125;&#125;&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-keyword">int</span> t;<span class="hljs-built_in">cin</span> &gt;&gt; t;<span class="hljs-keyword">while</span> (t--)&#123;<span class="hljs-built_in">cin</span> &gt;&gt; n &gt;&gt; m;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i&lt;n; i++)<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j&lt;m; j++)&#123;<span class="hljs-built_in">cin</span> &gt;&gt; <span class="hljs-built_in">map</span>[i][j];tt[i][j] = <span class="hljs-number">10000</span>;&#125;<span class="hljs-built_in">cin</span> &gt;&gt; k &gt;&gt; x1 &gt;&gt; yy1 &gt;&gt; x2 &gt;&gt; y2;tt[yy1 - <span class="hljs-number">1</span>][x1 - <span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;ans = <span class="hljs-number">0</span>;dfs(yy1 - <span class="hljs-number">1</span>, x1 - <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<span class="hljs-keyword">if</span> (tt[y2 - <span class="hljs-number">1</span>][x2 - <span class="hljs-number">1</span>]&lt;=k)<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"yes"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<span class="hljs-keyword">else</span><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"no"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>习题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>习题</tag>
      
      <tag>DFS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>AOE网</title>
    <link href="/2019/05/20/AOE%E7%BD%91/"/>
    <url>/2019/05/20/AOE%E7%BD%91/</url>
    
    <content type="html"><![CDATA[<h2 id="AOE网"><a href="#AOE网" class="headerlink" title="AOE网"></a>AOE网</h2><p><strong>1.介绍</strong><br>定义：在带权有向图中，以顶点表示事件，有向边表示活动，边上的权值表示完成该活动的开销，则称这种有向图为用边表示活动的网络，简称为AOE网（Activity On Edge Network）</p><p>性质：</p><ul><li>只有在某顶点所代表的事件发生后，从该顶点出发的各有向边所代表的活动才能开始</li><li>只有在进入某一顶点的各有向边所代表的活动都已经结束时，该顶点所代表的事件才发生</li></ul><p><strong>2.几个词的解释</strong><br>ps:事件是点，活动是边！！！</p><p>关键路径：<br>从源点到汇点的所有路径中，具有最长路径长度的路径，该路径上的活动成为<code>关键活动（后面有用先记着）</code></p><p>事件<code>V[k]</code>的最早发生时间<code>ve[k]</code>:<br>从开始顶点V到V[k]的最长路径长度。</p><p>事件<code>V[k]</code>的最迟发生时间<code>vl[k]</code>:<br>不推迟整个工程完成的前提下，即保证它所指向的事件Vi在ve(i)时刻能够发生时，改事件最迟必须发生的事件。</p><p>活动<code>a[i]</code>的最早开始时间<code>e[i]</code>:       活动a[i]用边<code>(V[k],V[j])</code>表示</p><pre><code class="hljs c++">e[i]=ve[k]</code></pre><p>活动<code>a[i]</code>的最迟开始时间<code>l[i]</code>:</p><pre><code class="hljs c++">l[i]=vl[j]-Weight(V[k],V[j])</code></pre><p>一个活动a[i]的松弛时间：<br><code>d[i]=l[i]-e[i]</code>或者<code>d[i]=关键路径长度-包含a[i]活动的最长路径</code></p><p><strong>3.计算</strong><br><img src="/2019/05/20/AOE%E7%BD%91/20190519214237921.png" srcset="/img/loading.gif" class="" title="在这里插入图片描述"></p><p><strong>3.1 计算事件的最早和最迟发生时间</strong></p><p>ve的计算方法为从前往后计算，取最大值，例如对于F,<code>ve(F)=max{ve(B)+a5,ve(E)+a7,ve(G)+a8}</code> ,只有一个的话就只取一个，多个的话，多个中取最大值</p><p>vl的计算方法为从后往前计算，首先另终点J的vl值为其ve，即vl(J)=ve(J)=18，然后多个中取最小值，例如对于B,<code>vl(B)=min{vl(C)-a2,vl(F)-a5,vl(D)-a3}=2</code>;若只有一个，例如对于H,<code>vl(H)=vl(J)-a12=14</code></p><p>最终算出各个顶点的最早和最迟发生时间如下<br>|V|ve（事件最早发生时间）| vl（事件最迟发生事件）|<br>|—|—|—|<br>|  A| 0 |0|<br>|  B| 2 |2|<br>| C| 5 |5|<br>|  D|  4|4|<br>| E| 10 |10|<br>|  F|13 |13|<br>| G| 7 |7|<br>|  H| 12 |14|<br>|  I| 13 |16|<br>|  J|18  |18|</p><p>有以上可以得出ve==vl的点即为关键路径上的事件，即A,B,C,D,E,F,G,J，则有以上点连接的边所代表的活动a1,a2,a3,a4,a6,a7,a8,a10疑似为关键活动<br>注意：<br>关键路径可能不只有一条，计算到这里只能得出关键路径上的事件，具体怎么走还等计算活动的最早和最迟开始时间，如果仅仅需要计算出关键路径，则只需计算几个疑似关键活动的最早和最迟发生时间，为了清楚，我们这里就把全部活动的都计算出来</p><p><strong>3.2活动的最早和最迟开始时间</strong><br>活动最早开始时间：  例如a1,为边（A,B），则<code>a1=ve(A)=0</code>;例如a2,为边（B,C），则a2=ve(B)=2</p><p>活动最晚开始时间：例如对于a1,为边（A,B）,则<code>a1=vl(B)-weight(a1)=2-2=0</code>；例如a12,为边（H,J）,则<code>a12=vl(J)-weight(a12)=18-4=14</code></p><p>最终结果如下</p><div class="table-container"><table><thead><tr><th>a</th><th>e（活动最早开始时间）</th><th>l（活动最迟开始事件）</th></tr></thead><tbody><tr><td>a1</td><td>0</td><td>0</td></tr><tr><td>a2</td><td>2</td><td>2</td></tr><tr><td>a3</td><td>2</td><td>2</td></tr><tr><td>a4</td><td>5</td><td>5</td></tr><tr><td>a5</td><td>2</td><td>9</td></tr><tr><td>a6</td><td>4</td><td>4</td></tr><tr><td>a7</td><td>10</td><td>10</td></tr><tr><td>a8</td><td>7</td><td>7</td></tr><tr><td>a9</td><td>10</td><td>12</td></tr><tr><td>a10</td><td>13</td><td>13</td></tr><tr><td>a11</td><td>7</td><td>10</td></tr><tr><td>a12</td><td>12</td><td>14</td></tr><tr><td>a13</td><td>13</td><td>16</td></tr></tbody></table></div><p>找出e==l的活动ai,这里为a1,a2,a3,,a4,a6,a7,a8,a10;经观察可发现这里有两条关键路径，分别为a1,a2,a4,a7,a10和a1,a3,a6,a8,a10</p><p>又比如问一个活动的松弛时间，即活动ai在不拖延总工程时间的情况下，该活动可以拖延的时间，有两种解法，比如问BF的松弛时间：<br>解1：BF=a5,所以松弛时间=l(a5)-e(a5)=7<br>解2：包含BF活动的最长路径为ABFJ,其长度为11，又因为关键路径长度为18，所以松弛时间为18-11=7</p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>快排C++&amp;Python</title>
    <link href="/2019/03/31/%E5%BF%AB%E6%8E%92C++&amp;Python/"/>
    <url>/2019/03/31/%E5%BF%AB%E6%8E%92C++&amp;Python/</url>
    
    <content type="html"><![CDATA[<h2 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h2><p>1．i =left; j =right; 找一个基准数（随意，这里不妨找a[left]=a[i]），将其挖出。<br>2．j—由后向前找比它小的数，找到后挖出此数填前一个坑a[i]中。<br>3．i++由前向后找比它大的数，找到后也挖出此数填到前一个坑a[j]中。<br>4．重复2，3步，直到i==j，将基准数填入a[i]中。</p><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">quick</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a[],<span class="hljs-keyword">int</span> left,<span class="hljs-keyword">int</span> right)</span></span><span class="hljs-function"></span>&#123;<span class="hljs-keyword">if</span>(left&gt;=right)<span class="hljs-keyword">return</span>;<span class="hljs-keyword">int</span> i=left,j=right,key=a[left];<span class="hljs-keyword">while</span>(i&lt;j)&#123;<span class="hljs-keyword">while</span>((i&lt;j)&amp;&amp;a[j]&gt;=key)j--;<span class="hljs-keyword">if</span>(i&lt;j)a[i++]=a[j];<span class="hljs-keyword">while</span>((i&lt;j)&amp;&amp;a[i]&lt;key)i++;<span class="hljs-keyword">if</span>(i&lt;j)a[j--]=a[i];&#125;a[i]=key;quick(a,left,j<span class="hljs-number">-1</span>);quick(a,j+<span class="hljs-number">1</span>,right);&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-keyword">int</span> a[]=&#123;<span class="hljs-number">-1</span>,<span class="hljs-number">-9</span>,<span class="hljs-number">4</span>,<span class="hljs-number">66</span>,<span class="hljs-number">123</span>,<span class="hljs-number">452</span>,<span class="hljs-number">665</span>,<span class="hljs-number">1</span>,<span class="hljs-number">34</span>&#125;;<span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> len=<span class="hljs-keyword">sizeof</span>(a)/<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>);<span class="hljs-comment">//不用static len会变</span><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;len;i++)<span class="hljs-built_in">cout</span>&lt;&lt;a[i]&lt;&lt;<span class="hljs-string">" "</span>;<span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-built_in">endl</span>;quick(a,<span class="hljs-number">0</span>,len<span class="hljs-number">-1</span>);<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;len;i++)<span class="hljs-built_in">cout</span>&lt;&lt;a[i]&lt;&lt;<span class="hljs-string">" "</span>;<span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-built_in">endl</span>;system(<span class="hljs-string">"pause"</span>);<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h2 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h2><p>1.记位于列表中间的数为mid<br>2.大于mid的放入greater列表<br>3.小于mid的放入less列表<br>4.递归greater和less列表<br><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">quick</span><span class="hljs-params">(arr)</span>:</span>    <span class="hljs-keyword">if</span>(len(arr)&lt;<span class="hljs-number">2</span>):        <span class="hljs-keyword">return</span> arr    mid=arr[len(arr)//<span class="hljs-number">2</span>]    less,greater=[],[]    arr.remove(mid)    <span class="hljs-keyword">for</span> num <span class="hljs-keyword">in</span> arr:        <span class="hljs-keyword">if</span>(num&gt;mid):            greater.append(num)        <span class="hljs-keyword">else</span>:            less.append(num)    <span class="hljs-keyword">return</span> quick(less)+[mid]+quick(greater)    arr=[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">5</span>,<span class="hljs-number">5</span>,<span class="hljs-number">5</span>,<span class="hljs-number">5</span>,<span class="hljs-number">31</span>,<span class="hljs-number">4</span>]arr=quick(arr)print(<span class="hljs-string">' '</span>.join([str(i)<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> arr]))</code></pre></p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
      <category>Python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>习题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>java.awt.Robot的mouseMove(x,y)效果不起作用</title>
    <link href="/2019/03/29/java.awt.Robot%E7%9A%84mouseMove(x,y)%E6%95%88%E6%9E%9C%E4%B8%8D%E8%B5%B7%E4%BD%9C%E7%94%A8/"/>
    <url>/2019/03/29/java.awt.Robot%E7%9A%84mouseMove(x,y)%E6%95%88%E6%9E%9C%E4%B8%8D%E8%B5%B7%E4%BD%9C%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p><code>mouseMove(x,y)</code>，此函数是使鼠标移动到<code>（x,y）</code>位置<br>测试发现它是一个逐渐逼近的过程，所以外面套个循环，就能移动到想要的位置了<br>原因未知，不知是不是win10的锅</p><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.awt.Robot;Robot robot=<span class="hljs-keyword">new</span> Robot();<span class="hljs-keyword">int</span> k=<span class="hljs-number">10</span>;<span class="hljs-keyword">int</span> x=<span class="hljs-number">666</span>;<span class="hljs-keyword">int</span> y=<span class="hljs-number">666</span>;<span class="hljs-keyword">while</span>((--k)&gt;<span class="hljs-number">0</span>)&#123;robot.mouseMove(x,y);&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Bug</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>KMP算法及手工求解next数组</title>
    <link href="/2019/03/18/KMP%E7%AE%97%E6%B3%95%E5%8F%8A%E6%89%8B%E5%B7%A5%E6%B1%82%E8%A7%A3next%E6%95%B0%E7%BB%84/"/>
    <url>/2019/03/18/KMP%E7%AE%97%E6%B3%95%E5%8F%8A%E6%89%8B%E5%B7%A5%E6%B1%82%E8%A7%A3next%E6%95%B0%E7%BB%84/</url>
    
    <content type="html"><![CDATA[<h2 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a>KMP算法</h2><p>详解找来找去感觉还是这两篇解释的很好<br><a href="https://segmentfault.com/a/1190000008575379?utm_medium=referral&amp;utm_source=tuicool" target="_blank" rel="noopener">KMP算法（1）：如何理解KMP</a><br><a href="https://segmentfault.com/a/1190000009409706" target="_blank" rel="noopener">KMP算法（2）：其细微之处</a></p><h2 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a><strong>笔记</strong></h2><img src="/2019/03/18/KMP%E7%AE%97%E6%B3%95%E5%8F%8A%E6%89%8B%E5%B7%A5%E6%B1%82%E8%A7%A3next%E6%95%B0%E7%BB%84/2019031822273034.png" srcset="/img/loading.gif" class="" title="在这里插入图片描述"><p>next[i]=j,即模式串p[1-i]的最长的相同真前后缀的长度<br><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"stdafx.h"</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"string"</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"iostream"</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">getNext</span><span class="hljs-params">(<span class="hljs-built_in">string</span> p, <span class="hljs-keyword">int</span> next[])</span></span><span class="hljs-function"></span>&#123;<span class="hljs-keyword">int</span> len = p.<span class="hljs-built_in">size</span>();<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;<span class="hljs-keyword">int</span> j = <span class="hljs-number">-1</span>;next[<span class="hljs-number">0</span>] = <span class="hljs-number">-1</span>;<span class="hljs-keyword">while</span> (i &lt; len - <span class="hljs-number">1</span>)&#123;<span class="hljs-keyword">if</span> (j == <span class="hljs-number">-1</span> || p[i] == p[j])next[++i] = ++j;<span class="hljs-keyword">else</span>j = next[j];&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">KMP</span><span class="hljs-params">(<span class="hljs-built_in">string</span> s, <span class="hljs-built_in">string</span> p, <span class="hljs-keyword">int</span> next[])</span></span><span class="hljs-function"></span>&#123;<span class="hljs-keyword">int</span> i, j;<span class="hljs-keyword">int</span> pl = p.<span class="hljs-built_in">size</span>();<span class="hljs-keyword">int</span> sl = s.<span class="hljs-built_in">size</span>();<span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>; i &lt; sl&amp;&amp; j &lt; pl;)<span class="hljs-comment">//注意这里不要用j&lt;p.size() 因为p.size()是unsigned int 类型，然后j有可能变成-1然后直接跳出循环</span>&#123;<span class="hljs-keyword">if</span> (j == <span class="hljs-number">-1</span> || s[i] == p[j])&#123;i++;j++;&#125;<span class="hljs-keyword">else</span>j = next[j];&#125;<span class="hljs-keyword">if</span> (j == p.<span class="hljs-built_in">size</span>())<span class="hljs-keyword">return</span> i - j;<span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;<span class="hljs-keyword">int</span> next[<span class="hljs-number">100</span>] = &#123; <span class="hljs-number">0</span> &#125;;<span class="hljs-built_in">string</span> s = <span class="hljs-string">"abababababcdab"</span>;<span class="hljs-built_in">string</span> p = <span class="hljs-string">"abcdab"</span>;<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"主串:"</span> &lt;&lt; s &lt;&lt; <span class="hljs-built_in">endl</span>;<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"子串:"</span> &lt;&lt; p &lt;&lt; <span class="hljs-built_in">endl</span>;getNext(p, next);<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"next数组为："</span>;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; p.<span class="hljs-built_in">size</span>(); i++)<span class="hljs-built_in">cout</span> &lt;&lt; next[i];<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"匹配位置:"</span> &lt;&lt; KMP(s, p, next) &lt;&lt; <span class="hljs-built_in">endl</span>;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></p><h2 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h2><img src="/2019/03/18/KMP%E7%AE%97%E6%B3%95%E5%8F%8A%E6%89%8B%E5%B7%A5%E6%B1%82%E8%A7%A3next%E6%95%B0%E7%BB%84/20190321174723805.png" srcset="/img/loading.gif" class="" title="在这里插入图片描述"><h2 id="手工求解next数组方法"><a href="#手工求解next数组方法" class="headerlink" title="手工求解next数组方法"></a>手工求解next数组方法</h2><p>以下两种方法互通，分别为以0为初始或以-1为初始</p><p><strong>1.以0为初始</strong></p><div class="table-container"><table><thead><tr><th>i</th><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th><th>10</th></tr></thead><tbody><tr><td> p</td><td>a</td><td>b</td><td>a</td><td>b</td><td>a</td><td>a</td><td>a</td><td>b</td><td>a</td><td>b</td><td>a </td></tr><tr><td> next</td><td>0</td><td>1</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table></div><ol><li>当i=0，1 next[0],next[1]分别初始为0，1</li><li>当i=2,p的前2位为 <code>ab</code>,因<code>next[1]=1</code>，则观察<code>ab</code>的前<code>1</code>位和后<code>1</code>位是否相同，不同，所以<code>next[2]=1</code>(记住后面运算时若连1位相同都没有则记为<code>1</code>，即最小记为1，其实看后面就知道意思是<code>next[i]=0+1=1</code>)</li><li>当i=3,p的前3位为<code>aba</code>,因<code>next[2]=1</code>,则观察<code>aba</code>的前<code>1</code>位和后<code>1</code>位是否相同，相同，则在原基础上<code>+1</code>，即<code>next[3]=1+1=2</code></li><li>当i=4,p的前4位为<code>abab</code>,因<code>next[3]=2</code>,则观察<code>abab</code>的前<code>2</code>位和后<code>2</code>位是否相同，相同，则在原基础上<code>+1</code>，即<code>next[4]=2+1=3</code></li><li>当i=5,p的前5位为<code>ababa</code>,因<code>next[4]=3</code>,则观察<code>ababa</code>的前<code>3</code>位和后<code>3</code>位是否相同，相同，则在原基础上<code>+1</code>，即<code>next[5]=3+1=4</code></li><li>当i=6,p的前6位为<code>ababaa</code>,因<code>next[5]=4</code>,则观察<code>ababaa</code>的前<code>4</code>位和后<code>4</code>位是否相同，不相同，则在原基础上<code>-1</code>，观察前<code>3</code>位和后<code>3</code>位是否相同，不同继续<code>-1</code>，直到观察到前<code>2</code>位和后<code>2</code>位相同，若不同再继续减，后观察到前1位和后1位相同，则next[6]=1+1=2</li><li>当i=7,p的前7位为<code>ababaaa</code>,因<code>next[5]=2</code>,则观察<code>ababaaa</code>的前<code>2</code>位和后<code>2</code>位是否相同，不相同，则在原基础上<code>-1</code>，观察前<code>1</code>位和后<code>1</code>位是否相同，相同，则next[7]=1+1=2</li><li>…</li><li>…</li><li>…   </li></ol><p>最终为</p><div class="table-container"><table><thead><tr><th>i</th><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th><th>10</th></tr></thead><tbody><tr><td>p</td><td>a</td><td>b</td><td>a</td><td>b</td><td>a</td><td>a</td><td>a</td><td>b</td><td>a</td><td>b</td><td>a</td></tr><tr><td>next</td><td>0</td><td>1</td><td>1</td><td>2</td><td>3</td><td>4</td><td>2</td><td>2</td><td>3</td><td>4</td><td>5</td></tr></tbody></table></div><p><strong>2.以-1为初始</strong></p><div class="table-container"><table><thead><tr><th>i</th><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th><th>10</th></tr></thead><tbody><tr><td>p</td><td>a</td><td>b</td><td>a</td><td>b</td><td>a</td><td>a</td><td>a</td><td>b</td><td>a</td><td>b</td><td>a</td></tr><tr><td>next</td><td>-1</td><td>0</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table></div><ol><li>当i=0，1 next[0],next[1]分别初始为-1，0</li><li>当i=2，p的前2位为<code>ab</code>,因<code>next[1]=0</code>，则<code>next[1]+1=1</code>,观察前<code>1</code>位和后<code>1</code>位是否相同，不同，则<code>1-1=0</code>，到0为止，则<code>next[2]=0</code>（<code>1-1=0</code>中第一个1的意思即前1位和后1位是否相同中的1）</li><li>当i=3,p的前3位为<code>aba</code>,因<code>next[2]=0</code>,则<code>next[2]+1=1</code>,则观察的前<code>1</code>位和后<code>1</code>位是否相同，相同，则<code>next[3]=1</code></li><li>当i=4,p的前4位为<code>abab</code>,因<code>next[3]=1</code>,则<code>next[3]+1=2</code>,则观察前<code>2</code>位和后<code>2</code>位是否相同，相同，则<code>next[4]=2</code></li><li>当i=5,p的前5位为<code>ababa</code>,因<code>next[4]=2</code>,则<code>next[4]+1=3</code>,则观察前<code>3</code>位和后<code>3</code>位是否相同，相同，则<code>next[4]=3</code></li><li>当i=6,p的前6位为<code>ababaa</code>,因<code>next[5]=3</code>,则<code>next[5]+1=4</code>,则观察前<code>4</code>位和后<code>4</code>位是否相同，不相同;则观察前<code>3</code>位和后<code>3</code>位是否相同，不同;则观察前<code>2</code>位和后<code>2</code>位是否相同，不相同;则观察前<code>1</code>位和后<code>1</code>位是否相同，相同，则<code>next[6]=1</code></li><li>当i=7,p的前6位为<code>ababaaa</code>,因<code>next[6]=1</code>,则<code>next[6]+1=2</code>,则观察前<code>2</code>位和后<code>2</code>位是否相同，不相同;则观察前<code>1</code>位和后<code>1</code>位是否相同，相同，则<code>next[7]=1</code></li><li>…</li><li>…</li><li><p>…</p><p>最终为</p></li></ol><div class="table-container"><table><thead><tr><th>i</th><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th><th>10</th></tr></thead><tbody><tr><td>p</td><td>a</td><td>b</td><td>a</td><td>b</td><td>a</td><td>a</td><td>a</td><td>b</td><td>a</td><td>b</td><td>a</td></tr><tr><td>next</td><td>-1</td><td>0</td><td>0</td><td>1</td><td>2</td><td>3</td><td>1</td><td>1</td><td>2</td><td>3</td><td>4</td></tr></tbody></table></div><p><strong>俩种方法的关系</strong><br>观察发现法1的next数组每项+1就是法2的next数组，所以考试时无论用哪一种都是可以的，只要<code>分析或者看清</code>是以什么为初值就行<br>其实还可以理解为把法1的next数组向右移1位，并把首位赋值位-1</p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Mysql Err1055 ONLY_FULL_GROUP_BY 存储过程</title>
    <link href="/2019/01/21/Mysql-Err1055-ONLY_FULL_GROUP_BY-%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B/"/>
    <url>/2019/01/21/Mysql-Err1055-ONLY_FULL_GROUP_BY-%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><p>Ubuntu16.04<br>Mysql5.7<br><strong>1.背景</strong><br>Err 1055 报错 sql_moede为ONLY_FULL_GROUP_BY,具体错误原因不介绍了.按提示改变sql_mode后存储过程中仍报改错.<br><strong>2.解决方法</strong><br>修改/etc/mysql/my.cnf 可以在最后加上如下<br><pre><code class="hljs mysql">[mysqld]sql_mode &#x3D;&quot;STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION&quot;</code></pre><br>然后 service mysql restart 重启服务<br>还有一些其他的设置sql_mode的方法,可自行了解<br>但是按照上面方法做完后在查询中不会再报1055,但是使用存储过程仍旧有问题,解决方法就是<br>…<br>…<br>…<br>复制,删除,新建,粘贴!!!<br>新建一个存储过程就OK,具体原因不了解,总之是个大坑</p>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Mysql</tag>
      
      <tag>Bug</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>python numpy的数组切片和其中None的意思</title>
    <link href="/2018/11/02/python-numpy%E7%9A%84%E6%95%B0%E7%BB%84%E5%88%87%E7%89%87%E5%92%8C%E5%85%B6%E4%B8%ADNone%E7%9A%84%E6%84%8F%E6%80%9D/"/>
    <url>/2018/11/02/python-numpy%E7%9A%84%E6%95%B0%E7%BB%84%E5%88%87%E7%89%87%E5%92%8C%E5%85%B6%E4%B8%ADNone%E7%9A%84%E6%84%8F%E6%80%9D/</url>
    
    <content type="html"><![CDATA[<h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><p>python 3.6<br>numpy<br><strong>1.背景</strong><br>    今天有人问我numpy中[1:3,None]是啥意思,一开始讲得云里雾里,后来终于理清了，我们逐步深入研究♂(滑稽)<br><strong>2.一维情况</strong></p><pre><code class="hljs python"><span class="hljs-keyword">import</span>  numpy <span class="hljs-keyword">as</span> npa=np.array([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>])print(a[<span class="hljs-number">0</span>:<span class="hljs-number">3</span>:<span class="hljs-number">2</span>])</code></pre><p>输出</p><pre><code class="hljs python">[<span class="hljs-number">1</span> <span class="hljs-number">3</span>]</code></pre><p>一维应该都知道吧 跟list差不多 [Start:End:Step] 注意是不包含End<br><strong>2.二维情况</strong><br>{% asset_img 20181101011506918.png 在这里插入图片描述 %}</p><pre><code class="hljs python"><span class="hljs-keyword">import</span>  numpy <span class="hljs-keyword">as</span> npa=np.array([[<span class="hljs-number">11</span>,<span class="hljs-number">12</span>,<span class="hljs-number">13</span>,<span class="hljs-number">14</span>],[<span class="hljs-number">21</span>,<span class="hljs-number">22</span>,<span class="hljs-number">23</span>,<span class="hljs-number">24</span>],[<span class="hljs-number">31</span>,<span class="hljs-number">32</span>,<span class="hljs-number">33</span>,<span class="hljs-number">34</span>],[<span class="hljs-number">41</span>,<span class="hljs-number">42</span>,<span class="hljs-number">43</span>,<span class="hljs-number">44</span>]])print(a[<span class="hljs-number">0</span>:<span class="hljs-number">4</span>:<span class="hljs-number">2</span>,<span class="hljs-number">0</span>:<span class="hljs-number">4</span>:<span class="hljs-number">2</span>])</code></pre><p>输出</p><pre><code class="hljs python">[[<span class="hljs-number">11</span> <span class="hljs-number">13</span>] [<span class="hljs-number">31</span> <span class="hljs-number">33</span>]]</code></pre><p>所以第0维取0到4步长为2 ，第1维也取0到4步长为2 ，所以意思是[第0维,第1维]，然后多维类推嘛，应该能理解了吧<br><strong>3.关于None</strong><br>再说说一开始的[:,None]</p><font color=red size=5>emmmm简单说就是说它增加了一个维度</font>但还是有些不同的，看例子<pre><code class="hljs python"><span class="hljs-keyword">import</span>  numpy <span class="hljs-keyword">as</span> npa=np.array([[<span class="hljs-number">11</span>,<span class="hljs-number">12</span>,<span class="hljs-number">13</span>,<span class="hljs-number">14</span>],[<span class="hljs-number">21</span>,<span class="hljs-number">22</span>,<span class="hljs-number">23</span>,<span class="hljs-number">24</span>],[<span class="hljs-number">31</span>,<span class="hljs-number">32</span>,<span class="hljs-number">33</span>,<span class="hljs-number">34</span>],[<span class="hljs-number">41</span>,<span class="hljs-number">42</span>,<span class="hljs-number">43</span>,<span class="hljs-number">44</span>]])print(<span class="hljs-string">'0维为None:'</span>)print(a[<span class="hljs-literal">None</span>,<span class="hljs-number">0</span>:<span class="hljs-number">4</span>])print(<span class="hljs-string">'1维为None:'</span>)print(a[<span class="hljs-number">0</span>:<span class="hljs-number">4</span>,<span class="hljs-literal">None</span>])</code></pre>输出<pre><code class="hljs python"><span class="hljs-number">0</span>维为<span class="hljs-literal">None</span>:[[[<span class="hljs-number">11</span> <span class="hljs-number">12</span> <span class="hljs-number">13</span> <span class="hljs-number">14</span>]  [<span class="hljs-number">21</span> <span class="hljs-number">22</span> <span class="hljs-number">23</span> <span class="hljs-number">24</span>]  [<span class="hljs-number">31</span> <span class="hljs-number">32</span> <span class="hljs-number">33</span> <span class="hljs-number">34</span>]  [<span class="hljs-number">41</span> <span class="hljs-number">42</span> <span class="hljs-number">43</span> <span class="hljs-number">44</span>]]]<span class="hljs-number">1</span>维为<span class="hljs-literal">None</span>:[[[<span class="hljs-number">11</span> <span class="hljs-number">12</span> <span class="hljs-number">13</span> <span class="hljs-number">14</span>]] [[<span class="hljs-number">21</span> <span class="hljs-number">22</span> <span class="hljs-number">23</span> <span class="hljs-number">24</span>]] [[<span class="hljs-number">31</span> <span class="hljs-number">32</span> <span class="hljs-number">33</span> <span class="hljs-number">34</span>]] [[<span class="hljs-number">41</span> <span class="hljs-number">42</span> <span class="hljs-number">43</span> <span class="hljs-number">44</span>]]]</code></pre>看下官方文档,[链接](https://www.numpy.org/devdocs/reference/arrays.indexing.html)<pre><code class="hljs python">Note:Remember that a slicing tuple can always be constructed <span class="hljs-keyword">as</span> obj <span class="hljs-keyword">and</span> used <span class="hljs-keyword">in</span> the x[obj] notation. Slice objects can be used <span class="hljs-keyword">in</span> the construction <span class="hljs-keyword">in</span> place of the [start:stop:step] notation.For example, x[<span class="hljs-number">1</span>:<span class="hljs-number">10</span>:<span class="hljs-number">5</span>,::<span class="hljs-number">-1</span>] can also be implemented <span class="hljs-keyword">as</span> obj = (slice(<span class="hljs-number">1</span>,<span class="hljs-number">10</span>,<span class="hljs-number">5</span>), slice(<span class="hljs-literal">None</span>,<span class="hljs-literal">None</span>,<span class="hljs-number">-1</span>)); x[obj].This can be useful <span class="hljs-keyword">for</span> constructing generic code that works on arrays of arbitrary dimension.</code></pre><pre><code class="hljs python">numpy.newaxisThe newaxis object can be used <span class="hljs-keyword">in</span> all slicing operations to create an axis of length one.newaxis <span class="hljs-keyword">is</span> an alias <span class="hljs-keyword">for</span> ‘<span class="hljs-literal">None</span>’, <span class="hljs-keyword">and</span> ‘<span class="hljs-literal">None</span>’ can be used <span class="hljs-keyword">in</span> place of this <span class="hljs-keyword">with</span> the same result.</code></pre>它巴拉巴拉的意思就是<font color=red size=5>numpy.newaxis效果和None是一样的，None是它的别名</font><pre><code class="hljs python">print(<span class="hljs-literal">None</span> <span class="hljs-keyword">is</span> np.newaxis)<span class="hljs-literal">True</span></code></pre><p>(话说为了少打点字（len(None)&lt;len(numpy.newaxis)）,可能就会让初学者看不懂- -，但是告诉他们答案我想他们肯定想暴打写代码的人♂（呼应前文滑稽）)<br>想更详细的知道numpy.newaxis的可以自己去搜搜啦</p>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>numpy</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python 凯撒加密</title>
    <link href="/2018/10/21/Python-%E5%87%AF%E6%92%92%E5%8A%A0%E5%AF%86/"/>
    <url>/2018/10/21/Python-%E5%87%AF%E6%92%92%E5%8A%A0%E5%AF%86/</url>
    
    <content type="html"><![CDATA[<p>在密码学中，恺撒密码是一种最简单且最广为人知的加密技术。它是一种替换加密的技术，明文中的所有字母都在字母表上向后（或向前）按照一个固定数目进行偏移后被替换成密文。例，当偏移量是3的时候，所有的字母A将被替换成D，B变成E，以此类推。</p><pre><code class="hljs python">n=input(<span class="hljs-string">"请输入移位："</span>)n=int(n)str_mi=input(<span class="hljs-string">"请输入需要加密的字符串："</span>)<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">jiami</span><span class="hljs-params">(str_1,n)</span>:</span>    ans=list(str_1)    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">0</span>,len(ans)):        <span class="hljs-keyword">if</span> ans[i].islower():            num = ord(ans[i])            ans[i] = chr((num - <span class="hljs-number">97</span> + n) % <span class="hljs-number">26</span> + <span class="hljs-number">97</span>)        <span class="hljs-keyword">if</span> ans[i].isupper():            num = ord(ans[i])            ans[i] = chr((num - <span class="hljs-number">65</span> + n) % <span class="hljs-number">26</span> + <span class="hljs-number">65</span>)    <span class="hljs-keyword">return</span> <span class="hljs-string">''</span>.join(ans)<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">jiemi</span><span class="hljs-params">(str_1)</span>:</span>    print(str_1+<span class="hljs-string">"的可能的明文为:"</span>)    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">0</span>,<span class="hljs-number">25</span>):        print(jiami(str_1,i))print(<span class="hljs-string">"加密后为："</span>+jiami(str_mi,n))jiemi(jiami(str_mi,n))</code></pre><img src="/2018/10/21/Python-%E5%87%AF%E6%92%92%E5%8A%A0%E5%AF%86/20181021154702527.png" srcset="/img/loading.gif" class="" title="在这里插入图片描述">]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>习题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>爬取微博热搜榜单存入mysql并部署在云服务器上</title>
    <link href="/2018/10/19/%E7%88%AC%E5%8F%96%E5%BE%AE%E5%8D%9A%E7%83%AD%E6%90%9C%E6%A6%9C%E5%8D%95%E5%AD%98%E5%85%A5mysql%E5%B9%B6%E9%83%A8%E7%BD%B2%E5%9C%A8%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A/"/>
    <url>/2018/10/19/%E7%88%AC%E5%8F%96%E5%BE%AE%E5%8D%9A%E7%83%AD%E6%90%9C%E6%A6%9C%E5%8D%95%E5%AD%98%E5%85%A5mysql%E5%B9%B6%E9%83%A8%E7%BD%B2%E5%9C%A8%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A/</url>
    
    <content type="html"><![CDATA[<h2 id="环境："><a href="#环境：" class="headerlink" title="环境："></a>环境：</h2><p>python3.5.2<br><strong>涉及的库:</strong><br>requests<br>bs4<br>pymysql<br><strong>服务器:</strong><br>Ubuntu16.04<br><strong>1.代码</strong></p><pre><code class="hljs python"><span class="hljs-keyword">import</span> requests<span class="hljs-keyword">import</span> datetime<span class="hljs-keyword">import</span> time<span class="hljs-keyword">import</span> pymysql<span class="hljs-keyword">from</span> bs4 <span class="hljs-keyword">import</span> BeautifulSoup<span class="hljs-keyword">import</span> randomhottime=<span class="hljs-string">''</span><span class="hljs-comment">#时间</span>sql = <span class="hljs-string">"insert into hottop(time,top)values(%s,%s)"</span>db = pymysql.connect(<span class="hljs-string">"数据库的ip"</span>,<span class="hljs-string">"数据库用户名"</span>,<span class="hljs-string">"密码"</span>,<span class="hljs-string">"weibohot"</span>)cursor = db.cursor()<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">Gethot</span><span class="hljs-params">()</span>:</span>    url = <span class="hljs-string">'https://s.weibo.com/top/summary?cate=realtimehot'</span>    <span class="hljs-comment">#这里为了稳定,可以添加一个user-Agent的池,然后每次用的时候随机一个,也可以添加ip池</span>    header=&#123;        <span class="hljs-string">'User-Agent'</span>:<span class="hljs-string">'Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:61.0) Gecko/20100101 Firefox/61.0'</span>    &#125;    <span class="hljs-keyword">try</span>:        <span class="hljs-comment"># global 声明接下来用的hottime是全局变量,</span>        <span class="hljs-comment"># 如果不加这个,它会变成局部变量,即使你在函数外声明了一个hottime</span>        <span class="hljs-keyword">global</span> hottime        hottime = datetime.datetime.now().strftime(<span class="hljs-string">"%Y-%m-%d %H:%M:%S"</span>)        hotweb = requests.get(url, headers=header, timeout=<span class="hljs-number">10</span>)    <span class="hljs-keyword">except</span>:        print(hottime+<span class="hljs-string">':http Error'</span>)    <span class="hljs-keyword">else</span>:        soup = BeautifulSoup(hotweb.text, <span class="hljs-string">"html.parser"</span>)        ans = soup.find_all(<span class="hljs-string">'td'</span>)        top = <span class="hljs-string">''</span>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> ans:            a = i.find(<span class="hljs-string">'a'</span>)  <span class="hljs-comment"># a标签内容，即热搜内容</span>            span = i.find(<span class="hljs-string">'span'</span>)  <span class="hljs-comment"># span标签内的的热度</span>            <span class="hljs-keyword">if</span> (a != <span class="hljs-literal">None</span> <span class="hljs-keyword">and</span> span != <span class="hljs-literal">None</span>):                top += a.get_text() + <span class="hljs-string">'__'</span> + span.get_text() + <span class="hljs-string">'\n'</span>        <span class="hljs-keyword">return</span> toperrorcount=<span class="hljs-number">0</span><span class="hljs-comment">#5次错误跳出循环</span><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:    <span class="hljs-keyword">try</span>:        top = Gethot()        cursor.execute(sql,(hottime,top))    <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:        errorcount+=<span class="hljs-number">1</span>        db.rollback()        print(hottime+<span class="hljs-string">":执行MySQL: %s 时出错：%s"</span> % (sql, e))        <span class="hljs-keyword">if</span>(errorcount==<span class="hljs-number">5</span>):            <span class="hljs-keyword">break</span>        <span class="hljs-keyword">else</span>:            time.sleep(<span class="hljs-number">10</span>)            <span class="hljs-keyword">continue</span>    <span class="hljs-keyword">else</span>:        db.commit()        time.sleep(random.randint(<span class="hljs-number">450</span>,<span class="hljs-number">550</span>))<span class="hljs-comment">#每次sleep随机450-550秒</span></code></pre><p><strong>2.数据表</strong></p><div class="table-container"><table><thead><tr><th>time</th><th>top</th></tr></thead><tbody><tr><td>datetime</td><td>varchar(2000)</td></tr></tbody></table></div><p>DDL语句:(不设置utf-8可能会出错- -)<br><pre><code class="hljs mysql">CREATE TABLE &#96;hottop&#96; (  &#96;time&#96; datetime NOT NULL,  &#96;top&#96; varchar(2000) NOT NULL)DEFAULT CHARSET&#x3D;utf8;</code></pre><br><strong>3.部署到服务器</strong><br>如果你是在本地写的代码,先把文件上传到服务器(可以通过ftp啥的,方法多多),<br>关于运行,weibohot.py是代码文件, log.file是通过print输出的日志文件(可以不必先创建,运行下面命令它自己也会创建)</p><pre><code class="hljs shell">nohup python3 -u weibohot.py &gt; log.file 2&gt;&amp;1 &amp;</code></pre><p>nohup命令可以看<a href="https://blog.csdn.net/liuyanfeier/article/details/62422742" target="_blank" rel="noopener">这篇文章</a>,我觉得介绍的很精简明要,现在市面上的云服务基本都给你装好了python2和3环境,直接用python命令的话一开始都应该默认为2,-u参数是不启用缓冲(否则你print出来的东西可能不会马上输出到log.file日志中)<br>其实仅仅如此还是不够的,它在运行中可能还会遇到各种问题之类的,因此想要更好的可以写个shell脚本,断线邮件提醒啊,重连啊…<br><strong>4.结果</strong><br><img src="/2018/10/19/%E7%88%AC%E5%8F%96%E5%BE%AE%E5%8D%9A%E7%83%AD%E6%90%9C%E6%A6%9C%E5%8D%95%E5%AD%98%E5%85%A5mysql%E5%B9%B6%E9%83%A8%E7%BD%B2%E5%9C%A8%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A/20181019001055507.png" srcset="/img/loading.gif" class="" title="在这里插入图片描述"></p>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>爬虫</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用阿里云ECS安装mysql及远程登录的一些小问题</title>
    <link href="/2018/10/15/%E4%BD%BF%E7%94%A8%E9%98%BF%E9%87%8C%E4%BA%91ECS%E5%AE%89%E8%A3%85mysql%E5%8F%8A%E8%BF%9C%E7%A8%8B%E7%99%BB%E5%BD%95%E7%9A%84%E4%B8%80%E4%BA%9B%E5%B0%8F%E9%97%AE%E9%A2%98/"/>
    <url>/2018/10/15/%E4%BD%BF%E7%94%A8%E9%98%BF%E9%87%8C%E4%BA%91ECS%E5%AE%89%E8%A3%85mysql%E5%8F%8A%E8%BF%9C%E7%A8%8B%E7%99%BB%E5%BD%95%E7%9A%84%E4%B8%80%E4%BA%9B%E5%B0%8F%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p><strong>1.Unable to locate package xxx</strong> </p><img src="/2018/10/15/%E4%BD%BF%E7%94%A8%E9%98%BF%E9%87%8C%E4%BA%91ECS%E5%AE%89%E8%A3%85mysql%E5%8F%8A%E8%BF%9C%E7%A8%8B%E7%99%BB%E5%BD%95%E7%9A%84%E4%B8%80%E4%BA%9B%E5%B0%8F%E9%97%AE%E9%A2%98/20181015222129131.png" srcset="/img/loading.gif" class="" title="在这里插入图片描述"><p>解决方法:</p><pre><code>sudo apt-get update</code></pre><p><strong>2.远程登录</strong><br>        选择创建一个用于远程登录的用户:</p><pre><code class="hljs shell">GRANT ALL PRIVILEGES ON *.* TO 'username'@'%' IDENTIFIED BY 'password' WITH GRANT OPTION;</code></pre><p>生效:</p><pre><code class="hljs shell">flush privileges;</code></pre><p>​        接下来一步,看了网上许多说的,都是vim /etc/mysql/my.cnf 将里面的bind-address = 127.0.0.1改为0.0.0.0,我试了下 然后进行重启服务(/etc/init.d/mysql restart),最后遇到报错:<br>mysql.serviceJob for mysql.service failed because the control process exited with error code. See “systemctl status mysql.service” and “journalctl -xe” for details.failed!</p><img src="/2018/10/15/%E4%BD%BF%E7%94%A8%E9%98%BF%E9%87%8C%E4%BA%91ECS%E5%AE%89%E8%A3%85mysql%E5%8F%8A%E8%BF%9C%E7%A8%8B%E7%99%BB%E5%BD%95%E7%9A%84%E4%B8%80%E4%BA%9B%E5%B0%8F%E9%97%AE%E9%A2%98/20181015222017843.png" srcset="/img/loading.gif" class="" title="在这里插入图片描述"><p>???<br><img src="/2018/10/15/%E4%BD%BF%E7%94%A8%E9%98%BF%E9%87%8C%E4%BA%91ECS%E5%AE%89%E8%A3%85mysql%E5%8F%8A%E8%BF%9C%E7%A8%8B%E7%99%BB%E5%BD%95%E7%9A%84%E4%B8%80%E4%BA%9B%E5%B0%8F%E9%97%AE%E9%A2%98/20181015222342177.png" srcset="/img/loading.gif" class="" title="在这里插入图片描述"><br>回去 仔细看/etc/mysql/my.cnf<br>我去!!!<br><img src="/2018/10/15/%E4%BD%BF%E7%94%A8%E9%98%BF%E9%87%8C%E4%BA%91ECS%E5%AE%89%E8%A3%85mysql%E5%8F%8A%E8%BF%9C%E7%A8%8B%E7%99%BB%E5%BD%95%E7%9A%84%E4%B8%80%E4%BA%9B%E5%B0%8F%E9%97%AE%E9%A2%98/20181015222729516.png" srcset="/img/loading.gif" class="" title="在这里插入图片描述"><br>emm他的意思是说配置文件在那俩目录下…果然在操作的时候还是要仔细看下的- -<br>两个我都进去看了下 结果是在</p><pre><code class="hljs shell">vim  /etc/mysql/mysql.conf.d/mysqld.cnf</code></pre><p>找到bind-address改为0.0.0.0(任意ip可访问),也可以设成自己的,在第一次那个文件里我还好奇咋没有bind-address,虎得我直接加了一行上去…</p><img src="/2018/10/15/%E4%BD%BF%E7%94%A8%E9%98%BF%E9%87%8C%E4%BA%91ECS%E5%AE%89%E8%A3%85mysql%E5%8F%8A%E8%BF%9C%E7%A8%8B%E7%99%BB%E5%BD%95%E7%9A%84%E4%B8%80%E4%BA%9B%E5%B0%8F%E9%97%AE%E9%A2%98/20181015223338455.png" srcset="/img/loading.gif" class="" title="在这里插入图片描述"><p>重启服务  /etc/init.d/mysql restart  ,ok<br>Navicat连接测试成功</p><p><img src="使用阿里云ECS安装mysql及远程登录的一些小问题/20181015224839569.png" srcset="/img/loading.gif" alt="在这里插入图片描述" style="zoom:50%;" /></p><p><strong>重要</strong><br>netstat -anp|grep 3306<br>查看3306端口有没有开启,没有的话去阿里云那添加安全规则,不细写了</p>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Mysql</tag>
      
      <tag>Bug</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>requests模拟登录（基础向）以及打印成pdf时使用pdfkit时出现的一些问题</title>
    <link href="/2018/10/13/requests%E6%A8%A1%E6%8B%9F%E7%99%BB%E5%BD%95%EF%BC%88%E5%9F%BA%E7%A1%80%E5%90%91%EF%BC%89%E4%BB%A5%E5%8F%8A%E6%89%93%E5%8D%B0%E6%88%90pdf%E6%97%B6%E4%BD%BF%E7%94%A8pdfkit%E6%97%B6%E5%87%BA%E7%8E%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98/"/>
    <url>/2018/10/13/requests%E6%A8%A1%E6%8B%9F%E7%99%BB%E5%BD%95%EF%BC%88%E5%9F%BA%E7%A1%80%E5%90%91%EF%BC%89%E4%BB%A5%E5%8F%8A%E6%89%93%E5%8D%B0%E6%88%90pdf%E6%97%B6%E4%BD%BF%E7%94%A8pdfkit%E6%97%B6%E5%87%BA%E7%8E%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p>需求时这样的：学校有一个判题网，当期末的时候要把提交的结果一页一页的打印成pdf交给老师<br>因为是内网，模拟登录十分简单我就简单写一下，但是我在使用pdfkit时出现了一些问题（强迫症问题），最终也没找到很好的解决方法，如果有dalao有想法恳请告诉 - -！</p><h2 id="环境："><a href="#环境：" class="headerlink" title="环境："></a>环境：</h2><p>python3.6<br><strong>涉及的库:</strong><br>requests<br>pdfkit<br>re<br><strong>1.模拟登录</strong><br><img src="/2018/10/13/requests%E6%A8%A1%E6%8B%9F%E7%99%BB%E5%BD%95%EF%BC%88%E5%9F%BA%E7%A1%80%E5%90%91%EF%BC%89%E4%BB%A5%E5%8F%8A%E6%89%93%E5%8D%B0%E6%88%90pdf%E6%97%B6%E4%BD%BF%E7%94%A8pdfkit%E6%97%B6%E5%87%BA%E7%8E%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98/20181013013638153.png" srcset="/img/loading.gif" class="" title="在这里插入图片描述"><br>登录的url如上 我们关注hearder里最后几个就行，先构造出来header</p><pre><code class="hljs plain">header&#x3D;&#123;&#39;uer-aGent&#39;:&#39;Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64; rv:61.0) Gecko&#x2F;20100101 Firefox&#x2F;61.0&#39;,&#39;Referer&#39;:&#39;http:&#x2F;&#x2F;**.***.***.***&#x2F;&#39;,&#39;Host&#39;:&#39;**.***.***.***&#39;&#125;</code></pre><img src="/2018/10/13/requests%E6%A8%A1%E6%8B%9F%E7%99%BB%E5%BD%95%EF%BC%88%E5%9F%BA%E7%A1%80%E5%90%91%EF%BC%89%E4%BB%A5%E5%8F%8A%E6%89%93%E5%8D%B0%E6%88%90pdf%E6%97%B6%E4%BD%BF%E7%94%A8pdfkit%E6%97%B6%E5%87%BA%E7%8E%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98/20181013014502706.png" srcset="/img/loading.gif" class="" title="在这里插入图片描述"><p>这是需要post的参数，第一个参数csrfmid…啥的我们发现就是cookie中的一个</p><p>接下来我们来讲讲如何获取cookie，因为是学生自己用的，验证很low，我们先通过requests.Session（）获得一个session（这里不懂的强烈建议先去搞懂Session和Cookie），我们先通过session.get（）先尝试登录一下，因为我们没有提交任何表单数据，毫无疑问是失败的，但是我们却因此获得了cookie，具体看代码，十分简单<br><pre><code class="hljs python"><span class="hljs-keyword">import</span> requests<span class="hljs-keyword">import</span> re<span class="hljs-keyword">import</span> time<span class="hljs-keyword">import</span> pdfkitpostdata=&#123;<span class="hljs-string">'password'</span>:<span class="hljs-string">'******'</span>,<span class="hljs-string">'username'</span>:<span class="hljs-string">'*******'</span>&#125;session = requests.Session()<span class="hljs-comment">#登录</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">Getcookiesandlogin</span><span class="hljs-params">()</span>:</span>    posturl = <span class="hljs-string">'http://**.***.***.***/user/logincheck/'</span>    session.get(<span class="hljs-string">'http://**.***.***.***/'</span>,headers=header)<span class="hljs-comment">#通过这次来获取cookie</span>    postdata[<span class="hljs-string">'csrfmiddlewaretoken'</span>]=session.cookies.get_dict()[<span class="hljs-string">'csrftoken'</span>]<span class="hljs-comment">#把cookie加入表单参数中</span>    session.post(posturl, data=postdata,headers=header)</code></pre><br><strong>2.pdfkit</strong><br>pdfkit依赖于<a href="https://wkhtmltopdf.org/downloads.html" target="_blank" rel="noopener">wkhtmltopdf</a>，链接为下载地址，我下的是windos的MXE (MinGW-w64)，直接解压就行，使用的时候设置一下路径参数就ok<br><pre><code class="hljs python">path=<span class="hljs-string">'E:/wkhtmltopdf/wkhtmltox/bin/wkhtmltopdf.exe'</span><span class="hljs-comment">#你解压后的路径</span>config = pdfkit.configuration(wkhtmltopdf=path)</code></pre></p><p>先说最后都没有解决的问题吧，看两幅图片的对比<br>1.<br><img src="/2018/10/13/requests%E6%A8%A1%E6%8B%9F%E7%99%BB%E5%BD%95%EF%BC%88%E5%9F%BA%E7%A1%80%E5%90%91%EF%BC%89%E4%BB%A5%E5%8F%8A%E6%89%93%E5%8D%B0%E6%88%90pdf%E6%97%B6%E4%BD%BF%E7%94%A8pdfkit%E6%97%B6%E5%87%BA%E7%8E%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98/20181013021751279.png" srcset="/img/loading.gif" class="" title="在这里插入图片描述"><br>2.<img src="/2018/10/13/requests%E6%A8%A1%E6%8B%9F%E7%99%BB%E5%BD%95%EF%BC%88%E5%9F%BA%E7%A1%80%E5%90%91%EF%BC%89%E4%BB%A5%E5%8F%8A%E6%89%93%E5%8D%B0%E6%88%90pdf%E6%97%B6%E4%BD%BF%E7%94%A8pdfkit%E6%97%B6%E5%87%BA%E7%8E%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98/20181013015556342.png" srcset="/img/loading.gif" class="" title="在这里插入图片描述"><br>emmm，就是空白（红框圈出），打印pdf的时候会出现空白，而且这些空白是有些pdf有，有些pdf没有的，而这些空白也不仅仅是出现在页与页的分隔之间。。。<br><em>只截取关于pdfkit的一段代码吧（这是最后的）</em></p><pre><code class="hljs python">text=session.get(url)css=[<span class="hljs-string">'E:\Pycharm\MyProjects\monidenglupanti\css\shCore.css'</span>,<span class="hljs-string">'E:\Pycharm\MyProjects\monidenglupanti\css\shThemeDefault.css'</span>,     <span class="hljs-string">'E:\Pycharm\MyProjects\monidenglupanti\css\global.css'</span>,<span class="hljs-string">'E:\Pycharm\MyProjects\monidenglupanti\css\group.css'</span>,     <span class="hljs-string">'E:\Pycharm\MyProjects\monidenglupanti\css\printstyle.css'</span>]name=re.findall(<span class="hljs-string">r'&lt;title&gt;(.*) &lt;/title&gt;'</span>,text.text)[<span class="hljs-number">0</span>].replace(<span class="hljs-string">' '</span>,<span class="hljs-string">''</span>)name=name.replace(<span class="hljs-string">':'</span>,<span class="hljs-string">'_'</span>)path=<span class="hljs-string">'E:/Pycharm/MyProjects/monidenglupanti/'</span>+name+<span class="hljs-string">'.pdf'</span>h=text.text.replace(<span class="hljs-string">'/js/media/js/scripts/'</span>,<span class="hljs-string">'js/'</span>)h = text.text.replace(<span class="hljs-string">'/js/media/js/'</span>, <span class="hljs-string">'js/'</span>)<span class="hljs-comment">#这里外链的路径变成‘C:\Users\76083\AppData\Local\Temp\’，改成其他路径失效，没解决- -！</span>pdfkit.from_string(h,output_path=path,configuration=config,css=css)</code></pre><p>苦逼历程：<br>1.一开始，发现打印的pdf没有样式，好，把网页的样式下载下来，添加进去，<br>后来发现，打印出来的pdf还是有些小地方不一样，想破脑袋，此处省略万字。。。<br>2.突然想到有些应该是javascript动态生成的！好，咱再把他也全部下载下来<br>（下载方法：Internet选项-常规-先点删除-选择临时文件(全清了也ok就当清理垃圾了)-删除后刷新一下你要下载的网页-再点设置-再点查看文件，好，里面就全是这个网站的css和js文件了）。<br>3.然后加载javascritpt，把网页中js的相对路径改成我需要的觉得路径，发现又发现设置其他盘无用（它还是会ignore）只能设置在‘C:\Users\76083\AppData\Local\Temp\’？？？算了，屈服<br>4.满心欢心运行效果，样式啥的全对了，看到空白，强迫症卒</p>]]></content>
    
    
    <categories>
      
      <category>python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>爬虫</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>12306余票及票价查询</title>
    <link href="/2018/10/09/%E4%BD%99%E7%A5%A8%E5%8F%8A%E7%A5%A8%E4%BB%B7%E6%9F%A5%E8%AF%A2/"/>
    <url>/2018/10/09/%E4%BD%99%E7%A5%A8%E5%8F%8A%E7%A5%A8%E4%BB%B7%E6%9F%A5%E8%AF%A2/</url>
    
    <content type="html"><![CDATA[<p>还原整个思路，遇到的一些问题也会写出来，纯新手向，因为打包在了一个类里，所以单独拷贝一个函数可能会有些问题,后面有完整代码地址，如有错误可以指正- -有问题也可以留言，后面写的有些赶，可以去完整源代码中看看<br>截至2018/10/9   0:15代码还是有效的</p><h2 id="环境："><a href="#环境：" class="headerlink" title="环境："></a>环境：</h2><p>python3.6<br><strong>涉及的库:</strong><br>requests<br>json<br>prettytable<br>re<br>pprint<br><strong>1.url分析</strong><br>    先打开<a href="https://kyfw.12306.cn/otn/leftTicket/init" target="_blank" rel="noopener">12306的余票查询</a>，我用的是火狐浏览器，按F12打开调试工具选择network（网络）选项，选择出发地，目的地，日期，点击查询<br>    <img src="/2018/10/09/%E4%BD%99%E7%A5%A8%E5%8F%8A%E7%A5%A8%E4%BB%B7%E6%9F%A5%E8%AF%A2/20181008211309564.png" srcset="/img/loading.gif" class="" title="在这里插入图片描述"><br>（小白问题：调试窗口里啥也没有是因为 你一番操作猛如虎，结果完事后想起：哎？调试窗口没打开！）<br>右上角有一排选项，咱选js，xhr 然后从这一条条里找出我们需要的链接（点的时候在右边选择响应，可以看到这条请求返回啥）哇塞！你找到一串data，里面还有各种车票的信息，好了，就是你了：<br><a href="https://kyfw.12306.cn/otn/leftTicket/queryA?leftTicketDTO.train_date=2018-10-23&amp;leftTicketDTO.from_station=HZH&amp;leftTicketDTO.to_station=RZH&amp;purpose_codes=ADULT" target="_blank" rel="noopener">https://kyfw.12306.cn/otn/leftTicket/queryA?leftTicketDTO.train_date=2018-10-23&amp;leftTicketDTO.from_station=HZH&amp;leftTicketDTO.to_station=RZH&amp;purpose_codes=ADULT</a><br><img src="/2018/10/09/%E4%BD%99%E7%A5%A8%E5%8F%8A%E7%A5%A8%E4%BB%B7%E6%9F%A5%E8%AF%A2/20181008212636116.png" srcset="/img/loading.gif" class="" title="在这里插入图片描述"><br><strong>PS</strong>：找json链接这种活就看经验了，老手可能马上就能找到，新手可能就要一条条点（汗~~）我这给一个快速的方法：进入余票查询界面，选择好出发地和目的地及日期，点击查询，好！然后再打开F12调试界面在点查询！哇塞只有1条而且就是我们需要的！（深入原因的话就是在你打开了调试界面后你只进行了这一条查询的post请求，而返回的当然就是你要的了）<br><img src="/2018/10/09/%E4%BD%99%E7%A5%A8%E5%8F%8A%E7%A5%A8%E4%BB%B7%E6%9F%A5%E8%AF%A2/20181008213803841.png" srcset="/img/loading.gif" class="" title="在这里插入图片描述"><br>好,继续正题,我们来观察这条json的链接,很容易明白那些参数吧,如下:<br><a href="https://kyfw.12306.cn/otn/leftTicket/queryA?leftTicketDTO.train_date=2018-10-23&amp;leftTicketDTO.from_station=HZH&amp;leftTicketDTO.to_station=RZH&amp;purpose_codes=ADULT" target="_blank" rel="noopener">https://kyfw.12306.cn/otn/leftTicket/queryA?leftTicketDTO.train_date=2018-10-23&amp;leftTicketDTO.from_station=HZH&amp;leftTicketDTO.to_station=RZH&amp;purpose_codes=ADULT</a><br>leftTicketDTO.train_date=日期<br>leftTicketDTO.from_station=出发点的地点码<br>leftTicketDTO.to_station=目的地的地点码<br>purpose_codes=票的种类<br><strong>2.获取车站对照字典</strong><br>上文链接中有两个参数是地点码,即一个地名对应一个值,一开始我是直接下载了网上(baidu喽)的一个字典,然后最后写完.不对!我靠!而且调试半天定位到字典错了!(这么多的地名偏偏被窝测试到错误的也是没谁了…）<br><img src="/2018/10/09/%E4%BD%99%E7%A5%A8%E5%8F%8A%E7%A5%A8%E4%BB%B7%E6%9F%A5%E8%AF%A2/20181008220408892.png" srcset="/img/loading.gif" class="" title="在这里插入图片描述"><br>好!自己动手!</p><pre><code class="hljs python"><span class="hljs-keyword">import</span> requests<span class="hljs-keyword">import</span> re<span class="hljs-comment">#生成字典 运行一次后抛弃之~~~</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">new_dictionary</span><span class="hljs-params">()</span>:</span>    url=<span class="hljs-string">"https://kyfw.12306.cn/otn/resources/js/framework/station_name.js?station_version=1.9069"</span>    station_namesweb=requests.get(url)    stationdic = re.findall(<span class="hljs-string">r'([\u4e00-\u9fa5]+)\|([a-zA-Z]+)'</span>, station_namesweb.text)    stationdic=dict(stationdic)    print(stationdic)new_dictionary()</code></pre><p>requests请求,json打包,正则提取,over!<br>打印出一个字典复制然后在一个文件里就ok了(上面代码中的url其实也是一样找的,可以试试手去找找看)哈哈,其实这也是今天整个工程的浓缩版吧,思路也是差不多的<br><strong>3.输入出发点,目的地,时间,获得需要的查询链接</strong><br>废多看码!!!</p><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">getUrl</span><span class="hljs-params">(self)</span>:</span>    startflag = <span class="hljs-literal">False</span>    endflag = <span class="hljs-literal">False</span>    <span class="hljs-keyword">while</span> startflag == <span class="hljs-literal">False</span>:        start = input(<span class="hljs-string">"请输入始发地：\n"</span>)        startflag = stations.__contains__(start)        <span class="hljs-keyword">if</span> startflag == <span class="hljs-literal">False</span>:            print(<span class="hljs-string">'始发地输入错误！'</span>)    <span class="hljs-keyword">while</span> endflag == <span class="hljs-literal">False</span>:        end = input(<span class="hljs-string">"请输入目的地：\n"</span>)        endflag = stations.__contains__(end)        <span class="hljs-keyword">if</span> endflag == <span class="hljs-literal">False</span>:            print(<span class="hljs-string">'目的地输入错误！'</span>)    self.date = input(<span class="hljs-string">"请输入日期(格式为xxxx-xx-xx)：\n"</span>)    url = <span class="hljs-string">'https://kyfw.12306.cn/otn/leftTicket/queryA?leftTicketDTO.train_date='</span> \          + self.date + <span class="hljs-string">'&amp;leftTicketDTO.from_station='</span> \          + stations[start] + <span class="hljs-string">'&amp;leftTicketDTO.to_station='</span> \          + stations[end] + <span class="hljs-string">'&amp;purpose_codes=ADULT'</span>    <span class="hljs-keyword">return</span> url</code></pre><p><strong>4.获取车辆信息</strong><br>因为12306在这里没做啥验证所以可以直接请求,不妨直接在浏览器里看一下,emmm是不是头都大了!!!!<br><img src="/2018/10/09/%E4%BD%99%E7%A5%A8%E5%8F%8A%E7%A5%A8%E4%BB%B7%E6%9F%A5%E8%AF%A2/20181008233255654.png" srcset="/img/loading.gif" class="" title="在这里插入图片描述"><br>车辆的信息都在这里了,用|分隔开,我们要做的就是从里面提取出我们想要的信息,emmm其实我花的时间最多的是在这里,因为要一一对应知道每个信息代表什么,而我又找不到那么一辆每个信息都齐全的车来让我对照…只能用好几辆的信息来对比喽（还不一定是对的，眼力有限）…我的眼睛!!!<br><img src="/2018/10/09/%E4%BD%99%E7%A5%A8%E5%8F%8A%E7%A5%A8%E4%BB%B7%E6%9F%A5%E8%AF%A2/20181008234420942.png" srcset="/img/loading.gif" class="" title="在这里插入图片描述"></p><blockquote><p><code>乱码|预订|030000K5540E|K551|MDB|RZH|HZH|RZH|02:31|10:50|08:19|Y|乱码|20181021|3|B2|44|52|0|0||||无|||无||有|10|||||10401030|1413|0</code></p><p>上代码:<br><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">getData</span><span class="hljs-params">(self,url)</span>:</span>    dataweb = requests.get(url)    datajson = json.loads(dataweb.text)    datatrains = datajson[<span class="hljs-string">'data'</span>][<span class="hljs-string">'result'</span>]    restations=datajson[<span class="hljs-string">'data'</span>][<span class="hljs-string">'map'</span>]<span class="hljs-comment">#地点缩写：地点全称的字典</span>    dataans = []    <span class="hljs-keyword">for</span> train <span class="hljs-keyword">in</span> datatrains:        per = &#123;            <span class="hljs-string">'train_no'</span>: <span class="hljs-string">''</span>,            <span class="hljs-string">'from_station_no'</span>: <span class="hljs-string">''</span>,            <span class="hljs-string">'to_station_no'</span>: <span class="hljs-string">''</span>,            <span class="hljs-string">'seat_types'</span>: <span class="hljs-string">''</span>,            <span class="hljs-string">'chufazhan'</span>:<span class="hljs-string">''</span>,            <span class="hljs-string">'dadaozhan'</span>:<span class="hljs-string">''</span>,            <span class="hljs-string">'checi'</span>: <span class="hljs-string">''</span>,            <span class="hljs-string">'chufasj'</span>: <span class="hljs-string">''</span>,            <span class="hljs-string">'didasj'</span>: <span class="hljs-string">''</span>,            <span class="hljs-string">'lishi'</span>: <span class="hljs-string">''</span>,            <span class="hljs-string">'erdeng'</span>: <span class="hljs-string">''</span>,            <span class="hljs-string">'yideng'</span>: <span class="hljs-string">''</span>,            <span class="hljs-string">'shangwu'</span>: <span class="hljs-string">''</span>,            <span class="hljs-string">'wuzuo'</span>:<span class="hljs-string">''</span>        &#125;        train = train.split(<span class="hljs-string">'|'</span>)        per[<span class="hljs-string">'train_no'</span>] = train[<span class="hljs-number">2</span>]        per[<span class="hljs-string">'from_station_no'</span>] = train[<span class="hljs-number">16</span>]        per[<span class="hljs-string">'to_station_no'</span>] = train[<span class="hljs-number">17</span>]        per[<span class="hljs-string">'seat_types'</span>] = train[<span class="hljs-number">35</span>]        per[<span class="hljs-string">'chufazhan'</span>]=train[<span class="hljs-number">6</span>]        per[<span class="hljs-string">'dadaozhan'</span>]=train[<span class="hljs-number">7</span>]        <span class="hljs-comment">#将得到站点名字由缩写转换全称</span>        per[<span class="hljs-string">'chufazhan'</span>]=restations[per[<span class="hljs-string">'chufazhan'</span>]]        per[<span class="hljs-string">'dadaozhan'</span>]=restations[per[<span class="hljs-string">'dadaozhan'</span>]]        per[<span class="hljs-string">'checi'</span>] = train[<span class="hljs-number">3</span>]        per[<span class="hljs-string">'chufasj'</span>] = train[<span class="hljs-number">8</span>]        per[<span class="hljs-string">'didasj'</span>] = train[<span class="hljs-number">9</span>]        per[<span class="hljs-string">'lishi'</span>] = train[<span class="hljs-number">10</span>]        per[<span class="hljs-string">'erdeng'</span>] = train[<span class="hljs-number">30</span>]        per[<span class="hljs-string">'yideng'</span>] = train[<span class="hljs-number">31</span>]        per[<span class="hljs-string">'shangwu'</span>] = train[<span class="hljs-number">32</span>]        per[<span class="hljs-string">'wuzuo'</span>]=train[<span class="hljs-number">26</span>]        <span class="hljs-keyword">for</span> value <span class="hljs-keyword">in</span> per:            <span class="hljs-keyword">if</span> (per[value] == <span class="hljs-string">''</span>):                per[value] = <span class="hljs-string">'-'</span>        dataans.append(per)    <span class="hljs-keyword">return</span> dataans</code></pre><br>PS：这里有个问题要说明下：比如我朋友温州-金华，而金华有两个站，他只要其中一个站的，所以我们得显示出出发站和抵达站到底是哪个，但是在信息中我们获得地点是一个码而不是一个站的名字，而我们的字典中是 {名字：码}，一开始我想要不干脆再做个反转的字典，后来往上翻的时候发现：原来上面已经给我们了！解决！计划通~<br><img src="/2018/10/09/%E4%BD%99%E7%A5%A8%E5%8F%8A%E7%A5%A8%E4%BB%B7%E6%9F%A5%E8%AF%A2/20181009004354618.png" srcset="/img/loading.gif" class="" title="在这里插入图片描述"><br><strong>5.获取票价信息</strong><br>票价的url是另外一条了,获取方式同上上,老方法请求,解析,打包<br><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">GetPrice</span><span class="hljs-params">(self,train_no,from_station_no,to_station_no,seat_types,date,price)</span>:</span>    url = <span class="hljs-string">'https://kyfw.12306.cn/otn/leftTicket/queryTicketPrice?train_no='</span> \          + train_no + <span class="hljs-string">'&amp;from_station_no='</span> \          + from_station_no + <span class="hljs-string">'&amp;to_station_no='</span> \          + to_station_no + <span class="hljs-string">'&amp;seat_types='</span> \          + seat_types + <span class="hljs-string">'&amp;train_date='</span> + date    priceweb=requests.get(url)    pricejson=json.loads(priceweb.text)    pricedata=pricejson[<span class="hljs-string">'data'</span>]    shangwu=pricedata.__contains__(<span class="hljs-string">'A9'</span>)<span class="hljs-comment">#商务</span>    yideng=pricedata.__contains__(<span class="hljs-string">'M'</span>)<span class="hljs-comment">#一等</span>    erdeng=pricedata.__contains__(<span class="hljs-string">'O'</span>)<span class="hljs-comment">#二等</span>    wuzuo=pricedata.__contains__(<span class="hljs-string">'WZ'</span>)<span class="hljs-comment">#无座</span>    <span class="hljs-keyword">if</span> shangwu:        price[<span class="hljs-string">'shangwu'</span>]=pricedata[<span class="hljs-string">'A9'</span>]    <span class="hljs-keyword">else</span> :        price[<span class="hljs-string">'shangwu'</span>]=<span class="hljs-string">''</span>    <span class="hljs-keyword">if</span> yideng:        price[<span class="hljs-string">'yideng'</span>]=pricedata[<span class="hljs-string">'M'</span>]    <span class="hljs-keyword">else</span> :        price[<span class="hljs-string">'yideng'</span>]=<span class="hljs-string">''</span>    <span class="hljs-keyword">if</span> erdeng:        price[<span class="hljs-string">'erdeng'</span>]=pricedata[<span class="hljs-string">'O'</span>]    <span class="hljs-keyword">else</span> :        price[<span class="hljs-string">'erdeng'</span>]=<span class="hljs-string">''</span>    <span class="hljs-keyword">if</span> wuzuo:        price[<span class="hljs-string">'wuzuo'</span>]=pricedata[<span class="hljs-string">'WZ'</span>]    <span class="hljs-keyword">else</span> :        price[<span class="hljs-string">'wuzuo'</span>]=<span class="hljs-string">''</span>    <span class="hljs-keyword">return</span> price</code></pre><br><strong>6.输出</strong><br>用了prettytable库输出表格<br><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">Print</span><span class="hljs-params">(self)</span>:</span>    price=&#123;        <span class="hljs-string">'shangwu'</span>:<span class="hljs-string">''</span>,        <span class="hljs-string">'yideng'</span>:<span class="hljs-string">''</span>,        <span class="hljs-string">'erdeng'</span>:<span class="hljs-string">''</span>,        <span class="hljs-string">'wuzuo'</span>:<span class="hljs-string">''</span>,    &#125;    table = prettytable.PrettyTable()    table.field_names = [<span class="hljs-string">"车次"</span>,<span class="hljs-string">"出发站"</span>,<span class="hljs-string">"达到站"</span> ,<span class="hljs-string">"出发时间"</span>, <span class="hljs-string">"抵达时间"</span>, <span class="hljs-string">"历时"</span>, <span class="hljs-string">"二等座"</span>, <span class="hljs-string">"一等座"</span>, <span class="hljs-string">"商务座"</span>,<span class="hljs-string">"无座"</span>]    <span class="hljs-keyword">for</span> per <span class="hljs-keyword">in</span> self.data:        price=self.GetPrice(per[<span class="hljs-string">'train_no'</span>],per[<span class="hljs-string">'from_station_no'</span>],per[<span class="hljs-string">'to_station_no'</span>],per[<span class="hljs-string">'seat_types'</span>],self.date,price)        table.add_row([per[<span class="hljs-string">'checi'</span>],per[<span class="hljs-string">'chufazhan'</span>],per[<span class="hljs-string">'dadaozhan'</span>], per[<span class="hljs-string">'chufasj'</span>], per[<span class="hljs-string">'didasj'</span>], per[<span class="hljs-string">'lishi'</span>], per[<span class="hljs-string">'erdeng'</span>]+<span class="hljs-string">'\n'</span>+price[<span class="hljs-string">'erdeng'</span>], per[<span class="hljs-string">'yideng'</span>]+<span class="hljs-string">'\n'</span>+price[<span class="hljs-string">'yideng'</span>],                       per[<span class="hljs-string">'shangwu'</span>]+<span class="hljs-string">'\n'</span>+price[<span class="hljs-string">'shangwu'</span>],per[<span class="hljs-string">'wuzuo'</span>]+<span class="hljs-string">'\n'</span>+price[<span class="hljs-string">'wuzuo'</span>]])    print(table)</code></pre><br><strong>7.演示</strong><br><img src="/2018/10/09/%E4%BD%99%E7%A5%A8%E5%8F%8A%E7%A5%A8%E4%BB%B7%E6%9F%A5%E8%AF%A2/20181008235639135.png" srcset="/img/loading.gif" class="" title="在这里插入图片描述"><br>8.完整代码<br><a href="https://github.com/senjay/12306tickets_and_price_search" target="_blank" rel="noopener">https://github.com/senjay/12306tickets_and_price_search</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>爬虫</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
